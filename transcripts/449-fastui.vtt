WEBVTT

00:00:00.000 --> 00:00:04.600
Building web UIs in Python has always been an interesting proposition.

00:00:04.600 --> 00:00:09.800
On one end, we have the full web design story with artisanal HTML and CSS.

00:00:09.800 --> 00:00:15.040
On the other end, there are several Python platforms that aim to bring RAD, Rapid Application

00:00:15.040 --> 00:00:19.080
Development style of building Python apps to the web.

00:00:19.080 --> 00:00:23.520
Those can be great, and I've covered a couple of them, but they usually reach a limit on

00:00:23.520 --> 00:00:28.160
what you can do or how they integrate with the larger web ecosystem.

00:00:28.160 --> 00:00:33.360
On this episode, we have Samuel Colvin back to share his latest exciting project, Fast

00:00:33.360 --> 00:00:34.640
UI.

00:00:34.640 --> 00:00:39.140
With Fast UI, you can build responsive web applications using React without writing a

00:00:39.140 --> 00:00:42.600
single line of JavaScript or touching NPM.

00:00:42.600 --> 00:00:48.120
Yet designers and other tools can focus on React front ends for a professional spa-like

00:00:48.120 --> 00:00:50.160
app experience.

00:00:50.160 --> 00:00:55.720
This is Talk Python to Me, episode 449, recorded December 14th, 2023.

00:00:55.720 --> 00:01:13.440
Welcome to Talk Python to Me, a weekly podcast on Python.

00:01:13.440 --> 00:01:15.280
This is your host, Michael Kennedy.

00:01:15.280 --> 00:01:20.200
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:01:20.200 --> 00:01:22.840
both on fosstodon.org.

00:01:22.840 --> 00:01:28.080
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:01:28.080 --> 00:01:31.560
We've started streaming most of our episodes live on YouTube.

00:01:31.560 --> 00:01:37.680
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be

00:01:37.680 --> 00:01:40.580
part of that episode.

00:01:40.580 --> 00:01:43.480
This episode is sponsored by Bright Data.

00:01:43.480 --> 00:01:47.200
Bright Data is professional web scraping and a dataset marketplace.

00:01:47.200 --> 00:01:54.720
If you need data and it doesn't have an API, check out talkpython.fm/brightdata today.

00:01:54.720 --> 00:01:57.040
And it's brought to you by Sentry.

00:01:57.040 --> 00:01:58.920
Don't let those errors go unnoticed.

00:01:58.920 --> 00:02:01.400
Use Sentry like we do here at Talk Python.

00:02:01.400 --> 00:02:02.880
Sign up at talkpython.fm/sentry.

00:02:02.880 --> 00:02:08.080
Hey, Samuel, welcome back to Talk Python to Me.

00:02:08.080 --> 00:02:09.080
- Thank you.

00:02:09.080 --> 00:02:10.080
Thank you very much for having me again.

00:02:10.080 --> 00:02:11.520
So soon after last time.

00:02:11.520 --> 00:02:13.600
- It's always amazing to have you on.

00:02:13.600 --> 00:02:20.480
In fact, you were on just last week in a really cool show that tons of people enjoyed and

00:02:20.480 --> 00:02:24.400
is not yet out at the time of recording, but will be released to the world by the time

00:02:24.400 --> 00:02:25.960
your show goes out live.

00:02:25.960 --> 00:02:28.320
So it's a bit of a time travel thing.

00:02:28.320 --> 00:02:29.420
Very, very appropriate here.

00:02:29.420 --> 00:02:35.960
But it was under the full-time open source developers panel of like a bunch of folks.

00:02:35.960 --> 00:02:40.840
For example, Charlie Marsh, Will McGugan, Gina Houska, and so on.

00:02:40.840 --> 00:02:46.320
And you snuck in for a minute there on your travels, but now you're back and we're here

00:02:46.320 --> 00:02:52.280
to talk properly about something really excellent that you put together called Fast UI, which

00:02:52.280 --> 00:02:53.960
is gonna be a lot of fun.

00:02:53.960 --> 00:02:55.320
- Yeah, thanks so much for having me.

00:02:55.320 --> 00:03:02.240
And yeah, I'm in a slightly better environment for a podcast than the stairwell of a restaurant

00:03:02.240 --> 00:03:03.240
somewhere in Istanbul.

00:03:03.240 --> 00:03:05.120
So yeah, it's nice to be here.

00:03:05.120 --> 00:03:06.440
- High marks for effort there.

00:03:06.440 --> 00:03:08.480
Come on, that was great.

00:03:08.480 --> 00:03:12.360
- It was good fun, but this is a better place to talk about these things.

00:03:12.360 --> 00:03:16.200
- Yeah, well, I hope you had a good trip and you're back and at it.

00:03:16.200 --> 00:03:18.880
Kim out in the audience points out, "Hey, could you just write another impressive tool

00:03:18.880 --> 00:03:20.320
for the next week's show?

00:03:20.320 --> 00:03:23.560
'Cause things are going pretty prolifically over there."

00:03:23.560 --> 00:03:27.720
You tell people a bit about Pydantic, the company, they probably heard of the library,

00:03:27.720 --> 00:03:29.400
but just what are you up to these days?

00:03:29.400 --> 00:03:34.480
- So Pydantic's obviously been around since 2017 originally, but then it's like something

00:03:34.480 --> 00:03:36.400
weird happened at the beginning of 2021.

00:03:36.400 --> 00:03:40.600
I don't know quite what that was, but Pydantic, the downloads just went crazy.

00:03:40.600 --> 00:03:44.040
So we were at like 5 million downloads then and we're now at 130 million.

00:03:44.040 --> 00:03:46.560
So yeah, it's gone crazy.

00:03:46.560 --> 00:03:49.560
And then just a bit more than a year ago, I was very lucky.

00:03:49.560 --> 00:03:53.680
Sequoia got in touch with me and basically said that I want to start a company.

00:03:53.680 --> 00:03:58.520
I had been meaning to do that after I released Pydantic V2 that I was then working on.

00:03:58.520 --> 00:04:03.720
Yeah, I started the company beginning of this year and now have an amazing team of 10 people

00:04:03.720 --> 00:04:04.800
working with me.

00:04:04.800 --> 00:04:08.680
So we released Pydantic V2 finally, having originally told people it would take me alone

00:04:08.680 --> 00:04:09.680
three months.

00:04:09.680 --> 00:04:14.920
It took me and I guess then six people a year in total, but that was released back in the

00:04:14.920 --> 00:04:19.240
summer and now we're working on a platform that I'm not going to talk about now, but

00:04:19.240 --> 00:04:23.040
I would love it if you'd have me back, I guess, beginning of Q2.

00:04:23.040 --> 00:04:24.040
- Is that next week or whatever?

00:04:24.040 --> 00:04:25.040
- It's not quite next week.

00:04:25.040 --> 00:04:26.040
- Q2 2024, something like that?

00:04:26.040 --> 00:04:27.040
- Yeah.

00:04:27.040 --> 00:04:28.040
- Okay.

00:04:28.040 --> 00:04:32.800
- I think we're going to try and get to open beta in Q1.

00:04:32.800 --> 00:04:33.800
So yeah.

00:04:33.800 --> 00:04:34.800
- Okay, fantastic.

00:04:34.800 --> 00:04:35.800
Yeah, well.

00:04:35.800 --> 00:04:40.760
- But off the back of, so that without getting into a lot of details on it, has platform

00:04:40.760 --> 00:04:41.760
components to it.

00:04:41.760 --> 00:04:45.120
And so we have people, people will be logging in, et cetera, et cetera.

00:04:45.120 --> 00:04:50.280
And I was just thinking about all of the path and the churn of building the relatively mechanical

00:04:50.280 --> 00:04:54.600
bits of an application again, with, it doesn't matter actually if you're building it with

00:04:54.600 --> 00:04:58.560
React or with one of the other front end frameworks, you end up having a whole bunch of stuff that's

00:04:58.560 --> 00:05:03.480
duplicated between what the front end guys are doing and what the full stack developers

00:05:03.480 --> 00:05:06.240
or the backend developers are building for us.

00:05:06.240 --> 00:05:08.880
And I guess for lots of people, there's a Pydantic model that's kind of at the core

00:05:08.880 --> 00:05:10.280
of lots of those bits.

00:05:10.280 --> 00:05:12.400
And I was just dreading all of that churn.

00:05:12.400 --> 00:05:16.320
And I had been wanting to build something like FastUI for a long time, but the fact

00:05:16.320 --> 00:05:20.160
that we're going to be using it internally really spurred me on to go and get it built

00:05:20.160 --> 00:05:24.200
and release it in a very incomplete phase to see what people thought.

00:05:24.200 --> 00:05:26.320
And yeah, there's been a great reaction and here I am.

00:05:26.320 --> 00:05:29.200
- Yeah, there has been quite the reaction to it.

00:05:29.200 --> 00:05:32.160
Let's see, do the GitHub star test.

00:05:32.160 --> 00:05:37.120
It's 2.6 thousand stars and it's what, two weeks old?

00:05:37.120 --> 00:05:38.120
A month old?

00:05:38.120 --> 00:05:39.240
Yeah, a month old.

00:05:39.240 --> 00:05:40.240
Last month anyway.

00:05:40.240 --> 00:05:43.640
- Well, it was only released publicly like, yeah, two weeks, it left them two weeks ago.

00:05:43.640 --> 00:05:45.040
Or maybe two weeks ago today.

00:05:45.040 --> 00:05:46.040
- Oh, that's right.

00:05:46.040 --> 00:05:49.120
Yeah, you probably, so you worked on it a little bit private and then you flipped the

00:05:49.120 --> 00:05:50.840
bit on the public status.

00:05:50.840 --> 00:05:52.360
Yeah, that makes a lot of sense.

00:05:52.360 --> 00:05:55.120
Because you don't want people just to go, "Whoa, what are they building?"

00:05:55.120 --> 00:05:56.120
Maybe you do.

00:05:56.120 --> 00:05:58.400
Maybe you're like, "What is this GitHub repo?"

00:05:58.400 --> 00:05:59.400
They misspelled FastAPI.

00:05:59.400 --> 00:06:01.360
I don't know what they're working on.

00:06:01.360 --> 00:06:02.360
- Yeah, exactly.

00:06:02.360 --> 00:06:06.880
And also, I mean, we have a team with lots of people who've done lots of open source,

00:06:06.880 --> 00:06:08.680
very strongly opinionated engineers.

00:06:08.680 --> 00:06:12.600
I can't even get my team to use it without kind of proving the value in it.

00:06:12.600 --> 00:06:15.600
So I worked on it a bit without really talking to them and then was like, "Right, I built

00:06:15.600 --> 00:06:18.280
this thing, let's at least give it a try."

00:06:18.280 --> 00:06:23.120
I don't know, maybe I'm wrong in this, but I think it's quite a fundamentally different

00:06:23.120 --> 00:06:29.480
way of thinking about how you build user interfaces from lots of the tools that exist today in

00:06:29.480 --> 00:06:30.480
the Python ecosystem.

00:06:30.480 --> 00:06:34.920
And so there's a bit of a like education piece and trying to understand the principle as

00:06:34.920 --> 00:06:37.840
well as the like mechanics of going and using it.

00:06:37.840 --> 00:06:38.840
- Yeah, absolutely.

00:06:38.840 --> 00:06:43.000
Well, we're gonna dive into the philosophy, but I'll give people the too long, didn't

00:06:43.000 --> 00:06:44.000
read version.

00:06:44.000 --> 00:06:49.680
Basically, you can create UIs in pure Python in sort of dynamic web framework friendly

00:06:49.680 --> 00:06:51.240
ways, right?

00:06:51.240 --> 00:06:55.880
- Yeah, probably the mistake is in my description of it because yes, it does that.

00:06:55.880 --> 00:07:01.400
But where I personally think FastUI is powerful and where we're using it within the Pydantic

00:07:01.400 --> 00:07:06.040
team is actually, we have got front-end developers, we've got some really expert guys who are

00:07:06.040 --> 00:07:08.600
very comfortable building stuff in React.

00:07:08.600 --> 00:07:14.680
But we want those two roles to have to constantly communicate to build every individual bit.

00:07:14.680 --> 00:07:18.160
So the idea is, I think if you go down the page a little bit, I kind of explained it.

00:07:18.160 --> 00:07:22.960
But like for a Python developer, it's this way of building UIs without having to touch

00:07:22.960 --> 00:07:29.040
TypeScript or JavaScript or NPM or any of those Byzantine like massive build tools.

00:07:29.040 --> 00:07:32.760
But then for a front-end developer, it's this opportunity to go and build the best components

00:07:32.760 --> 00:07:38.760
you can and allow, basically provide a powerful interface for your backend guys to go and

00:07:38.760 --> 00:07:40.320
build a UI with it.

00:07:40.320 --> 00:07:45.040
So kind of split those two things up and I guess allow React to do what React does brilliantly,

00:07:45.040 --> 00:07:47.920
which is provide these like reusable components.

00:07:47.920 --> 00:07:49.240
- Yeah, absolutely.

00:07:49.240 --> 00:07:54.120
Kind of a framework as well to bring the navigation and the cohesion of the whole app together,

00:07:54.120 --> 00:07:57.080
not just a particular view or a page too, you would say, right?

00:07:57.080 --> 00:08:01.040
- Yeah, so the weird bit is principle of RESTful interfaces.

00:08:01.040 --> 00:08:03.960
We've all heard of REST or RESTful and we all think we know what it means, which is

00:08:03.960 --> 00:08:09.480
basically something to do with a URL structure and return me some JSON that like gives me

00:08:09.480 --> 00:08:11.160
the data I need to render my view.

00:08:11.160 --> 00:08:17.680
Well, if you look at the Roy Fielding's original PhD, as is brilliantly described in this HTMX

00:08:17.680 --> 00:08:21.560
article that I talk about further on down here, he's not really talking about that stuff.

00:08:21.560 --> 00:08:26.680
Sure, he has some stuff on what the URL structure should be, but really his principle is that

00:08:26.680 --> 00:08:32.160
the data returned from the backend should be self-describing as if it should have everything

00:08:32.160 --> 00:08:34.200
you need to go and render the user interface.

00:08:34.200 --> 00:08:39.760
So let's say, I think they're using the HTMX example, example of like a bank account.

00:08:39.760 --> 00:08:43.840
And if you go down to like principle, the long version, here we are, right?

00:08:43.840 --> 00:08:47.720
I've linked to the PhD, but more importantly, the HTMX article, which explains it really

00:08:47.720 --> 00:08:48.720
well.

00:08:48.720 --> 00:08:52.000
I think if we follow that, yeah, I think they'll even on that page, there's a very jokey tone

00:08:52.000 --> 00:08:55.200
lots of the time HTMX, but they also have a really cool thing.

00:08:55.200 --> 00:08:56.200
- Yeah, absolutely.

00:08:56.200 --> 00:08:58.040
- Somewhere I think they have, yeah, here we are, right?

00:08:58.040 --> 00:09:02.080
So if you look at the traditional JSON response, which I think is the second one, and you were

00:09:02.080 --> 00:09:03.480
trying to show, yeah, right.

00:09:03.480 --> 00:09:07.440
So this, you and I as humans can read this and be like, yeah, that kind of explains my

00:09:07.440 --> 00:09:09.000
bank account and what's going on.

00:09:09.000 --> 00:09:10.000
But there was not enough-

00:09:10.000 --> 00:09:13.480
- Right, it's got like an account number and a balance, which is a more complicated object,

00:09:13.480 --> 00:09:15.440
nested objects and those types of things.

00:09:15.440 --> 00:09:18.240
- Right, it's got all the things that we can read account number, cool, that's a number

00:09:18.240 --> 00:09:20.160
balance, yeah, that makes sense.

00:09:20.160 --> 00:09:23.600
But if you're a computer, there's not enough there to go and render someone the nice user

00:09:23.600 --> 00:09:26.800
interface they would want where they would have it displayed on a page.

00:09:26.800 --> 00:09:33.000
So if you were the engineering team in the bank trying to turn this into a web interface,

00:09:33.000 --> 00:09:38.520
you then need to go and have lots of very application specific or page specific logic

00:09:38.520 --> 00:09:41.840
to show where the account number goes and where the balance goes and where the status

00:09:41.840 --> 00:09:42.840
goes and stuff like that.

00:09:42.840 --> 00:09:46.480
And that causes enormous amounts of churn and it means that it's particularly difficult

00:09:46.480 --> 00:09:50.440
when you have those engineers working at different time zones because you end up having this

00:09:50.440 --> 00:09:51.880
spec between the two.

00:09:51.880 --> 00:09:55.360
And then you always have this problem with software where, fine, we can get it to work,

00:09:55.360 --> 00:09:57.080
but what happens when we come to add it?

00:09:57.080 --> 00:10:02.400
So what's the process of, let's say we want to show as well on this page, your like joint

00:10:02.400 --> 00:10:04.680
account balance, let's say, just to make something up.

00:10:04.680 --> 00:10:09.280
What we probably need to do is we need to get backend guys to go and add that to end

00:10:09.280 --> 00:10:13.520
point and then the front end and that can be deployed and then the front end can be

00:10:13.520 --> 00:10:15.880
updated to show that and the data is available.

00:10:15.880 --> 00:10:18.600
That is a lots of churn, lots of delay in that.

00:10:18.600 --> 00:10:19.600
Right.

00:10:19.600 --> 00:10:23.520
Lots of coordination between the two domain experts and then it kind of, you got that

00:10:23.520 --> 00:10:28.000
microservice cascading, like it's got to do, then this one's got to be upgraded.

00:10:28.000 --> 00:10:31.920
And then eventually there's enough flow of data through the system that the UI people

00:10:31.920 --> 00:10:33.880
can put it up there, right?

00:10:33.880 --> 00:10:34.880
Right.

00:10:34.880 --> 00:10:38.240
And so, and it's bad in this case of like showing your bank balance, but it gets even

00:10:38.240 --> 00:10:43.640
worse when you have a pool where every field in the form needs to be, needs to be completed,

00:10:43.640 --> 00:10:44.680
for example.

00:10:44.680 --> 00:10:48.600
And so we basically have to deploy the front end that has all of the form components and

00:10:48.600 --> 00:10:52.520
the backend that receives that new form at the same time.

00:10:52.520 --> 00:10:56.180
And we've got this piloting model that, you know, depending on how we've done it probably

00:10:56.180 --> 00:10:59.640
is used to define our form and it might even be used to define our database.

00:10:59.640 --> 00:11:04.360
But like we're not using a piloting model in the front end TypeScript, in my opinion,

00:11:04.360 --> 00:11:09.120
the big Achilles heel in typing is that you don't have any, you can't use type in at runtime.

00:11:09.120 --> 00:11:12.360
And so we don't have an equivalent of I'd answer it.

00:11:12.360 --> 00:11:15.040
And so we're basically trusting that data is how it is.

00:11:15.040 --> 00:11:19.800
So yeah, FastAPI is a, is an attempt, sorry, fast UI is an attempt to basically remove

00:11:19.800 --> 00:11:25.840
that need to like have complete synchronization between backend and front end by having beautifully

00:11:25.840 --> 00:11:28.180
designed components in the front end.

00:11:28.180 --> 00:11:31.440
Not saying what we have now is that beautiful, but that's the idea long term.

00:11:31.440 --> 00:11:35.720
But then the backend can basically just do the orchestration can say, show me a table,

00:11:35.720 --> 00:11:40.280
show me a form, show me a modal and put the following content in it, et cetera.

00:11:40.280 --> 00:11:41.280
Excellent.

00:11:41.280 --> 00:11:44.320
Nice comment from Tony on the audience says I originally started in Python and went to

00:11:44.320 --> 00:11:45.320
using TypeScript.

00:11:45.320 --> 00:11:49.000
Pydantic made the transition back to Python so nice.

00:11:49.000 --> 00:11:54.600
And so in your description, you also have up here that this Pydantic is interesting,

00:11:54.600 --> 00:11:55.600
is involved here.

00:11:55.600 --> 00:11:58.920
Like what is the role that Pydantic plays in defining all this?

00:11:58.920 --> 00:12:04.140
So the idea is that we're getting to have this restful UI is really that we, we end

00:12:04.140 --> 00:12:09.280
up having a bunch of components in a shared definition of some components.

00:12:09.280 --> 00:12:13.740
And we basically promise that the backend is going to send data that matches the types

00:12:13.740 --> 00:12:15.720
defined in the front end.

00:12:15.720 --> 00:12:19.680
That's all very well, but if you're not careful, you end up not sending quite the right data.

00:12:19.680 --> 00:12:25.780
So what's nice is that all of the components that you can return from fast UI are themselves

00:12:25.780 --> 00:12:26.780
Pydantic models.

00:12:26.780 --> 00:12:31.880
So Pydantic goes off and does not only the validation, but also the coercion and it does

00:12:31.880 --> 00:12:33.440
stuff like uses camel case.

00:12:33.440 --> 00:12:37.440
So the front end developers are happy because we've got every no underscores anywhere.

00:12:37.440 --> 00:12:43.000
And so yeah, the, all of the front end, sorry, the backend code for fast UI is basically,

00:12:43.000 --> 00:12:46.600
it's just Pydantic models, which, which implement these components.

00:12:46.600 --> 00:12:47.600
Right.

00:12:47.600 --> 00:12:50.880
So it might be useful for those who can't see this to go in and I can talk through an

00:12:50.880 --> 00:12:55.720
example if we go into the code here and I can talk you through like a very basic component.

00:12:55.720 --> 00:12:57.640
Oh, maybe it'd be, I showed it here.

00:12:57.640 --> 00:13:02.480
So I've got, got the code base open here, just working on something.

00:13:02.480 --> 00:13:08.440
But if I open up here, source and then the Python package, and then we look into components

00:13:08.440 --> 00:13:13.180
and we can look at like a really simple component, probably a button, which would be kind of

00:13:13.180 --> 00:13:14.180
understandable to everyone.

00:13:14.180 --> 00:13:15.180
Where's button?

00:13:15.180 --> 00:13:16.180
Here we are.

00:13:16.180 --> 00:13:20.480
So this is just a plain Pydantic model, which contains text, which is the text you would

00:13:20.480 --> 00:13:21.760
put within the button.

00:13:21.760 --> 00:13:27.120
Then it contains the event that you want to fire when someone clicks on it and HTML type,

00:13:27.120 --> 00:13:33.500
which matches what you can get in HTML, button, reset, submits, and then class name, which

00:13:33.500 --> 00:13:35.860
becomes the classes that get applied.

00:13:35.860 --> 00:13:39.280
And then critically this type, which is a literal, which has to be button.

00:13:39.280 --> 00:13:45.160
And that is used by the discriminated union in Pydantic to do the validation of different

00:13:45.160 --> 00:13:46.160
types.

00:13:46.160 --> 00:13:51.400
And it's also used by a big switch statement in the, in the TypeScripts to basically decide

00:13:51.400 --> 00:13:54.840
what component I'll go and render when I, when I get an object.

00:13:54.840 --> 00:13:55.840
Right.

00:13:55.840 --> 00:14:01.800
So there's some TypeScript, maybe it makes sense to talk a bit about the building blocks.

00:14:01.800 --> 00:14:06.440
So you say FastUI is made up of four things just so people can get a sense of like, you

00:14:06.440 --> 00:14:07.760
know, what's at play here.

00:14:07.760 --> 00:14:08.760
Right.

00:14:08.760 --> 00:14:12.640
So, so the four things that we have now package a Python package called FastUI, which I was

00:14:12.640 --> 00:14:18.280
just showing you there, the types for, and then we have NPM package called FastUI again,

00:14:18.280 --> 00:14:23.920
it's in the Pydantic organization, which is where the meat of the, of the logic resides.

00:14:23.920 --> 00:14:29.000
And that's, that's implementing basically the most of the components and all of the,

00:14:29.000 --> 00:14:33.120
the wiring to mean that when I return a button, a button, the button component gets, gets

00:14:33.120 --> 00:14:34.120
rendered.

00:14:34.120 --> 00:14:38.120
And then, but obviously we don't probably want to end up using a vanilla button when

00:14:38.120 --> 00:14:40.280
we come to display it.

00:14:40.280 --> 00:14:46.340
So then I've implemented basic customization of the FastUI React library using Bootstrap.

00:14:46.340 --> 00:14:50.980
And all that's really doing is it's deciding what classes to append to use with each component

00:14:50.980 --> 00:14:52.680
and also just customizing a few of them.

00:14:52.680 --> 00:14:56.000
So for example, modal, there's no like nice way to do a vanilla modal.

00:14:56.000 --> 00:15:01.040
So the modal implementation in the default FastUI package just basically shows me alert

00:15:01.040 --> 00:15:02.840
saying this isn't implemented.

00:15:02.840 --> 00:15:05.520
Whereas the Bootstrap one uses a nice Bootstrap modal.

00:15:05.520 --> 00:15:11.560
And then we have finally FastUI prebuilt, which basically uses the FastUI package, customizes

00:15:11.560 --> 00:15:14.360
it with FastUI Bootstrap and then, and then builds it.

00:15:14.360 --> 00:15:19.820
And that means we can, we can go and basically return that prebuilt React app without having

00:15:19.820 --> 00:15:24.260
to get our hands dirty with NPM on yarn and all the other.

00:15:24.260 --> 00:15:29.420
All the web packy bundling minifying transpiling business.

00:15:29.420 --> 00:15:34.260
But the cool bit, in my opinion of FastUI is that at its core, it's really the definition

00:15:34.260 --> 00:15:36.460
of a bunch of different schemas effectively.

00:15:36.460 --> 00:15:41.100
Those schemas are defined in Pydantic and they're defined in TypeScript, but they could

00:15:41.100 --> 00:15:45.360
perfectly well be, and really nicely, I just merged it the other day.

00:15:45.360 --> 00:15:52.980
We now use the JSON schema generated by Pydantic and JSON schema generated by the React types

00:15:52.980 --> 00:15:57.460
to basically go and test that there's an equivalence between those two, those models everywhere.

00:15:57.460 --> 00:16:01.320
But in theory, there's nothing to stop the front end from being built with another JavaScript

00:16:01.320 --> 00:16:06.240
library or even, even with something like HTML and HTMX, or even you could go and use

00:16:06.240 --> 00:16:09.540
React Native and builds, or even some kind of embedded device.

00:16:09.540 --> 00:16:11.540
You could go and implement those components.

00:16:11.540 --> 00:16:16.860
And then on the other side, and this is even more achievable, you could go and return data

00:16:16.860 --> 00:16:21.440
that matches those models from a Rust or Go service.

00:16:21.440 --> 00:16:24.880
And in theory, not have to change your UI at all, because all you're doing is I promise

00:16:24.880 --> 00:16:29.000
that I'm going to match these schemas and then whatever front end and whatever back

00:16:29.000 --> 00:16:31.080
end can then communicate.

00:16:31.080 --> 00:16:32.800
Whether that comes to pass, I don't know yet.

00:16:32.800 --> 00:16:36.620
And obviously I built the default backend in Python, because that's what I know best

00:16:36.620 --> 00:16:42.000
and where I think Pydantic is really helpful and I built the first front end in React and

00:16:42.000 --> 00:16:43.640
TypeScript because one, that's what I know.

00:16:43.640 --> 00:16:45.520
And two, it's what we're using within Pydantic.

00:16:45.520 --> 00:16:48.440
But there's a, you asked, lots of people have asked about HTMX.

00:16:48.440 --> 00:16:50.980
People have also asked about Svelte and others.

00:16:50.980 --> 00:16:55.360
I think I wouldn't see the point in building like fast UI in Vue because I don't think

00:16:55.360 --> 00:16:56.360
it adds much.

00:16:56.360 --> 00:16:57.360
It's just a lot of work.

00:16:57.360 --> 00:17:03.600
But I think there's a world where we build a HTMX template rendered version of fast UI's

00:17:03.600 --> 00:17:05.160
front end that could be super valuable.

00:17:05.160 --> 00:17:06.160
That's interesting.

00:17:06.160 --> 00:17:11.360
So first point is these different components sound like they are potentially a little mix

00:17:11.360 --> 00:17:12.360
and match.

00:17:12.360 --> 00:17:15.460
You know, you could take it all as one big thing, or you could say really like the way

00:17:15.460 --> 00:17:20.600
it defines the React front end, but we're going to implement it some other end point.

00:17:20.600 --> 00:17:21.600
Yeah.

00:17:21.600 --> 00:17:25.880
I think it's something like, it'll be slightly skewed now because of tests, but I'd say it's

00:17:25.880 --> 00:17:30.960
sort of twice as much front end to backend at the moment as in the, yeah, it's skewed

00:17:30.960 --> 00:17:33.360
a bit by test, but even now there's more TypeScript.

00:17:33.360 --> 00:17:37.400
So I think the simplest thing to do, and you could do it pretty trivially, would be to

00:17:37.400 --> 00:17:42.000
use another backend, another language for your backend service.

00:17:42.000 --> 00:17:45.640
And as long as it matches those types, and you could even go and use something like JSON

00:17:45.640 --> 00:17:47.120
Schema to enforce that.

00:17:47.120 --> 00:17:51.880
But yeah, re-implementing the front end, probably a bigger piece of work, but totally doable.

00:17:51.880 --> 00:17:54.680
I mean, I did it in my spare time in two weeks, built the whole thing.

00:17:54.680 --> 00:17:56.840
So it's not, you know, millions of different things.

00:17:56.840 --> 00:18:00.460
There's kind of 20 components at the moment that are then composable to build reasonably

00:18:00.460 --> 00:18:02.400
sophisticated like UIs.

00:18:02.400 --> 00:18:09.640
So this is a web front end like Flask or Django sort of framework, but a way that really incorporates

00:18:09.640 --> 00:18:15.880
building the UI in Python and validating and enforcing that with PyDandic rather than just,

00:18:15.880 --> 00:18:17.680
Hey, file new HTML.

00:18:17.680 --> 00:18:21.680
Let's just start typing and hope they line up, you know, like instead of trying to juggle

00:18:21.680 --> 00:18:26.720
all those different languages, CSS, HTML, all the JavaScript tooling for packing up

00:18:26.720 --> 00:18:29.080
stuff, just let's write Python, right?

00:18:29.080 --> 00:18:35.160
So maybe you got a simple example of what it looks like to define a real simple example

00:18:35.160 --> 00:18:37.700
here on the readme.

00:18:37.700 --> 00:18:44.000
It's got a very interesting parity between what is in the HTML DOM and is what is in

00:18:44.000 --> 00:18:49.080
the Python abstract syntax tree, I guess, right?

00:18:49.080 --> 00:18:53.040
And visually as well, the way you look at the code, it looks like the way it might look

00:18:53.040 --> 00:18:54.040
in HTML.

00:18:54.040 --> 00:18:57.560
Like give us a sense of what writing a UI in this would look like.

00:18:57.560 --> 00:18:58.560
Right.

00:18:58.560 --> 00:19:01.240
So I think the first of all, we have to talk about like the two enormous, the two most

00:19:01.240 --> 00:19:03.120
obvious pitfalls for this.

00:19:03.120 --> 00:19:09.000
One end of the pitfall you have, which I think is the biggest temptation is to basically

00:19:09.000 --> 00:19:12.280
mirror all of HTML in Python.

00:19:12.280 --> 00:19:16.440
And for those of us who are happy writing HTML or writing React, that sounds like hell.

00:19:16.440 --> 00:19:19.400
It's going to be slow because you have to do some weird rendering, but it's also just

00:19:19.400 --> 00:19:23.880
going to be a pig because I don't want to have to define every A, hre and everything

00:19:23.880 --> 00:19:25.800
else in Python code.

00:19:25.800 --> 00:19:29.960
It's just, and there are going to be, it requires for start, it requires you to know two things,

00:19:29.960 --> 00:19:35.120
Python and HTML, whereas HTML, you only need to know one.

00:19:35.120 --> 00:19:39.160
This portion of Talk Python to Me is brought to you by Bright Data.

00:19:39.160 --> 00:19:43.360
Bright Data helps you turn websites into structured data.

00:19:43.360 --> 00:19:47.000
There's an unimaginable amount of data available on the internet.

00:19:47.000 --> 00:19:53.200
And we're lucky to live in a time where we have so many APIs to access structured data.

00:19:53.200 --> 00:19:59.160
But the truth is that most of the data out there is not served up over a clean API.

00:19:59.160 --> 00:20:02.220
Just sitting there on a web page as HTML.

00:20:02.220 --> 00:20:06.960
Maybe it's even further obscured behind some front end JavaScript framework like view or

00:20:06.960 --> 00:20:07.960
react.

00:20:07.960 --> 00:20:10.760
What if you need access to that data?

00:20:10.760 --> 00:20:12.960
Web scraping to the rescue, right?

00:20:12.960 --> 00:20:17.800
Yes, but just like you wouldn't set up your own production infrastructure in your home

00:20:17.800 --> 00:20:22.960
office, running a web scraping job on a single computer at a fixed location can lead to your

00:20:22.960 --> 00:20:28.440
program being unreliable with data pinned to that IP location and much of the time blocked

00:20:28.440 --> 00:20:31.320
for rate limits and other such causes.

00:20:31.320 --> 00:20:36.040
If you need to do professional web scraping, bright data is the place to start.

00:20:36.040 --> 00:20:40.400
They have award winning proxy networks and powerful web scrapers.

00:20:40.400 --> 00:20:43.840
What's more is they have ready to use data sets for download.

00:20:43.840 --> 00:20:46.400
So you might not even need to scrape data at all.

00:20:46.400 --> 00:20:51.680
And if you can't find the data set in their marketplace, they'll even build a custom data

00:20:51.680 --> 00:20:53.200
set for you.

00:20:53.200 --> 00:20:57.080
From listening to the show, you know that I'm a privacy conscious person.

00:20:57.080 --> 00:21:02.160
And that's why I'm happy to see that they are both CCPA and GDPR compliant.

00:21:02.160 --> 00:21:07.400
Bright Data has both low code solutions as well as Python programming models with async

00:21:07.400 --> 00:21:09.400
IO and playwright.

00:21:09.400 --> 00:21:14.280
So if you have serious data needs, and those websites don't offer API's, then you need

00:21:14.280 --> 00:21:19.880
bright data, check them out today at talkpython.fm/bright data.

00:21:19.880 --> 00:21:24.800
And please use that URL that way they know you heard about them from us.

00:21:24.800 --> 00:21:27.240
That's talkpython.fm/ bright data.

00:21:27.240 --> 00:21:29.480
The link is in your podcast player show notes.

00:21:29.480 --> 00:21:33.240
Thank you to bright data for supporting the show.

00:21:33.240 --> 00:21:37.920
I always find these things that try to dodge like dodge the fact that HTML exists.

00:21:37.920 --> 00:21:40.480
I find them I just they don't resonate with me.

00:21:40.480 --> 00:21:46.440
I'm not entirely sure why it's like we have really nice things like CSS and we have really

00:21:46.440 --> 00:21:53.160
all there's just so much tooling and frameworks, you know, you mentioned bootstrap already,

00:21:53.160 --> 00:21:54.680
right, that just plug into there.

00:21:54.680 --> 00:21:58.040
And if it's like, well, we're just going to write, recreate it in Python.

00:21:58.040 --> 00:22:03.080
Well, it has all the oddities of HTML if it's going to be really high parity, and then you

00:22:03.080 --> 00:22:06.440
just have a less well known way to do the same weird thing.

00:22:06.440 --> 00:22:08.760
You know, I don't know, just it doesn't resonate super with me.

00:22:08.760 --> 00:22:09.760
I agree.

00:22:09.760 --> 00:22:14.200
And I found the same thing at times with ORMs that you end up the worst case of an ORM is

00:22:14.200 --> 00:22:19.280
you work out what you need to do in SQL, then you try and translate back from SQL to ORM.

00:22:19.280 --> 00:22:21.240
And it would be much nicer just to write my SQL.

00:22:21.240 --> 00:22:25.120
I mean, not always the case, ORMs can be powerful, but I think that they, they both can fall

00:22:25.120 --> 00:22:28.020
into the same same trap if you're not careful.

00:22:28.020 --> 00:22:30.680
And then I was gonna say at the far end of the spectrum, the other end of the spectrum,

00:22:30.680 --> 00:22:35.000
you have, and I guess Django's admin view for understandable reasons could suffer from

00:22:35.000 --> 00:22:38.640
this that you basically have a very small set of things you have a like a table page

00:22:38.640 --> 00:22:40.920
and a details page and a form page.

00:22:40.920 --> 00:22:41.920
And that's kind of it, right?

00:22:41.920 --> 00:22:46.660
So there's this difficult trade off in where in that continuum do we try to choose what

00:22:46.660 --> 00:22:48.560
size of component to implement, right?

00:22:48.560 --> 00:22:53.400
So for example, here we have, we have a heading, which is almost one for one matches what you

00:22:53.400 --> 00:22:54.440
would do in HTML.

00:22:54.440 --> 00:22:58.220
We have the text that goes within it and we have the level, which, you know, it's slightly

00:22:58.220 --> 00:23:02.760
different syntax, but it's basically one for one matching an HTML tag.

00:23:02.760 --> 00:23:07.800
But then we have a table, which it doesn't look very much like an HTML table at all.

00:23:07.800 --> 00:23:12.560
We're not having to explicitly define the table body versus the table head.

00:23:12.560 --> 00:23:14.280
We're not having to put in each column.

00:23:14.280 --> 00:23:15.280
We're not having to worry.

00:23:15.280 --> 00:23:17.960
Yeah, there's lots of stuff here that is much less like it.

00:23:17.960 --> 00:23:23.120
And that's where it's in these very common components where there is consistent things

00:23:23.120 --> 00:23:26.360
that lots of people want to do, or lots of places in your app where you might want to

00:23:26.360 --> 00:23:31.720
do them, where I think a framework like fast UI gets gets super powerful because we can

00:23:31.720 --> 00:23:37.560
get you a table here with with users defined and with a few columns with some customization

00:23:37.560 --> 00:23:41.800
on what happens when you, how we render each column much more quickly than we could go

00:23:41.800 --> 00:23:43.640
write out all the HTML for that.

00:23:43.640 --> 00:23:45.880
And it's much more concise to read it.

00:23:45.880 --> 00:23:51.200
Like it's consistent enough that something like Copilot will help you write it out where

00:23:51.200 --> 00:23:53.040
you do have a bit of customization to do.

00:23:53.040 --> 00:23:55.120
I think this, this is where it can be super powerful.

00:23:55.120 --> 00:23:56.760
Yeah, it's, it is pretty interesting.

00:23:56.760 --> 00:24:02.360
And I like the hierarchy for people listening, just check out github.com/pydanics/fast UI

00:24:02.360 --> 00:24:04.520
and the example right there on the page.

00:24:04.520 --> 00:24:10.760
But what you do is you create a, in this case, a FastAPI, API endpoint, and then you return

00:24:10.760 --> 00:24:13.200
a hierarchy of elements out of fast UI.

00:24:13.200 --> 00:24:17.800
So we have a page, the page has components, the components are a list of a header in a

00:24:17.800 --> 00:24:24.480
table, the table has data, which maps over to a list of pydantic models, which then help

00:24:24.480 --> 00:24:29.720
say what goes in the field and for the column headings and things like that.

00:24:29.720 --> 00:24:30.720
It's pretty interesting.

00:24:30.720 --> 00:24:31.720
I think it's neat.

00:24:31.720 --> 00:24:34.920
And obviously we can add other components like pagination that works.

00:24:34.920 --> 00:24:39.440
I think just, just to come back to the top, to how we do these views, the very simple

00:24:39.440 --> 00:24:44.960
and it's most simple what fast UI's react app does is it basically takes whatever the

00:24:44.960 --> 00:24:46.080
URL is you go to.

00:24:46.080 --> 00:24:52.240
So in this case, you might go to slash to the base URL and it pre-pens slash API and

00:24:52.240 --> 00:24:56.040
makes a request to that endpoint to basically say, what should I render?

00:24:56.040 --> 00:24:57.040
And it gets back.

00:24:57.040 --> 00:25:03.080
And so this here, where we're basically returning a list of pydantic models, all the fast UI

00:25:03.080 --> 00:25:07.240
model is really doing is taking that list of pydantic models and calling model dump

00:25:07.240 --> 00:25:11.160
JSON on it to get the JSON that we returned to the front end.

00:25:11.160 --> 00:25:16.000
As I say, the front end then knows how to render each of those.

00:25:16.000 --> 00:25:18.200
Each dictionary in the list is what it is at its core.

00:25:18.200 --> 00:25:22.160
At its core, it's a, it's a list of objects to use JavaScript parlance.

00:25:22.160 --> 00:25:25.220
It just knows how to render each of them and renders each of them in turn.

00:25:25.220 --> 00:25:29.160
And then obviously they can then have nested other models, all of which it knows how to

00:25:29.160 --> 00:25:30.160
render.

00:25:30.160 --> 00:25:31.160
Yeah.

00:25:31.160 --> 00:25:32.160
It reminds me of a couple of things.

00:25:32.160 --> 00:25:34.800
I have an example of this, no, somewhere along here.

00:25:34.800 --> 00:25:35.800
I pulled it up.

00:25:35.800 --> 00:25:39.280
It reminds me of kind of what react looks like.

00:25:39.280 --> 00:25:45.040
If people have done react, you know, you write a function that returns kind of an HTML thing,

00:25:45.040 --> 00:25:48.640
but then it has JavaScript arrow functions, right?

00:25:48.640 --> 00:25:52.000
It's a, but it has the same nested feel, right?

00:25:52.000 --> 00:25:55.220
Did react inspire you to create it this way or not really?

00:25:55.220 --> 00:25:56.220
Yeah, it did.

00:25:56.220 --> 00:25:58.780
I've done quite a lot of react and I like it a lot.

00:25:58.780 --> 00:26:02.060
I know there were as a, as a popular piece of technology, there were lots of people who

00:26:02.060 --> 00:26:06.260
like to like to break it, but I do think react.

00:26:06.260 --> 00:26:11.700
So like being a powerful step forward and the greatest form of flattery is, is copying.

00:26:11.700 --> 00:26:16.020
And there are enough other, like sure there are other more powerful, arguably more powerful,

00:26:16.020 --> 00:26:21.060
arguably more performant new front end libraries, but everything is, is component based now.

00:26:21.060 --> 00:26:25.460
Like, you know, react has changed, changed the, was the sea change in how we did front

00:26:25.460 --> 00:26:29.420
end with that component architecture and JSX similarly is, is superpower.

00:26:29.420 --> 00:26:32.780
So one of the things that I think we're going to get to, I don't want to dive into it yet,

00:26:32.780 --> 00:26:37.820
but like in react, you would say like, we're going to return a photo contacts, a context

00:26:37.820 --> 00:26:41.660
or a switch or something that is not typically known in HTML.

00:26:41.660 --> 00:26:45.100
And these are higher order building blocks in the UI space.

00:26:45.100 --> 00:26:46.100
Right?

00:26:46.100 --> 00:26:51.440
So when people think about what they're creating here in Python, it's not just the fundamental

00:26:51.440 --> 00:26:54.060
DOM objects and elements, is it?

00:26:54.060 --> 00:26:55.060
Right.

00:26:55.060 --> 00:26:56.060
So that, that, that was actually, yeah.

00:26:56.060 --> 00:26:59.860
So page here is a bit of ambiguity about how we're going to define a page.

00:26:59.860 --> 00:27:02.900
Like default implementation does, does something reasonably sensible.

00:27:02.900 --> 00:27:05.060
It like, you know, pads it, et cetera.

00:27:05.060 --> 00:27:08.060
But like heading isn't, there isn't much to do really.

00:27:08.060 --> 00:27:11.540
You're going to return a heading, but when you come to a table, there's a lot of debate

00:27:11.540 --> 00:27:12.660
about how you're going to do that.

00:27:12.660 --> 00:27:17.540
And then when you move on to like even higher order components, like a modal, then that's

00:27:17.540 --> 00:27:21.220
the, the, how exactly that's implemented is, you know, in some sense it's to completely

00:27:21.220 --> 00:27:23.380
the choice of how you've implemented it in the front end.

00:27:23.380 --> 00:27:26.820
You could, you could do lots of different things, but yeah, the whole point is that

00:27:26.820 --> 00:27:31.140
it doesn't and shouldn't be like each HTML tag is written out.

00:27:31.140 --> 00:27:34.740
Cause as I say, I think that would be a like obvious failure mode for this.

00:27:34.740 --> 00:27:35.740
Yeah.

00:27:35.740 --> 00:27:40.940
The other thing this reminds me of, by the way, just for people out there listening is

00:27:40.940 --> 00:27:42.620
it looks a lot like a flutter.

00:27:42.620 --> 00:27:47.620
If people have done any flutter, you've got these widget hierarchies, you build them,

00:27:47.620 --> 00:27:53.020
you maybe set some properties, you add in a bunch of, a bunch of elements, you know,

00:27:53.020 --> 00:27:56.380
set some children to an array of other sub elements.

00:27:56.380 --> 00:28:01.340
And this is done of course in Dart, but it's, you know, this is kind of a Python version

00:28:01.340 --> 00:28:03.820
that's similar as well, these higher order widgets.

00:28:03.820 --> 00:28:04.820
Yeah, absolutely.

00:28:04.820 --> 00:28:05.820
Similar thing.

00:28:05.820 --> 00:28:10.260
And actually the other place where I've built this before is that internally Pydantic core,

00:28:10.260 --> 00:28:14.660
the Rust bit of Pydantic is effectively not entirely different to this, right?

00:28:14.660 --> 00:28:18.580
You define these nested structures of validators.

00:28:18.580 --> 00:28:22.860
Everything at its core is a like combined validator, which is in Rust terms, an enormous

00:28:22.860 --> 00:28:26.580
enum of all the different types of validator, some of which have nested within them, more

00:28:26.580 --> 00:28:27.580
and more validators.

00:28:27.580 --> 00:28:32.860
And that's how you build up nested structures of Pydantic models, which in turn is what

00:28:32.860 --> 00:28:33.860
these are.

00:28:33.860 --> 00:28:34.860
We're getting a bit of it.

00:28:34.860 --> 00:28:35.860
Yeah.

00:28:35.860 --> 00:28:37.940
The validators and the UI, they kind of like have a similar structure.

00:28:37.940 --> 00:28:40.980
A bit of a sidebar, just a bit of piece of code in here.

00:28:40.980 --> 00:28:46.940
You've got table, which is a class, square bracket, user, which is another class, square

00:28:46.940 --> 00:28:47.940
bracket.

00:28:47.940 --> 00:28:53.100
I imagine that you and your team are deeper into the Python type system than the vast

00:28:53.100 --> 00:28:57.780
majority of others out there with all the work with Pydantic and the interoperability

00:28:57.780 --> 00:28:59.400
with Rust.

00:28:59.400 --> 00:29:00.400
What is that?

00:29:00.400 --> 00:29:01.400
Tell people about this.

00:29:01.400 --> 00:29:03.340
Yes, a table is a generic.

00:29:03.340 --> 00:29:07.620
So you can imagine if you were doing list of ints, you would do list square bracket

00:29:07.620 --> 00:29:08.620
int.

00:29:08.620 --> 00:29:13.860
And that's basically the point is that list is a generic around its elements, same as

00:29:13.860 --> 00:29:16.300
a dict is generic around its keys and its values.

00:29:16.300 --> 00:29:23.100
While table here is generic around the Pydantic model that you're using for each row.

00:29:23.100 --> 00:29:27.940
And particularly what that means is that what it means practically is that table has access

00:29:27.940 --> 00:29:32.580
to the class when it's deciding what the default columns are.

00:29:32.580 --> 00:29:36.900
So if you don't define the columns list as we have here to say what columns to display,

00:29:36.900 --> 00:29:39.980
it'll show all of the fields in the Pydantic model.

00:29:39.980 --> 00:29:44.820
And the point is we get access to that to the user before we've, even if the data was

00:29:44.820 --> 00:29:47.980
empty before the validation has happened.

00:29:47.980 --> 00:29:48.980
Is it necessary?

00:29:48.980 --> 00:29:54.180
Is it slightly like, yeah, fancy use of Pydantic types, Python types, maybe it is.

00:29:54.180 --> 00:29:58.860
But yeah, if you know, forgive the Pydantic team or me in particular for occasionally

00:29:58.860 --> 00:30:00.340
doing fancy things with Python types.

00:30:00.340 --> 00:30:02.700
That is definitely occupational hazard of what we do.

00:30:02.700 --> 00:30:03.700
Yeah.

00:30:03.700 --> 00:30:04.700
I didn't mean it as a negative.

00:30:04.700 --> 00:30:05.700
I just thought it was interesting.

00:30:05.700 --> 00:30:06.700
No, I agree.

00:30:06.700 --> 00:30:10.660
And actually I had it somewhere else on forms and I removed it and realized it was, it was,

00:30:10.660 --> 00:30:11.660
it was unnecessary.

00:30:11.660 --> 00:30:13.300
So you can definitely do too much.

00:30:13.300 --> 00:30:15.100
Such a thing as too much Python typing.

00:30:15.100 --> 00:30:16.100
Yeah.

00:30:16.100 --> 00:30:17.100
Yeah, for sure.

00:30:17.100 --> 00:30:18.100
It is pretty interesting.

00:30:18.100 --> 00:30:21.340
So let's maybe talk about some of the examples.

00:30:21.340 --> 00:30:27.420
Actually before we do, just give us a sense of where does this fit in the UI space for

00:30:27.420 --> 00:30:28.420
Python?

00:30:28.420 --> 00:30:35.500
On one end we've got Flask, Django, FastAPI, returning HTML, et cetera, where it's all

00:30:35.500 --> 00:30:36.500
on you.

00:30:36.500 --> 00:30:43.100
You're doing all the five languages of web apps, SQL or some query language, Python,

00:30:43.100 --> 00:30:46.060
JavaScript, CSS, some other tools, right?

00:30:46.060 --> 00:30:48.260
Like you're doing all that and you're doing my hand.

00:30:48.260 --> 00:30:50.820
On the other end, we've got tools that are pretty cool.

00:30:50.820 --> 00:30:56.020
Like we've got Anvil that lets you just write Python and do a draggy droppy sort of thing,

00:30:56.020 --> 00:31:00.860
which is, is really neat, but it fits into a kind of a box for those types of apps.

00:31:00.860 --> 00:31:02.140
I just discovered DropBase.

00:31:02.140 --> 00:31:03.740
Have you heard of DropBase?

00:31:03.740 --> 00:31:04.740
Not seen DropBase.

00:31:04.740 --> 00:31:09.820
Yeah, but I've seen a lot of these like, get me a UI more quickly.

00:31:09.820 --> 00:31:11.900
A lot of them are like kind of low code.

00:31:11.900 --> 00:31:14.980
Anvil, maybe I wouldn't really quite put it there, but they're pretty like low code, but

00:31:14.980 --> 00:31:18.620
then there's places where Python goes to make it dynamic.

00:31:18.620 --> 00:31:19.620
Right.

00:31:19.620 --> 00:31:20.820
So we're in that spectrum.

00:31:20.820 --> 00:31:23.300
Would you put fast UI as it is today?

00:31:23.300 --> 00:31:24.300
Interestingly.

00:31:24.300 --> 00:31:27.380
One of the reasons I wanted to come and talk to you was I heard you were talking the other

00:31:27.380 --> 00:31:32.740
day on your other podcast, and I heard you talking about fast UI and kind of, I'd say

00:31:32.740 --> 00:31:34.740
categorizing it into that group.

00:31:34.740 --> 00:31:38.580
And what I wanted to kind of, one of the things I wanted to come and say was, yes, we can

00:31:38.580 --> 00:31:44.060
do that, but the use case we have within Pydantic is actually to go and build a pretty complex,

00:31:44.060 --> 00:31:48.860
fully fledged application with front end developers building components, but just get rid of that

00:31:48.860 --> 00:31:49.860
churn.

00:31:49.860 --> 00:31:50.860
Right.

00:31:50.860 --> 00:31:56.060
So it's more like Gmail, less like here's a table that I can click on and see some related

00:31:56.060 --> 00:31:57.060
table.

00:31:57.060 --> 00:31:58.060
Right, exactly.

00:31:58.060 --> 00:32:00.980
And then what I should probably put in the demo and probably where Pydantic is people

00:32:00.980 --> 00:32:05.100
most associated and where this is going to be most useful is within forms.

00:32:05.100 --> 00:32:10.460
So I don't know if you want to go to the demo and I can talk people through, but like within

00:32:10.460 --> 00:32:12.980
fast UI is dedicated to forms.

00:32:12.980 --> 00:32:17.700
We can do things like nested Pydantic models all become components within a form.

00:32:17.700 --> 00:32:21.220
Then obviously we can do client side validation with a whole bunch of stuff, but we can also

00:32:21.220 --> 00:32:24.900
do server side validation, but then we get all the fancy stuff.

00:32:24.900 --> 00:32:30.660
Like if the data is invalid and you get a validation error on the server side, we'll

00:32:30.660 --> 00:32:35.180
then basically re-render the form with the errors in place, all that stuff that like

00:32:35.180 --> 00:32:38.420
anyone building a web application has to go and implement some version of it.

00:32:38.420 --> 00:32:44.660
At the moment there are some React libraries that will build you a form from JSON schema,

00:32:44.660 --> 00:32:49.340
but they don't perfectly fit in with what Pydantic does or with FastAPI.

00:32:49.340 --> 00:32:53.580
And so I have built some variant of that about five times.

00:32:53.580 --> 00:32:57.900
I still think the state of the art until now is Django, but like lots of us don't want

00:32:57.900 --> 00:33:01.860
to build our web applications completely with Django because it's pretty all or nothing

00:33:01.860 --> 00:33:03.980
despite the wonder that is Django.

00:33:03.980 --> 00:33:09.900
And so that's the kind of space where for me, this like becomes a really stands out

00:33:09.900 --> 00:33:14.220
because what would have been to do it properly, it's days of work to get form validation,

00:33:14.220 --> 00:33:18.500
to get form submission to work, get client side validation, server side validation, get

00:33:18.500 --> 00:33:19.740
the redirect after your form.

00:33:19.740 --> 00:33:23.540
None of that stuff is entirely trivial, even for those of us who've done it before.

00:33:23.540 --> 00:33:30.460
Whereas the theory is with fast UI and in, although fast UI does not require FastAPI,

00:33:30.460 --> 00:33:35.460
the form stuff is quite tightly integrated with FastAPI and you can get a really good

00:33:35.460 --> 00:33:38.060
experience of building stuff like forms.

00:33:38.060 --> 00:33:44.100
I think that where the alternative really today is to use, no disrespect to any of the

00:33:44.100 --> 00:33:48.380
fast libraries or any of the other things, but I think the only real alternative right

00:33:48.380 --> 00:33:50.820
now is implementing yourself or use Django.

00:33:50.820 --> 00:33:54.500
- Yeah, but I do also want to, but maybe before we get to that, let's try to take a little

00:33:54.500 --> 00:33:58.100
survey of what are these widgets, these building blocks that you can use.

00:33:58.100 --> 00:33:59.100
Yeah, is that right?

00:33:59.100 --> 00:34:00.100
- Yeah, absolutely.

00:34:00.100 --> 00:34:01.460
- I think I can find them here.

00:34:01.460 --> 00:34:02.460
Yes.

00:34:02.460 --> 00:34:03.460
Yeah.

00:34:03.460 --> 00:34:08.820
So you have a UI demo, which I'll link to at onrender.com, the prefix, but you talk

00:34:08.820 --> 00:34:14.940
about some of the things that you can just create in that Python hierarchy that you return

00:34:14.940 --> 00:34:17.540
that builds up your UI there.

00:34:17.540 --> 00:34:19.380
So maybe you talk us through some of the things that are here.

00:34:19.380 --> 00:34:20.380
- Yes.

00:34:20.380 --> 00:34:24.220
We have the kind of generic markdown component, which will go up and renders a markdown.

00:34:24.220 --> 00:34:27.780
This table itself is implemented using the markdown component.

00:34:27.780 --> 00:34:32.260
Just one side note, the markdown and the code, because they have quite a lot of JavaScript

00:34:32.260 --> 00:34:38.500
associated with them, they're actually lazily loaded to make the prebuilt fast UI app faster

00:34:38.500 --> 00:34:39.500
to load.

00:34:39.500 --> 00:34:42.780
Then we have text, probably the simplest one of all, just render some text.

00:34:42.780 --> 00:34:44.900
Paragraph, again, very simple.

00:34:44.900 --> 00:34:46.220
Page titles, a slightly funny one.

00:34:46.220 --> 00:34:50.500
It doesn't actually display anything on the page, but it changes the browser title.

00:34:50.500 --> 00:34:52.820
So what you see in the tab at the top of the page.

00:34:52.820 --> 00:34:53.820
- It's not always easy to do.

00:34:53.820 --> 00:34:57.100
Like how do you inject it into the head when you're in the body?

00:34:57.100 --> 00:34:59.220
It takes a little bit of integration there, yeah.

00:34:59.220 --> 00:35:00.220
- Right, exactly.

00:35:00.220 --> 00:35:03.620
So again, very simple, like one to six HTML heading.

00:35:03.620 --> 00:35:05.580
Code, a bit more sophisticated.

00:35:05.580 --> 00:35:09.540
And if you click on code, maybe those who can see it will be able to click through.

00:35:09.540 --> 00:35:10.540
Oh, code is, yeah.

00:35:10.540 --> 00:35:11.860
So code is there.

00:35:11.860 --> 00:35:16.060
We get a highlighted bit of source code displayed.

00:35:16.060 --> 00:35:20.780
- It's color coded with class types having a color and keywords having a color.

00:35:20.780 --> 00:35:21.780
That's nice.

00:35:21.780 --> 00:35:23.380
- Like you would see in GitHub or something like that.

00:35:23.380 --> 00:35:25.620
So again, just work out of the box.

00:35:25.620 --> 00:35:30.500
Then we have some components like a link list and link, which are used in other components

00:35:30.500 --> 00:35:31.500
mostly.

00:35:31.500 --> 00:35:34.540
So if you, the nav bar you see at the top of the page there, that uses a link list and

00:35:34.540 --> 00:35:35.820
then we have links.

00:35:35.820 --> 00:35:37.860
Then we get into kind of more sophisticated components.

00:35:37.860 --> 00:35:41.460
So the first one, you see a button, which loads a modal and then the button, which loads

00:35:41.460 --> 00:35:42.460
a dynamic modal.

00:35:42.460 --> 00:35:46.380
So when the modal loads, it will make a request to get the content you want to see within

00:35:46.380 --> 00:35:47.380
that modal.

00:35:47.380 --> 00:35:52.220
So that could be a form or it could be customized depending on the form in the page.

00:35:52.220 --> 00:35:55.340
Then we have loading content from the server, which is the same thing we were doing in the

00:35:55.340 --> 00:35:56.860
modal, but on the page.

00:35:56.860 --> 00:35:58.460
Then we have this SSE component.

00:35:58.460 --> 00:36:03.500
So again, very simple to use within Fast UI, but like quite a lot of work to use server

00:36:03.500 --> 00:36:08.380
side events to basically dynamically update a React component if you weren't using that.

00:36:08.380 --> 00:36:15.140
- So your server load SSE widget, that provides, like you said, server sent events, which I

00:36:15.140 --> 00:36:17.100
don't know how many people are familiar with SSE.

00:36:17.100 --> 00:36:21.660
I'm sure they're familiar with WebSockets and they're familiar with just like a JavaScript

00:36:21.660 --> 00:36:22.660
event.

00:36:22.660 --> 00:36:26.700
So it's like an immediate sort of lightweight, one directional, but normally the opposite

00:36:26.700 --> 00:36:29.780
in reverse, I guess, from the server to the client, sort of pushing out stuff.

00:36:29.780 --> 00:36:31.340
So that's a really powerful thing.

00:36:31.340 --> 00:36:35.500
And if it's that easy to just hook a function call when something happens, that's pretty

00:36:35.500 --> 00:36:36.500
cool.

00:36:36.500 --> 00:36:40.220
- One of the things I want to try with SSE that I think will work really nicely is LLM

00:36:40.220 --> 00:36:42.940
responses where you get like one token at a time because you don't want to wait for

00:36:42.940 --> 00:36:43.940
the whole thing.

00:36:43.940 --> 00:36:44.940
- Yeah, exactly.

00:36:44.940 --> 00:36:48.460
- The event would be perfect for basically printing out the response from an LLM.

00:36:48.460 --> 00:36:52.260
And again, it would be like two lines of code to add that to an app with Fast UI.

00:36:52.260 --> 00:36:56.140
It would not be two lines of code to go and implement that yourself, whether you're using

00:36:56.140 --> 00:36:59.500
pure JavaScript or React or whatever framework.

00:36:59.500 --> 00:37:03.740
And we have iFrame, which again, kind of map, we're back to kind of mapping one-to-one to

00:37:03.740 --> 00:37:04.740
a component.

00:37:04.740 --> 00:37:08.940
One of the nice things to say about both iFrame and images, they were contributed by other

00:37:08.940 --> 00:37:09.940
people.

00:37:09.940 --> 00:37:12.420
So I don't think I'd even created an issue asking for them, but people have come along

00:37:12.420 --> 00:37:13.420
and added them.

00:37:13.420 --> 00:37:14.420
It's been one of the nice things to see.

00:37:14.420 --> 00:37:18.820
I think we had 18 or so people contribute to the first release, first release after

00:37:18.820 --> 00:37:22.240
my initial release, or sorry, the second release of Fast UI.

00:37:22.240 --> 00:37:24.660
So yeah, good engagement from lots of people.

00:37:24.660 --> 00:37:25.660
Image.

00:37:25.660 --> 00:37:27.940
- Yeah, so you've got a bunch of UI stuff here.

00:37:27.940 --> 00:37:32.500
And it just, as I look at this and I see what you're building, it just makes me think of

00:37:32.500 --> 00:37:36.660
like, wow, there's an opportunity for stuff like what you get out, not necessarily the

00:37:36.660 --> 00:37:41.640
same as, but like what you get out of say, Tailwind UI, where the things you might work

00:37:41.640 --> 00:37:46.820
with are on-off switches, you know, like toggles, like you might see in your phone or other

00:37:46.820 --> 00:37:52.220
sort of elements that have like a lot of design imbued in them that people can just grab and

00:37:52.220 --> 00:37:57.180
use, almost like a Django philosophy for the front end, in a sense there.

00:37:57.180 --> 00:38:00.700
Is that something that you are dreaming of or?

00:38:00.700 --> 00:38:03.340
- Someone was complaining somewhere that we didn't have a grid component yet.

00:38:03.340 --> 00:38:07.940
And I think we'll do one, but like those bits get quite opinionated, but yeah, like calendar,

00:38:07.940 --> 00:38:10.140
completely obvious choice, right?

00:38:10.140 --> 00:38:14.820
Complete faff to go and implement that yourself in HTML, commonly used, trivial to define

00:38:14.820 --> 00:38:17.900
because the definition, there aren't that many different things to define.

00:38:17.900 --> 00:38:18.900
You choose your month.

00:38:18.900 --> 00:38:21.740
You know, most of us are on the Gregorian calendar, right?

00:38:21.740 --> 00:38:25.100
We're not going to have to change too much what calendar we're going to render.

00:38:25.100 --> 00:38:28.220
So yeah, that's a perfect example of the kind of thing.

00:38:28.220 --> 00:38:31.660
Tiles like this, again, totally possible to go and implement them.

00:38:31.660 --> 00:38:36.820
And again, obviously you can use, we can provide some nice default, but also if you're a bigger

00:38:36.820 --> 00:38:40.300
company and you want to go and customize it, you can totally do that.

00:38:40.300 --> 00:38:43.820
And you can have a front end developer go through and implement the classes that basically

00:38:43.820 --> 00:38:45.940
customize the look.

00:38:45.940 --> 00:38:49.780
I wanted to come back just to show you some of the other components.

00:38:49.780 --> 00:38:51.460
So we were on, yeah.

00:38:51.460 --> 00:38:52.460
This one here.

00:38:52.460 --> 00:38:55.620
I don't know if we have anything more below that, but I would love to show you the tables

00:38:55.620 --> 00:38:59.540
because the tables and the forms of really where it comes into cities is probably the

00:38:59.540 --> 00:39:00.540
best example.

00:39:00.540 --> 00:39:01.540
Okay.

00:39:01.540 --> 00:39:02.540
Yeah.

00:39:02.540 --> 00:39:03.540
Awesome.

00:39:03.540 --> 00:39:06.500
This is a list of cities just for some public data set with country and population.

00:39:06.500 --> 00:39:10.700
But at the top you see we have a filter to choose by country.

00:39:10.700 --> 00:39:14.780
And if we click here, if you start searching like UN or something, you'll see we're doing

00:39:14.780 --> 00:39:15.780
a server side.

00:39:15.780 --> 00:39:17.700
We're loading from the server, the list of cities.

00:39:17.700 --> 00:39:21.620
So again, this component to go and implement, if you were going to do that from scratch,

00:39:21.620 --> 00:39:25.460
you've got to have you some like clever, this is a list of countries.

00:39:25.460 --> 00:39:27.820
So if you do like, oh, country, sorry, I'm typing in cities.

00:39:27.820 --> 00:39:28.820
Good.

00:39:28.820 --> 00:39:30.900
Like UN, you'll get United Kingdom and United States.

00:39:30.900 --> 00:39:31.900
Perfect.

00:39:31.900 --> 00:39:32.900
There you go.

00:39:32.900 --> 00:39:34.940
And then we do United States or whatever.

00:39:34.940 --> 00:39:35.940
Yeah.

00:39:35.940 --> 00:39:38.540
And then we'll get a bunch of cities in the United States.

00:39:38.540 --> 00:39:42.740
Building this and wiring it all up and using one of the, we use react select here, but

00:39:42.740 --> 00:39:45.200
you can use select two or one of those components.

00:39:45.200 --> 00:39:46.200
It's not trivial.

00:39:46.200 --> 00:39:47.660
You need to also set up the backend.

00:39:47.660 --> 00:39:48.660
You need to set up this.

00:39:48.660 --> 00:39:53.740
There's like a few hundred lines of react dedicated just to setting up those, those

00:39:53.740 --> 00:39:55.200
selects correctly.

00:39:55.200 --> 00:39:59.660
And as you'll see in a minute on a form, you can add this to a, to form with us.

00:39:59.660 --> 00:40:00.660
You are pretty trivially.

00:40:00.660 --> 00:40:05.980
Secondly, if you go to the bottom of the page on cities, you will see pagination again,

00:40:05.980 --> 00:40:07.220
not a trivial thing to go and set up.

00:40:07.220 --> 00:40:10.380
If you've got, if you're just starting from scratch and you want to show like build an

00:40:10.380 --> 00:40:14.900
internal endpoint, for example, to show all of your users doing all that pagination and

00:40:14.900 --> 00:40:18.820
like wiring all that up is not trivial, but we effectively do the work for you to have

00:40:18.820 --> 00:40:22.780
that component and do the maths of which page we're on and stuff like that.

00:40:22.780 --> 00:40:27.940
I want to reiterate, this is the fast UI is not just designed as a kind of Django admin

00:40:27.940 --> 00:40:29.380
interface alternative.

00:40:29.380 --> 00:40:33.740
We within Pananzi are going to go and use it for UI that we're going to show to end

00:40:33.740 --> 00:40:34.740
users.

00:40:34.740 --> 00:40:40.500
But obviously it also comes into its own when people want to just get something up quickly.

00:40:40.500 --> 00:40:44.060
This portion of Talk Python To Me is brought to you by Sentry, you know, Sentry for the

00:40:44.060 --> 00:40:47.700
air monitoring service, the one that we use right here at talk Python.

00:40:47.700 --> 00:40:51.560
But this time I want to tell you about a new and free workshop.

00:40:51.560 --> 00:40:55.820
He mean the Kraken managing a Python monorepo with Sentry.

00:40:55.820 --> 00:41:01.240
Join Salma Alam Nayyar, senior developer advocate at Sentry and David Winterbottom, head of

00:41:01.240 --> 00:41:06.980
engineering at Kraken technologies for an inside look into how he and his team develop,

00:41:06.980 --> 00:41:13.060
deploy and maintain a rapidly evolving Python monorepo with over 4 million lines of code

00:41:13.060 --> 00:41:16.100
that powers the Kraken utility platform.

00:41:16.100 --> 00:41:20.860
In this workshop, David will share how his department of 500 developers who deploy around

00:41:20.860 --> 00:41:26.280
200 times a day, use Sentry to reduce noise, prioritize issues and maintain code quality

00:41:26.280 --> 00:41:29.540
without relying on a dedicated Q&A team.

00:41:29.540 --> 00:41:34.380
You'll learn how to find and fix root causes of crashes, ways to prioritize the most urgent

00:41:34.380 --> 00:41:38.100
crashes and errors, and tips to streamline your workflow.

00:41:38.100 --> 00:41:43.880
Join them for free on Tuesday, February 27 2024 at 2am civic time.

00:41:43.880 --> 00:41:47.980
Just visit talkbython.fm/sentry-monorepo.

00:41:47.980 --> 00:41:50.300
That link is in your podcast player show notes.

00:41:50.300 --> 00:41:54.660
2am might be a little early here in the US, but go ahead and sign up anyway if you're

00:41:54.660 --> 00:42:00.300
a US listener, because I'm sure they'll email you about a follow up recording as well.

00:42:00.300 --> 00:42:05.260
Thank you to Sentry for supporting this episode.

00:42:05.260 --> 00:42:09.220
If we have a design language or something like that, or even using a framework, I mean,

00:42:09.220 --> 00:42:13.620
you mentioned bootstrap, but tailwind or vulva is that one of the new ones?

00:42:13.620 --> 00:42:19.020
Like if we're working with one of those, and we wanted to use this, like how easy is it

00:42:19.020 --> 00:42:21.660
to sort of bring in those elements there?

00:42:21.660 --> 00:42:26.660
So if I show you here on boot, so I'll show you how we customize it with bootstrap, which

00:42:26.660 --> 00:42:28.980
is probably the best definition of it.

00:42:28.980 --> 00:42:32.820
So you'll see here, this is in the, this is the, where am I looking?

00:42:32.820 --> 00:42:33.940
This is the prebuilt version.

00:42:33.940 --> 00:42:38.740
So this, this is obviously the prebuilt version of fast UI you can get, but it's actually

00:42:38.740 --> 00:42:41.700
just, it's a very simple app in terms of react.

00:42:41.700 --> 00:42:43.380
This app has one, well, two components.

00:42:43.380 --> 00:42:48.220
It has a div which contains the fast UI component, and then we customize it in a bunch of ways.

00:42:48.220 --> 00:42:50.620
We have a like component that we render for not found.

00:42:50.620 --> 00:42:53.660
We have a component we render for spinner and for transitioning.

00:42:53.660 --> 00:42:57.060
But then these are the two that really matter, where we can customize the classes and we

00:42:57.060 --> 00:43:00.540
can customize how we render certain components.

00:43:00.540 --> 00:43:04.380
So if we come in here to have this function from bootstrap, which is how we customize

00:43:04.380 --> 00:43:08.220
the classes, you'll see that at its core, it's just this big old switch.

00:43:08.220 --> 00:43:13.780
So this is all a TypeScript, like type safe because types are very powerful in TypeScript,

00:43:13.780 --> 00:43:16.440
but like all of the props will have this type key.

00:43:16.440 --> 00:43:19.260
As I showed you earlier, when we were looking at the Python code,

00:43:19.260 --> 00:43:21.380
That's like, and all the different things.

00:43:21.380 --> 00:43:22.380
Yeah.

00:43:22.380 --> 00:43:25.100
Based on the switch, we just go through and this is all just like defining the classes

00:43:25.100 --> 00:43:27.860
we want for all of the different components.

00:43:27.860 --> 00:43:30.020
Some of them depending on the exact state of the component.

00:43:30.020 --> 00:43:34.700
So all of these form inputs, we customize them depending on which type they are and

00:43:34.700 --> 00:43:36.660
on which mode we're in, et cetera, et cetera.

00:43:36.660 --> 00:43:41.740
But it's all very mechanical, just like laying out the classes we need for each individual

00:43:41.740 --> 00:43:42.740
case.

00:43:42.740 --> 00:43:46.580
And then we have the other way of customizing it, which is to use custom components.

00:43:46.580 --> 00:43:52.700
We basically for three in particular components, navbar, modal and pagination, we define our

00:43:52.700 --> 00:43:54.740
own custom React components.

00:43:54.740 --> 00:43:59.580
So here's the one for navbar where we use a bunch of bootstrap types to render a bootstrap

00:43:59.580 --> 00:44:00.580
navbar.

00:44:00.580 --> 00:44:06.260
So you could basically create a React component that has all the settings necessary to create

00:44:06.260 --> 00:44:08.540
a navbar in Tailwind or whatever.

00:44:08.540 --> 00:44:09.540
Right.

00:44:09.540 --> 00:44:10.540
And then just plug that stuff in.

00:44:10.540 --> 00:44:14.940
So if you wanted to use Tailwind, what's this, like 20, it's like a hundred lines of code

00:44:14.940 --> 00:44:16.700
to define all of the classes.

00:44:16.700 --> 00:44:18.660
And it's pretty mechanical code, right?

00:44:18.660 --> 00:44:23.660
So it would be, it wouldn't be hard at all to go and use Tailwind, Tailwind CSS.

00:44:23.660 --> 00:44:26.220
And then you might want to define a few of your components specifically.

00:44:26.220 --> 00:44:30.780
But actually modal, I think is the only one that really requires it to be custom implemented

00:44:30.780 --> 00:44:35.060
because the default just shows you an alert because there's nothing.

00:44:35.060 --> 00:44:39.060
The page says, it's like, ah, no, the page doesn't say this isn't going to work.

00:44:39.060 --> 00:44:40.060
Yeah.

00:44:40.060 --> 00:44:43.180
So yeah, I think this is one of the bits I'm most proud of here is that like how much you

00:44:43.180 --> 00:44:46.780
could customize it and how simply you could start to customize it.

00:44:46.780 --> 00:44:47.780
Right.

00:44:47.780 --> 00:44:49.820
Those are really like kind of pluggable or extensible.

00:44:49.820 --> 00:44:53.140
So you don't have to get in and know too much about it.

00:44:53.140 --> 00:44:58.180
You just plug in the class name generator and the renderer for a specific one.

00:44:58.180 --> 00:44:59.180
And so, yeah.

00:44:59.180 --> 00:45:01.220
And all of the types, it's all typescripted.

00:45:01.220 --> 00:45:05.220
So the types should do a lot of help telling you what you can implement.

00:45:05.220 --> 00:45:10.820
Last thing I'll show you is, yeah, so here in the default build, as I said, we, our custom

00:45:10.820 --> 00:45:13.320
render function is not just a bootstrap one.

00:45:13.320 --> 00:45:18.620
We do one special thing, which is where we have this idea of a custom component, which

00:45:18.620 --> 00:45:24.500
basically all it has is a subtype, which basically you should use to render it however you like.

00:45:24.500 --> 00:45:31.140
So in our case, we take custom and if the subtype is cow say, we render that as a particular

00:45:31.140 --> 00:45:34.220
block, like use this component here.

00:45:34.220 --> 00:45:37.620
And we print out the cow says whatever it was that the input was from the server.

00:45:37.620 --> 00:45:39.940
And otherwise we just go back to using the bootstrap render.

00:45:39.940 --> 00:45:45.100
And so if you look at that component here, yeah, we've got this like slightly silly example

00:45:45.100 --> 00:45:47.820
of a custom component of cow say saying something.

00:45:47.820 --> 00:45:48.820
Oh, that's fun.

00:45:48.820 --> 00:45:51.700
But yeah, it shouldn't be too difficult to customize.

00:45:51.700 --> 00:45:54.900
And then even if you're customizing to go back to using bootstrap for the full back

00:45:54.900 --> 00:45:55.900
case of everything else.

00:45:55.900 --> 00:45:56.900
Okay.

00:45:56.900 --> 00:46:01.220
So you could almost just for one section that has to be really specialized to some custom,

00:46:01.220 --> 00:46:02.980
but otherwise just lean on a framework.

00:46:02.980 --> 00:46:03.980
Yeah.

00:46:03.980 --> 00:46:04.980
Okay.

00:46:04.980 --> 00:46:05.980
Yeah.

00:46:05.980 --> 00:46:09.100
This looks like something that one person could take one for the team, create a tailwind

00:46:09.100 --> 00:46:14.980
or a whatever generator, class name generator, and then put that as either a contribution

00:46:14.980 --> 00:46:18.660
or put it up on GitHub and then you just, you're kind of good to go.

00:46:18.660 --> 00:46:19.660
Yeah.

00:46:19.660 --> 00:46:20.660
I think we might, we might actually do it.

00:46:20.660 --> 00:46:23.300
We're, we're using tailwind and radix within Pythontics.

00:46:23.300 --> 00:46:27.020
So I suspect our front end guys will at some point get annoyed with my use of bootstrap

00:46:27.020 --> 00:46:29.300
and go off and go and change it.

00:46:29.300 --> 00:46:32.740
One of the reasons I use bootstrap is that because bootstrap is completely customized

00:46:32.740 --> 00:46:39.500
via SCSS and the SCSS compilers for Python, we have the, at least the possibility in future

00:46:39.500 --> 00:46:43.460
to allow you to customize the complete look and feel of your app without ever having to

00:46:43.460 --> 00:46:48.380
touch NPM because you just go change basically the color definitions as we do here.

00:46:48.380 --> 00:46:53.540
So, so the, the default version of maybe I can even change it here and as it's running,

00:46:53.540 --> 00:46:54.540
it'll change.

00:46:54.540 --> 00:46:58.460
But if I hear you say I've set the primary color to be black and so you'll see the buttons

00:46:58.460 --> 00:47:00.380
here are all rendered as black.

00:47:00.380 --> 00:47:04.860
If I were to change it, I haven't tried this for a bit, so I hope it works.

00:47:04.860 --> 00:47:05.860
Comment it out primary.

00:47:05.860 --> 00:47:11.460
You'll see that all of the primary, which is the bootstrap primary button.

00:47:11.460 --> 00:47:16.620
And if I changed it, I got rid of the default font, you would see we went back to whatever

00:47:16.620 --> 00:47:17.620
the other font was.

00:47:17.620 --> 00:47:21.500
So there's a world in future where we allow you to customize the look and feel even within

00:47:21.500 --> 00:47:22.860
bootstrap from Python code.

00:47:22.860 --> 00:47:23.860
Yeah.

00:47:23.860 --> 00:47:25.820
Tell people maybe who don't know what SCSS is.

00:47:25.820 --> 00:47:27.420
They probably know what CSS is.

00:47:27.420 --> 00:47:34.020
It's generally referred to as SAS, which is S A S S, which was, is, is basically a more

00:47:34.020 --> 00:47:36.660
powerful version of, of CSS where you can.

00:47:36.660 --> 00:47:37.660
SAS and less.

00:47:37.660 --> 00:47:38.660
Those were the two.

00:47:38.660 --> 00:47:39.660
Yeah.

00:47:39.660 --> 00:47:46.760
And then we kind of settled on SAS, but then we had SCSS, which is SAS with more CSS syntax.

00:47:46.760 --> 00:47:52.660
It's a way to like do slightly more powerful things in, in CSS and minify it and have stuff

00:47:52.660 --> 00:47:56.980
like variables for they were available in CSS and defaults.

00:47:56.980 --> 00:48:01.980
And even you can do weird stuff like map functions and they use very heavily in bootstrap.

00:48:01.980 --> 00:48:06.660
But the nice bit is because the compiler is written in C, there's lib SAS in Python where

00:48:06.660 --> 00:48:13.060
you can get kind of a front end customization without needing the whole of node and the,

00:48:13.060 --> 00:48:15.420
the whole dog and pony show front end of it.

00:48:15.420 --> 00:48:16.420
Yeah.

00:48:16.420 --> 00:48:17.420
Excellent.

00:48:17.420 --> 00:48:18.420
It's got a lot of legs.

00:48:18.420 --> 00:48:22.500
So when I saw this and I saw, okay, this is a, for, for web apps and it's kind of got

00:48:22.500 --> 00:48:27.380
this, this Python code running that defines the backend and it's got the UI and it's all

00:48:27.380 --> 00:48:29.220
a little self-contained.

00:48:29.220 --> 00:48:34.460
One of the thoughts I had was, wouldn't it be neat if there was a, got a little bundler

00:48:34.460 --> 00:48:36.780
type of thing that made this into an electron app.

00:48:36.780 --> 00:48:37.780
Would this be possible?

00:48:37.780 --> 00:48:40.140
Can we get something that you could send out?

00:48:40.140 --> 00:48:45.500
Or is this really just going to be intended to be kind of a, a friend of Django type of

00:48:45.500 --> 00:48:46.500
thing?

00:48:46.500 --> 00:48:50.300
I have not used electron for a very long time, so I don't pretend to be an expert.

00:48:50.300 --> 00:48:55.580
What I will say is that unlike some of the other UI libraries, we're not trying to do

00:48:55.580 --> 00:49:00.700
clever things with web sockets and do all of the, all of the rendering requiring duplex

00:49:00.700 --> 00:49:02.680
communication between the client and the server.

00:49:02.680 --> 00:49:03.740
It's pretty simple.

00:49:03.740 --> 00:49:08.060
It's like make a request and the JSON contains some information about how to render it.

00:49:08.060 --> 00:49:09.900
And then the front end goes off and renders it.

00:49:09.900 --> 00:49:14.180
So it's the result, what you get when you finish is very, in terms of a networking point

00:49:14.180 --> 00:49:17.500
of view, very, very simple, very conventional.

00:49:17.500 --> 00:49:21.900
It's like make an HTTP request to get back JSON, JavaScript knows how to render it.

00:49:21.900 --> 00:49:25.900
And so I don't see why it shouldn't, shouldn't work in, in electron.

00:49:25.900 --> 00:49:29.900
There's even the world in which we don't need the whole of electron and we could, someone

00:49:29.900 --> 00:49:34.180
could go and build fast UI components for whatever native library, and we could get

00:49:34.180 --> 00:49:37.380
like native apps running that are based on fast drive.

00:49:37.380 --> 00:49:41.220
Not saying that's necessarily a good idea, but like those possibilities exist.

00:49:41.220 --> 00:49:42.220
It is, it does exist.

00:49:42.220 --> 00:49:43.220
Okay.

00:49:43.220 --> 00:49:44.220
Yeah.

00:49:45.220 --> 00:49:46.220
Very interesting.

00:49:46.220 --> 00:49:49.100
Another thing that is convention, I suppose, I'll see if I can pull it out here is the

00:49:49.100 --> 00:49:50.100
UI.

00:49:50.100 --> 00:49:55.020
A lot of times you'll have either just slash or have slash users, but then you'll have

00:49:55.020 --> 00:49:56.900
an API that backs it.

00:49:56.900 --> 00:50:01.180
And there's this convention that if it's in the URL, if you have slash API slash, in this

00:50:01.180 --> 00:50:04.260
example we were talking about before, it's like slash table slash cities.

00:50:04.260 --> 00:50:07.940
If you say API slash table slash, that's the data endpoint.

00:50:07.940 --> 00:50:12.600
And then if you drop the API, that's the front end that then turns around and calls the backend

00:50:12.600 --> 00:50:13.600
with the API inserted.

00:50:13.600 --> 00:50:14.600
Right.

00:50:14.600 --> 00:50:18.020
You want to talk about that convention a little bit so people kind of see where that's going.

00:50:18.020 --> 00:50:21.060
So that's how, how I've set it up in the default app.

00:50:21.060 --> 00:50:22.500
It doesn't, you don't have to do it like that.

00:50:22.500 --> 00:50:27.500
And I think we're using a separate subdomain to avoid like path-based routing and all that

00:50:27.500 --> 00:50:28.500
fun.

00:50:28.500 --> 00:50:32.620
But yeah, the, the, the principle that the default simplest way of basically doing a

00:50:32.620 --> 00:50:36.860
calc excuse me, a calculation to go from, I've got a URL, how do I get the data for

00:50:36.860 --> 00:50:40.300
it is as I said earlier, basically prepend slash API.

00:50:40.300 --> 00:50:45.180
So maybe a more general way to think about it is for every page, there is an endpoint

00:50:45.180 --> 00:50:47.980
that is a FastAPI endpoint or a pair of them.

00:50:47.980 --> 00:50:53.660
Maybe even the one returns the HTML front end stuff that makes it run that talks around

00:50:53.660 --> 00:50:54.900
and goes back to itself.

00:50:54.900 --> 00:50:55.900
Right.

00:50:55.900 --> 00:50:56.900
Yeah.

00:50:56.900 --> 00:51:00.660
So what we have in the default app here, what I would generally recommend is where are we?

00:51:00.660 --> 00:51:05.140
We have a bunch of routers that connect and do all of the API stuff.

00:51:05.140 --> 00:51:08.180
And I've just been implementing all which I can show you in a minute, but that's not

00:51:08.180 --> 00:51:11.860
available as a PR for it, but it's not available in the demo you're looking at.

00:51:11.860 --> 00:51:15.940
But then we have this like basically catch all endpoint, which if nothing else has been

00:51:15.940 --> 00:51:18.820
hit, will render the standard HTML.

00:51:18.820 --> 00:51:23.420
And one of the nice things is that the Python library gives you this prebuilt HTML, which

00:51:23.420 --> 00:51:30.180
will basically render you the HTML that you'll get if you went here and I view page source,

00:51:30.180 --> 00:51:31.180
you see returning.

00:51:31.180 --> 00:51:32.180
Yeah.

00:51:32.180 --> 00:51:33.180
Well, yeah.

00:51:33.180 --> 00:51:37.020
And this particular, if I went to 8,000, then it wouldn't be messed up by beat.

00:51:37.020 --> 00:51:39.840
You just get this very simple HTML, which in turn renders the app.

00:51:39.840 --> 00:51:41.580
So yeah, there's effectively, you're right.

00:51:41.580 --> 00:51:45.580
There's two, there's two, there's a like matching endpoints for, for every view you might want

00:51:45.580 --> 00:51:49.900
to have one to get to return the Jason, the one to render the HTML.

00:51:49.900 --> 00:51:51.780
But you don't write, you don't write them both, right?

00:51:51.780 --> 00:51:56.980
You write the API one and then fast UI magically turns out into UI.

00:51:56.980 --> 00:51:57.980
Right.

00:51:57.980 --> 00:52:01.300
And whatever, and this would all of most of this, with the exception of the form submission

00:52:01.300 --> 00:52:04.620
would all just work out the box with, with any Python web framework.

00:52:04.620 --> 00:52:10.300
You just need to produce your financing model, dump it to Jason and return that in a response.

00:52:10.300 --> 00:52:16.620
But one of the really nice things about the, this being the like actual data existing in

00:52:16.620 --> 00:52:20.940
Jason is that writing a test, there's quite a lot here, but you'll see most of it is,

00:52:20.940 --> 00:52:21.940
is Markdown.

00:52:21.940 --> 00:52:26.460
So writing a test that our views contain what we expect them to is massively easier when

00:52:26.460 --> 00:52:30.220
we're testing against Jason, which we can convert to Python objects and tests.

00:52:30.220 --> 00:52:33.700
Then it would be if we've got an HTML page and we're running a bunch of regexes for,

00:52:33.700 --> 00:52:35.940
does this page contain the user's name?

00:52:35.940 --> 00:52:37.420
Does it contain the word log out?

00:52:37.420 --> 00:52:38.420
Blah, blah, blah.

00:52:38.420 --> 00:52:39.420
Yeah.

00:52:39.420 --> 00:52:42.780
So you can just say, write type of things or those types of tests.

00:52:42.780 --> 00:52:43.780
Sure.

00:52:43.780 --> 00:52:44.780
Oh yeah.

00:52:44.780 --> 00:52:47.260
Even worse, you end up with that Playwright and like Playwright that's image of it and

00:52:47.260 --> 00:52:50.860
see if the image looks like the image used to look and yeah.

00:52:50.860 --> 00:52:51.860
Things I don't want to have to build.

00:52:51.860 --> 00:52:55.460
I mean, they have to happen occasionally, but like we're, and ironically we'll probably

00:52:55.460 --> 00:52:59.660
end up with them in fast UI to like even more certainty that our components work correctly,

00:52:59.660 --> 00:53:03.740
but hopefully that thereby avoid everyone else having to, having to go and build them.

00:53:03.740 --> 00:53:09.380
Is there any concern that maybe there's unintended APIs in the sense that like all of the stuff

00:53:09.380 --> 00:53:14.820
I'm sure this is probably true for pretty much any react site, but like a lot of the

00:53:14.820 --> 00:53:19.100
page is available also as an API, even if you don't intend it to be an API, like what's

00:53:19.100 --> 00:53:20.100
yeah.

00:53:20.100 --> 00:53:24.460
That's a limitation of any, I mean, in some ways the data will be slightly less nice to

00:53:24.460 --> 00:53:25.460
yeah.

00:53:25.460 --> 00:53:26.460
You're right.

00:53:26.460 --> 00:53:29.900
If you're a company that give people foreign exchange rates and you want them to always

00:53:29.900 --> 00:53:33.540
come to your site, you obviously can't render that with, with react because there's going

00:53:33.540 --> 00:53:36.940
to be a JSON endpoint where someone can just go scrape your exchange rates or whatever

00:53:36.940 --> 00:53:37.940
else.

00:53:37.940 --> 00:53:38.940
Right.

00:53:38.940 --> 00:53:42.300
And if you have a function based off and say you have to log in to do it, right.

00:53:42.300 --> 00:53:44.180
It's not just that it's public.

00:53:44.180 --> 00:53:48.780
It just, there's always a JSON version, but honestly there's so many interesting ways

00:53:48.780 --> 00:53:50.260
to pull data out of HTML.

00:53:50.260 --> 00:53:53.820
Like if someone will do it anyway.

00:53:53.820 --> 00:54:00.060
I also think that like in theory, if your options are build pure react or do this, and

00:54:00.060 --> 00:54:03.820
this has the, the, like, as I say, there's the realistic chance someone's going to come

00:54:03.820 --> 00:54:07.820
along and implement a fast UI front end that, that renders HTML.

00:54:07.820 --> 00:54:12.340
And then, and then you don't have to expose your expose those JSON endpoints at all.

00:54:12.340 --> 00:54:14.740
And you could, you could return HTML from your server.

00:54:14.740 --> 00:54:16.500
We just haven't got around to building it yet.

00:54:16.500 --> 00:54:17.500
Yeah.

00:54:17.500 --> 00:54:20.100
I guess you could maybe do some kind of server side rendering potentially as well.

00:54:20.100 --> 00:54:21.100
Exactly.

00:54:21.100 --> 00:54:22.100
That's what I mean.

00:54:22.100 --> 00:54:25.100
Whether it's server side rendering or whether it's JavaScript server side rendering or whether

00:54:25.100 --> 00:54:29.340
it's edge rendering, I've tried to build a sort of edge rendering thing in Cloudflare

00:54:29.340 --> 00:54:34.020
years ago using Rust and for a bunch of reasons it didn't quite work, but there's real possibility

00:54:34.020 --> 00:54:36.740
of doing like, yeah, any number of different things in that direction.

00:54:36.740 --> 00:54:37.740
Oh, that's interesting.

00:54:37.740 --> 00:54:42.020
I know the CDNs have pretty dynamic stuff right at the edge where you can sort of put

00:54:42.020 --> 00:54:43.020
your last bit of code.

00:54:43.020 --> 00:54:44.820
I haven't done anything with that.

00:54:44.820 --> 00:54:48.260
That's kind of what Remix is doing and Next.js to a lesser extent.

00:54:48.260 --> 00:54:53.580
So, but again, in theory, the, I mean, maybe I'm overblowing it and fast UI will remain

00:54:53.580 --> 00:54:58.420
what it is now, but like in theory, we just, we've set up this, this language of different

00:54:58.420 --> 00:55:03.940
components that, that hopefully is whilst by no means universal, complete enough that

00:55:03.940 --> 00:55:06.140
you can build lots of common user interfaces with it.

00:55:06.140 --> 00:55:10.700
And then if it really gains adoption, then people can go build new backends and new frontends

00:55:10.700 --> 00:55:14.220
and they all in theory should be able to mix and match with each other.

00:55:14.220 --> 00:55:15.220
We'll see if that happens.

00:55:15.220 --> 00:55:16.220
Yeah.

00:55:16.220 --> 00:55:17.220
And widgets too, right?

00:55:17.220 --> 00:55:22.300
Kind of like see a Tailwind UI create a paid thing for higher order widgets, potentially

00:55:22.300 --> 00:55:25.180
just being React already makes that, that probably exists.

00:55:25.180 --> 00:55:26.180
I just don't know.

00:55:26.180 --> 00:55:31.020
And there's, there's been a number of issues of people wanting to render existing, basically

00:55:31.020 --> 00:55:33.540
build extensions to fast UI to render their widgets.

00:55:33.540 --> 00:55:38.700
I think we will probably support the repro HTML that things like pandas data frames already

00:55:38.700 --> 00:55:42.580
returned so that you could, for example, return a data frame and it might not be pretty, but

00:55:42.580 --> 00:55:47.420
you'll get something coming up as HTML and, you know, start ugly and then move on to doing

00:55:47.420 --> 00:55:49.540
those things in an even more powerful way.

00:55:49.540 --> 00:55:50.540
Sure.

00:55:50.540 --> 00:55:51.540
Yeah.

00:55:51.540 --> 00:55:53.300
I didn't even think of the data science side, but there's probably a lot of cool dashboard

00:55:53.300 --> 00:55:57.220
widgets connected to pandas and pullers that are potential out there.

00:55:57.220 --> 00:55:58.220
Yeah.

00:55:58.220 --> 00:56:01.180
And charts and visualizing data is something I don't think is interested in.

00:56:01.180 --> 00:56:05.740
There's no reason why a lot of them couldn't be implemented as fast UI components and then

00:56:05.740 --> 00:56:06.740
displayed.

00:56:06.740 --> 00:56:07.740
Okay.

00:56:07.740 --> 00:56:09.700
We are running pretty short on time.

00:56:09.700 --> 00:56:14.140
I feel like we should probably bring a little more Pydantic to the side and just talk real

00:56:14.140 --> 00:56:15.820
quickly about forms, right?

00:56:15.820 --> 00:56:16.820
What do you think?

00:56:16.820 --> 00:56:17.820
Yeah, absolutely.

00:56:17.820 --> 00:56:20.860
So if you, probably easiest if you share, let me see, share my screen.

00:56:20.860 --> 00:56:21.860
I'll do it from here.

00:56:21.860 --> 00:56:24.860
Cause I can also, it's like the form is pretty boring.

00:56:24.860 --> 00:56:25.860
You can show me behind the scenes.

00:56:25.860 --> 00:56:26.860
Yeah, yeah, yeah.

00:56:26.860 --> 00:56:30.820
It's probably most interesting if we, if we look at the, how the form is implemented in

00:56:30.820 --> 00:56:33.660
the code first, and then we look at what that, what that means for the UI.

00:56:33.660 --> 00:56:37.540
So this is the login form that Michael, you were just showing here that I can show, which

00:56:37.540 --> 00:56:42.900
is a login form with an email address, password, some validation, basically like that.

00:56:42.900 --> 00:56:43.900
Yeah.

00:56:43.900 --> 00:56:46.740
Powered entirely by, again, a completely vanilla Pydantic model.

00:56:46.740 --> 00:56:52.420
And the way that we return that is we return three things, a heading, which is like telling

00:56:52.420 --> 00:56:54.100
the person what we're looking at here in the demo.

00:56:54.100 --> 00:56:58.420
And then this third thing is that it's interesting bit where again, actually the model form is

00:56:58.420 --> 00:57:01.120
again, generic around the Pydantic model.

00:57:01.120 --> 00:57:03.800
And then it takes one other argument, which is the submit URL.

00:57:03.800 --> 00:57:04.800
And that's enough information.

00:57:04.800 --> 00:57:05.800
Right.

00:57:05.800 --> 00:57:11.460
So what you're returning as part of that hierarchy in Python is a model form and you give it

00:57:11.460 --> 00:57:12.460
a Pydantic model.

00:57:12.460 --> 00:57:17.020
And so it looks at the Pydantic class and says, we're going to create like an email

00:57:17.020 --> 00:57:19.700
address and a password field and so on.

00:57:19.700 --> 00:57:20.700
Right?

00:57:20.700 --> 00:57:21.700
Exactly that.

00:57:21.700 --> 00:57:22.700
Awesome.

00:57:22.700 --> 00:57:23.700
Okay.

00:57:23.700 --> 00:57:26.160
And then when you submit that form, it's submitted as form data.

00:57:26.160 --> 00:57:30.260
So as not as JSON data, but as a vanilla HTML form.

00:57:30.260 --> 00:57:33.100
A standard form post type of thing.

00:57:33.100 --> 00:57:34.100
Post form.

00:57:34.100 --> 00:57:38.160
And then we have this, it's this syntax is definitely slightly funky here, but it's how

00:57:38.160 --> 00:57:40.460
we do it in FastAPI.

00:57:40.460 --> 00:57:45.580
We have form, which is annotated as a login form, but it's also got fast UI form, which

00:57:45.580 --> 00:57:49.720
in turn, which also takes login form, all of which looks a bit ugly, but what we're

00:57:49.720 --> 00:57:56.300
really doing in the background is converting form data into the Pydantic model, including

00:57:56.300 --> 00:57:59.820
flattening and deflattening the model in the case where we have nested models, which I'll

00:57:59.820 --> 00:58:00.860
show you in a minute.

00:58:00.860 --> 00:58:05.220
But the result of this is once we, in our, in our post endpoint, we get an instance of

00:58:05.220 --> 00:58:07.420
the login form that we can then go do stuff with.

00:58:07.420 --> 00:58:13.260
If I show you a more comprehensive or complex example, this is big model here becomes big

00:58:13.260 --> 00:58:15.900
form and this has a bunch more stuff in it.

00:58:15.900 --> 00:58:18.360
So it has file inputs.

00:58:18.360 --> 00:58:22.660
File inputs are one of the reasons we can't just submit, submit JSON because yeah, we

00:58:22.660 --> 00:58:26.020
don't want to be part of encoding and all those things.

00:58:26.020 --> 00:58:27.020
Yeah.

00:58:27.020 --> 00:58:28.020
All those things.

00:58:28.020 --> 00:58:29.020
Right.

00:58:29.020 --> 00:58:30.320
And so here we have name.

00:58:30.320 --> 00:58:34.460
We use bold again, as I have before to indicate required fields.

00:58:34.460 --> 00:58:39.740
So we could, I don't know, I've got some Pydantic logos here that I'll use as images.

00:58:39.740 --> 00:58:41.500
This one is multiple images.

00:58:41.500 --> 00:58:45.380
So we can select multiple images, a date field in this date.

00:58:45.380 --> 00:58:47.020
I've got a calendar picker.

00:58:47.020 --> 00:58:48.020
Very nice.

00:58:48.020 --> 00:58:49.520
So that's just input type equals.

00:58:49.520 --> 00:58:51.260
That's just input type equals date.

00:58:51.260 --> 00:58:52.260
Okay.

00:58:52.260 --> 00:58:53.260
We have switches.

00:58:53.260 --> 00:58:57.020
We have, and then you'll see here, we have size model, arrow width and size model, arrow

00:58:57.020 --> 00:58:58.020
height.

00:58:58.020 --> 00:59:01.980
And the point is that we're doing here, and these are integer fields, but the cool bit

00:59:01.980 --> 00:59:07.300
is that they map to a nested Pydantic model within the big model.

00:59:07.300 --> 00:59:13.140
What FastUI is doing internally is basically flattening this into one list of form fields,

00:59:13.140 --> 00:59:14.700
which is then what we get rendered here.

00:59:14.700 --> 00:59:15.700
I see.

00:59:15.700 --> 00:59:19.940
So in your Pydantic model, you have a size object, but then in the form, it just has

00:59:19.940 --> 00:59:21.940
the width and the height, the one after another.

00:59:21.940 --> 00:59:22.940
Size width and size height.

00:59:22.940 --> 00:59:23.940
Exactly that.

00:59:23.940 --> 00:59:30.300
If I put a requirement or a restriction like min or max onto the field in the size model,

00:59:30.300 --> 00:59:33.820
would that become a client side min and max in the form?

00:59:33.820 --> 00:59:35.780
There's a PR to do exactly that.

00:59:35.780 --> 00:59:36.780
Yeah.

00:59:36.780 --> 00:59:37.780
Awesome.

00:59:37.780 --> 00:59:39.180
We will get server-side validation as well.

00:59:39.180 --> 00:59:40.900
And then we'll look at it for a couple of weeks.

00:59:40.900 --> 00:59:43.860
So like it's, there's more to do, right?

00:59:43.860 --> 00:59:44.860
But that's awesome.

00:59:44.860 --> 00:59:45.860
That's really fun.

00:59:45.860 --> 00:59:46.860
Yeah.

00:59:46.860 --> 00:59:48.940
And then you'll see in uploads, we have some quite powerful things we can do here.

00:59:48.940 --> 00:59:55.220
So we use the upload file, which is a starlet type, but we can also annotate it with form

00:59:55.220 --> 01:00:01.340
file, which takes two optional arguments of what rule, what except to apply.

01:00:01.340 --> 01:00:04.460
So that will both in the browser, when you open the...

01:00:04.460 --> 01:00:05.460
Yeah.

01:00:05.460 --> 01:00:06.460
When you choose a file browse dialogue.

01:00:06.460 --> 01:00:07.460
Yeah.

01:00:07.460 --> 01:00:08.460
It'll tell you what size.

01:00:08.460 --> 01:00:09.460
You have a MIME.

01:00:09.460 --> 01:00:11.860
So for people listening, you have the MIME typeset, not like an extension, but you have

01:00:11.860 --> 01:00:16.620
image slash star, which means image slash JPEG, PNG, WebP, et cetera.

01:00:16.620 --> 01:00:17.620
Right.

01:00:17.620 --> 01:00:21.860
And that's understood by the browser and then by the OS to let you select files, but it's

01:00:21.860 --> 01:00:23.440
also validated server-side.

01:00:23.440 --> 01:00:28.300
So if someone goes and edits their HTML and submits a not image, the server-side validation

01:00:28.300 --> 01:00:32.700
will check at least based on the file extension that it looks like an image and you get back

01:00:32.700 --> 01:00:33.700
the bytes.

01:00:33.700 --> 01:00:37.740
So you could also go do validation that the bytes are a valid image if you so wanted.

01:00:37.740 --> 01:00:42.860
You could read the bomb, the mark that indicates the file type that's sometimes in these different

01:00:42.860 --> 01:00:43.860
files.

01:00:43.860 --> 01:00:44.860
Yeah.

01:00:44.860 --> 01:00:46.900
If I submit this, but let's say, well, first of all, I try and submit this because we've

01:00:46.900 --> 01:00:49.100
got server-side validation of which fields are required.

01:00:49.100 --> 01:00:52.700
It won't let me submit if this file field is not completed.

01:00:52.700 --> 01:00:57.140
And then I think if we put in name and we don't capitalize it in this case, we'll go

01:00:57.140 --> 01:01:01.100
off and do the validation and come back and we'll say name will start with a capital because

01:01:01.100 --> 01:01:02.420
I've implemented it.

01:01:02.420 --> 01:01:03.420
Where's that validation?

01:01:03.420 --> 01:01:04.420
Oh, I see.

01:01:04.420 --> 01:01:05.620
That's a function that you write.

01:01:05.620 --> 01:01:06.620
Right.

01:01:06.620 --> 01:01:10.540
And just to prove the point, I've just written a validator in Pydantic, which says this must

01:01:10.540 --> 01:01:12.700
start with uppercase.

01:01:12.700 --> 01:01:18.860
And if I then went in here and edited that print out form, is that going to now clear

01:01:18.860 --> 01:01:19.860
my form?

01:01:19.860 --> 01:01:20.860
No, it's not, which is magic.

01:01:20.860 --> 01:01:26.580
And if I submit that, you'll see here where I printed out the form, we got the different

01:01:26.580 --> 01:01:30.100
file objects and we got the raw data all come through as the Pydantic model.

01:01:30.100 --> 01:01:31.660
Yeah, that's really cool.

01:01:31.660 --> 01:01:37.140
And so I love how even the custom validators in Pydantic, like Python code that you wrote

01:01:37.140 --> 01:01:43.100
appears on what feels like client side, but is really server side validation run by React,

01:01:43.100 --> 01:01:44.100
right?

01:01:44.100 --> 01:01:45.100
Yeah, exactly that.

01:01:45.100 --> 01:01:48.620
And so we'll do stuff like link checks and all the things you can do on an input client

01:01:48.620 --> 01:01:49.620
side as well.

01:01:49.620 --> 01:01:53.380
But of course, there'll also be enforced server side, which obviously if you're building anything

01:01:53.380 --> 01:01:56.220
that is going to be exposed to the internet, you've got to do.

01:01:56.220 --> 01:01:57.220
Yeah.

01:01:57.220 --> 01:02:00.020
You should never, never trust what comes into your web app.

01:02:00.020 --> 01:02:02.820
It's just put it online for five minutes and look at the log.

01:02:02.820 --> 01:02:07.060
It's already trying, somebody is already after wpadmin.php, you know?

01:02:07.060 --> 01:02:08.380
Yeah, exactly that.

01:02:08.380 --> 01:02:11.940
And then the last thing I'll show, I know we haven't got very long at all, is authentication,

01:02:11.940 --> 01:02:14.260
which I've just been working on now.

01:02:14.260 --> 01:02:15.780
This is again, it's a simple form.

01:02:15.780 --> 01:02:20.700
I'm just going to select an email, put in a random password and I can log in.

01:02:20.700 --> 01:02:22.380
And in this case, I've logged in.

01:02:22.380 --> 01:02:24.740
It just says who I am and how many people are logged in.

01:02:24.740 --> 01:02:29.140
If I come back to this page, it'll show me logged in and I can do post requests to log

01:02:29.140 --> 01:02:30.140
out.

01:02:30.140 --> 01:02:33.780
And what it's doing internally is, and again, this is the kind of thing that would be lots

01:02:33.780 --> 01:02:38.180
and lots of work to implement if you're doing it yourself, is it's storing in session storage,

01:02:38.180 --> 01:02:42.580
the auth token, then adding it as a header where we do the fetch from the front end to

01:02:42.580 --> 01:02:46.340
the back end so we can effectively store sessions that way.

01:02:46.340 --> 01:02:47.340
Oh yeah, very cool.

01:02:47.340 --> 01:02:51.300
Yeah, that auth token's coming in as a header item or being set as a header item.

01:02:51.300 --> 01:02:52.300
Excellent.

01:02:52.300 --> 01:02:53.300
Right, exactly.

01:02:53.300 --> 01:02:54.300
Cool.

01:02:54.300 --> 01:02:57.060
So yeah, I hope that we've done a bit of a whirlwind tour through FastUI and what's there

01:02:57.060 --> 01:03:02.860
now and what I hope is coming up and the slightly philosophy of why I built it.

01:03:02.860 --> 01:03:04.020
But yeah, I hope that was interesting.

01:03:04.020 --> 01:03:05.100
It's super interesting.

01:03:05.100 --> 01:03:07.020
And it's really early days.

01:03:07.020 --> 01:03:10.900
I'm looking forward to two things, to see what people go do with it, what widgets and

01:03:10.900 --> 01:03:11.940
stuff they build.

01:03:11.940 --> 01:03:15.700
So can you drop in, like you said, a calendar or something awesome like that.

01:03:15.700 --> 01:03:19.900
And I'm also looking forward to see what you all internally release in a couple of months

01:03:19.900 --> 01:03:20.900
from it.

01:03:20.900 --> 01:03:21.900
Absolutely.

01:03:21.900 --> 01:03:27.460
And thanks so much for having me and letting me witter on about this random library.

01:03:27.460 --> 01:03:28.620
Yeah, of course.

01:03:28.620 --> 01:03:29.620
Good work.

01:03:29.620 --> 01:03:30.620
It's certainly creative.

01:03:30.620 --> 01:03:35.620
Maybe just give people a sense of, as we wrap it up, can they use it now?

01:03:35.620 --> 01:03:36.960
Should they use it now?

01:03:36.960 --> 01:03:38.020
Can they contribute?

01:03:38.020 --> 01:03:39.020
Maybe they're interested.

01:03:39.020 --> 01:03:40.420
What do you tell that crew?

01:03:40.420 --> 01:03:41.420
I'd love people to contribute.

01:03:41.420 --> 01:03:46.380
I mean, almost most useful is issues saying how you're using it, where it's working, where

01:03:46.380 --> 01:03:47.380
it's not.

01:03:47.380 --> 01:03:51.260
There is a bunch of people who've already submitted PRs and continue to do so.

01:03:51.260 --> 01:03:56.420
And yeah, I think what works, works pretty rigorously and it's probably better implemented

01:03:56.420 --> 01:03:59.220
and tested than lots of private code.

01:03:59.220 --> 01:04:01.940
But definitely within internal uses, use it now.

01:04:01.940 --> 01:04:05.380
And like I say, Pydantic is building things with it now.

01:04:05.380 --> 01:04:11.340
So look, I mean, I give the open source guarantee that it's relatively safe, which is the guarantee

01:04:11.340 --> 01:04:12.620
that means nothing.

01:04:12.620 --> 01:04:17.340
But mostly because at the end, it's just defining how you build your UI and how you implement

01:04:17.340 --> 01:04:19.240
your session authentication.

01:04:19.240 --> 01:04:20.840
It's not having strong opinions about that.

01:04:20.840 --> 01:04:24.920
So yeah, I think it's, I think it's the place where people should go and try it and give

01:04:24.920 --> 01:04:25.920
feedback.

01:04:25.920 --> 01:04:26.920
Excellent.

01:04:26.920 --> 01:04:27.920
All right.

01:04:27.920 --> 01:04:28.920
Well, thanks again for coming on the show.

01:04:28.920 --> 01:04:29.920
Looking forward to talking to you next week.

01:04:29.920 --> 01:04:30.920
No, just kidding.

01:04:30.920 --> 01:04:31.920
Like two in a row, I suppose.

01:04:31.920 --> 01:04:32.920
Looking forward to talking to you 2024.

01:04:32.920 --> 01:04:33.920
Absolutely.

01:04:33.920 --> 01:04:34.920
Have a good Christmas.

01:04:34.920 --> 01:04:35.920
Thank you so much.

01:04:35.920 --> 01:04:36.920
Yeah.

01:04:36.920 --> 01:04:37.920
Thanks.

01:04:37.920 --> 01:04:38.920
Bye.

01:04:38.920 --> 01:04:39.920
This has been another episode of Talk Python to Me.

01:04:39.920 --> 01:04:41.680
Thank you to our sponsors.

01:04:41.680 --> 01:04:43.060
Be sure to check out what they're offering.

01:04:43.060 --> 01:04:45.960
It really helps support the show.

01:04:45.960 --> 01:04:49.680
This data is professional web scraping and a dataset marketplace.

01:04:49.680 --> 01:04:58.400
If you need data and it doesn't have an API, check out talkpython.fm/brightdata today.

01:04:58.400 --> 01:05:00.120
Take some stress out of your life.

01:05:00.120 --> 01:05:04.880
Get notified immediately about errors and performance issues in your web or mobile applications

01:05:04.880 --> 01:05:06.160
with Sentry.

01:05:06.160 --> 01:05:10.960
Just visit talkpython.fm/sentry and get started for free.

01:05:10.960 --> 01:05:14.520
And be sure to use the promo code talkpython, all one word.

01:05:14.520 --> 01:05:16.960
Want to level up your Python?

01:05:16.960 --> 01:05:21.040
We have one of the largest catalogs of Python video courses over at Talk Python.

01:05:21.040 --> 01:05:26.160
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:05:26.160 --> 01:05:28.840
And best of all, there's not a subscription in sight.

01:05:28.840 --> 01:05:31.960
Check it out for yourself at training.talkpython.fm.

01:05:31.960 --> 01:05:33.720
Be sure to subscribe to the show.

01:05:33.720 --> 01:05:36.580
Open your favorite podcast app and search for Python.

01:05:36.580 --> 01:05:37.940
We should be right at the top.

01:05:37.940 --> 01:05:43.520
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the Direct

01:05:43.520 --> 01:05:47.560
RSS feed at /rss on talkpython.fm.

01:05:47.560 --> 01:05:50.080
We're live streaming most of our recordings these days.

01:05:50.080 --> 01:05:53.680
If you want to be part of the show and have your comments featured on the air, be sure

01:05:53.680 --> 01:05:58.600
to subscribe to our YouTube channel at talkpython.fm/youtube.

01:05:58.600 --> 01:05:59.920
This is your host, Michael Kennedy.

01:05:59.920 --> 01:06:01.040
Thanks so much for listening.

01:06:01.040 --> 01:06:02.280
I really appreciate it.

01:06:02.280 --> 01:06:04.040
Now get out there and write some Python code.

01:06:05.040 --> 01:06:08.040
[MUSIC PLAYING]

