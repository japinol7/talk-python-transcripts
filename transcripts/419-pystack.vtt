WEBVTT

00:00:00.000 --> 00:00:05.280
Here's the situation. You have a Python app that is locked up or even completely crashed,


00:00:05.280 --> 00:00:11.200
and all you're left with is a core dump on the server. Now what? It's time for PyStack. You can


00:00:11.200 --> 00:00:15.920
capture a view of your app as if you've set a breakpoint and even view the call stack and


00:00:15.920 --> 00:00:22.160
locals across language calls, for example, from Python to C++ and back. We have the maintainers,


00:00:22.160 --> 00:00:27.760
Pablo Galindo Salgato and Matt Wozniewski, here to dive into PyStack. You'll definitely want to


00:00:27.760 --> 00:00:34.640
to have this tool in your toolbox. This is Talk Python to Me, episode 419, recorded Tuesday,


00:00:34.640 --> 00:00:35.640
January 6th, 2023.


00:00:35.640 --> 00:00:55.600
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.


00:00:55.600 --> 00:01:00.480
Follow me on Mastodon where I'm @mkennedy and follow the podcast using @talkpython,


00:01:00.480 --> 00:01:02.800
both on fosstodon.org.


00:01:02.800 --> 00:01:06.680
Be careful with impersonating accounts on other instances, there are many.


00:01:06.680 --> 00:01:12.160
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.


00:01:12.160 --> 00:01:15.920
We've started streaming most of our episodes live on YouTube.


00:01:15.920 --> 00:01:21.760
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be


00:01:21.760 --> 00:01:24.180
part of that episode.


00:01:24.180 --> 00:01:29.100
This episode is brought to you by Sentry and their awesome error monitoring product.


00:01:29.100 --> 00:01:31.800
And it's brought to you by Compiler from Red Hat.


00:01:31.800 --> 00:01:36.660
Listen to an episode of their podcast as they demystify the tech industry over at toppython.fm/compiler.


00:01:36.660 --> 00:01:37.660
Hey, Pablo.


00:01:37.660 --> 00:01:38.660
Hey, Matt.


00:01:38.660 --> 00:01:41.660
Great to have you both here.


00:01:41.660 --> 00:01:49.760
I'm very excited to talk about some cool tools that give us a nice internal look inside of


00:01:49.760 --> 00:01:50.760
our Python apps.


00:01:50.760 --> 00:01:53.260
Yeah, I'm really excited to talk about these tools as well.


00:01:53.260 --> 00:01:54.820
- Yeah, it sounds like you've been working on them


00:01:54.820 --> 00:01:57.500
for a couple of years, you two, and especially Pablo,


00:01:57.500 --> 00:01:58.820
and it's gonna be great.


00:01:58.820 --> 00:02:03.280
So that's looking at sort of debugging Python apps


00:02:03.280 --> 00:02:05.940
and even Python apps that have crashed,


00:02:05.940 --> 00:02:08.060
which is really, really fantastic.


00:02:08.060 --> 00:02:09.740
Maybe some profiling as well.


00:02:09.740 --> 00:02:10.940
We'll see what we get to.


00:02:10.940 --> 00:02:12.780
- Crashing apps is not that fantastic, but...


00:02:12.780 --> 00:02:13.860
(laughing)


00:02:13.860 --> 00:02:15.260
But debugging them, maybe.


00:02:15.260 --> 00:02:16.100
- Right.


00:02:16.100 --> 00:02:17.820
- Exactly, I'm so excited my app crashed


00:02:17.820 --> 00:02:20.900
'cause I get to use this PyStack tool that you all worked on.


00:02:20.900 --> 00:02:22.940
- For a while, I actually was,


00:02:22.940 --> 00:02:24.940
because that means that I could use it.


00:02:24.940 --> 00:02:26.300
But let's keep that secret.


00:02:26.300 --> 00:02:28.060
Well, you need test cases, right?


00:02:28.060 --> 00:02:29.060
And you need examples.


00:02:29.060 --> 00:02:29.560
Right.


00:02:29.560 --> 00:02:30.780
I forgot to say exactly that.


00:02:30.780 --> 00:02:32.660
It's a great way to see if we have any bugs.


00:02:32.660 --> 00:02:34.300
It's a great chance to try things out.


00:02:34.300 --> 00:02:35.220
Meta debugging.


00:02:35.220 --> 00:02:36.980
If you're trying to debug the debugger.


00:02:36.980 --> 00:02:38.380
Oh, we have done that, for sure.


00:02:38.380 --> 00:02:38.880
Yeah.


00:02:38.880 --> 00:02:40.740
[LAUGHTER]


00:02:40.740 --> 00:02:41.900
How funny.


00:02:41.900 --> 00:02:42.420
Awesome.


00:02:42.420 --> 00:02:46.380
Well, let's just have a quick round of introductions


00:02:46.380 --> 00:02:48.740
from you guys before we can jump into it.


00:02:48.740 --> 00:02:49.300
Absolutely.


00:02:49.300 --> 00:02:50.700
Matt, do you want to go first?


00:02:50.700 --> 00:02:51.200
Sure.


00:02:51.200 --> 00:02:52.500
I am Matt Wisniewski.


00:02:52.500 --> 00:02:55.340
I'm a senior software engineer at Bloomberg.


00:02:55.340 --> 00:02:59.080
I originally joined in 2009, I think.


00:02:59.080 --> 00:03:01.340
So I've been around for quite a while.


00:03:01.340 --> 00:03:04.040
I work on the Python infrastructure team at Bloomberg.


00:03:04.040 --> 00:03:08.180
So our job is building tools and libraries


00:03:08.180 --> 00:03:10.160
and maintaining the interpreters for use


00:03:10.160 --> 00:03:11.720
by other teams at Bloomberg.


00:03:11.720 --> 00:03:13.100
- Right on, sounds very fun.


00:03:13.100 --> 00:03:13.940
Pablo?


00:03:13.940 --> 00:03:16.420
- I'm Pablo Alino, apart from working at Bloomberg


00:03:16.420 --> 00:03:18.180
in exactly the same things as Matt,


00:03:18.180 --> 00:03:19.840
because he's my co-worker.


00:03:19.840 --> 00:03:22.220
I do a bunch of things in the Python community.


00:03:22.220 --> 00:03:25.300
So let me see if I don't miss anything.


00:03:25.300 --> 00:03:27.180
So I'm in the Python Extreme Council.


00:03:27.180 --> 00:03:28.580
I think this is my third year.


00:03:28.580 --> 00:03:31.100
I'm also the release manager of 3.10 and 3.11.


00:03:31.100 --> 00:03:33.060
3.10 is going to security fixes,


00:03:33.060 --> 00:03:34.820
and today I actually need to do the last one.


00:03:34.820 --> 00:03:37.340
So that's kind of exciting, I suppose.


00:03:37.340 --> 00:03:39.340
- You have a 3.10 release coming today?


00:03:39.340 --> 00:03:42.300
- Yes, the 3.12 beta one, I think.


00:03:42.300 --> 00:03:44.300
We are also releasing 3.11 and 3.10.


00:03:44.300 --> 00:03:47.700
Like 3.11 is a bug fix, 3.10 is a first security release,


00:03:47.700 --> 00:03:49.140
which means it's source only.


00:03:49.140 --> 00:03:50.700
And it's my first security release as well.


00:03:50.700 --> 00:03:52.800
But I think that makes it easier, hopefully.


00:03:52.800 --> 00:03:56.080
- Yeah, and you were on the podcast before


00:03:56.080 --> 00:03:58.480
talking about the actual release of 3.11


00:03:58.480 --> 00:03:59.440
and that whole process.


00:03:59.440 --> 00:04:02.160
So if people want to go back and see that in more detail,


00:04:02.160 --> 00:04:03.000
that was really fun.


00:04:03.000 --> 00:04:04.500
- All right, we broke GitHub.


00:04:04.500 --> 00:04:07.180
That's an exciting time when we released 3.11.


00:04:07.180 --> 00:04:09.480
So yeah, I'm also in the Python core team,


00:04:09.480 --> 00:04:13.760
mainly working on the parser and the garbage collector.


00:04:13.760 --> 00:04:16.360
Therefore breaking black autoformatters a lot


00:04:16.360 --> 00:04:18.360
with new syntax.


00:04:18.360 --> 00:04:19.200
- Yeah, excellent.


00:04:19.200 --> 00:04:21.800
- Faster CPython, you can't forget it. - Right, right.


00:04:21.800 --> 00:04:24.640
And I'm collaborating with the Faster CPython team as well.


00:04:24.640 --> 00:04:27.040
Sorry, I just see you, I always forget something.


00:04:27.040 --> 00:04:29.940
As far as community stuff goes, I'd be remiss if I didn't mention


00:04:29.940 --> 00:04:32.720
that I am a moderator on the Python Discord too.


00:04:32.720 --> 00:04:36.220
So if anyone is not a member of Python Discord, they should join.


00:04:36.220 --> 00:04:37.880
- It's a cool place to hang out. - Awesome.


00:04:37.880 --> 00:04:40.280
Yeah, we'll put a link to that in the show notes as well,


00:04:40.280 --> 00:04:42.280
so people can check that out.


00:04:42.280 --> 00:04:45.360
So you all are busy, is what I hear you saying.


00:04:45.360 --> 00:04:47.360
- Yes. - Yes.


00:04:47.360 --> 00:04:48.880
- Absolutely.


00:04:48.880 --> 00:04:49.720
All right, excellent.


00:04:49.720 --> 00:04:52.200
Well, let's maybe set the stage


00:04:52.200 --> 00:04:54.560
for talking about PyStack here.


00:04:54.560 --> 00:04:56.640
And the first thing I want to talk about is just,


00:04:56.640 --> 00:04:57.920
hold on, I do want to point out,


00:04:57.920 --> 00:04:59.140
like you said you both work


00:04:59.140 --> 00:05:01.740
on the infrastructure team at Bloomberg.


00:05:01.740 --> 00:05:03.760
I'm not sure people fully appreciate


00:05:03.760 --> 00:05:06.900
how much Python is happening at Bloomberg.


00:05:06.900 --> 00:05:09.080
So maybe we should just give like a big picture


00:05:09.080 --> 00:05:11.680
because it's germane to this conversation,


00:05:11.680 --> 00:05:14.180
like PyStack and other tools like Memory,


00:05:14.180 --> 00:05:16.520
which we may get a chance to talk about if we have time.


00:05:16.520 --> 00:05:19.720
those are coming out of supporting this large community.


00:05:19.720 --> 00:05:23.640
And I got a sense of how big Python is at Bloomberg


00:05:23.640 --> 00:05:28.560
when there were 60 engineers from Bloomberg at PyCon


00:05:28.560 --> 00:05:32.240
and everybody's booth duty was measured in minutes.


00:05:32.240 --> 00:05:33.800
- Right, right, and they didn't copy paste


00:05:33.800 --> 00:05:35.560
the same engineer 60 times.


00:05:35.560 --> 00:05:36.480
(laughs)


00:05:36.480 --> 00:05:37.760
Yeah, it's quite wild.


00:05:37.760 --> 00:05:40.080
I can start if you want to.


00:05:40.080 --> 00:05:42.200
It's very interesting, actually, that you point this out


00:05:42.200 --> 00:05:45.440
because Bloomberg, being a very old company,


00:05:45.440 --> 00:05:50.840
You know, when people talk about legacy, and it's like, oh, we have legacy because we have this Python 2.7 script.


00:05:50.840 --> 00:05:56.480
Well, just you should see what a company that started in the 70s can do about that.


00:05:56.480 --> 00:05:58.720
But it used to be a C++ house.


00:05:58.720 --> 00:06:05.680
And when I started, actually, the main language were C++ and JavaScript for the front end, Bloomberg terminal.


00:06:05.680 --> 00:06:09.920
And now we are actually, I think I'm, if I'm not mistaken, Matt can correct me,


00:06:09.920 --> 00:06:12.800
but I think we can say probably that now we are a Python house,


00:06:12.800 --> 00:06:18.640
because I think we just surpassed for the first time the amount of lines of Python compared with C++.


00:06:18.640 --> 00:06:22.440
And if that is not true, it's mostly there, which is quite exciting.


00:06:22.440 --> 00:06:26.540
At the point where I joined the company, we had onboarding training for juniors


00:06:26.540 --> 00:06:30.840
that included a Fortran for C programmers section.


00:06:30.840 --> 00:06:34.640
And at this point, we have a C++ for Python programmers section instead.


00:06:34.640 --> 00:06:38.040
So that's how much it's changed over the last decade or so.


00:06:38.040 --> 00:06:39.040
Wow, that's incredible.


00:06:39.040 --> 00:06:40.840
- That means that C++ is now legacy.


00:06:40.840 --> 00:06:41.680
(laughs)


00:06:41.680 --> 00:06:42.520
We'll see.


00:06:42.520 --> 00:06:43.340
- Ooh.


00:06:43.340 --> 00:06:44.180
- Who said that?


00:06:44.180 --> 00:06:45.160
Certainly not me.


00:06:45.160 --> 00:06:46.720
The steering council member says that.


00:06:46.720 --> 00:06:49.240
(laughs)


00:06:49.240 --> 00:06:50.080
Okay, so yeah.


00:06:50.080 --> 00:06:51.360
But this is an interesting,


00:06:51.360 --> 00:06:53.480
and this kind of goes into itself.


00:06:53.480 --> 00:06:55.640
I think this is an interesting scenario


00:06:55.640 --> 00:06:58.200
because that C++ didn't went away.


00:06:58.200 --> 00:07:00.560
Among other things, it's because it's not legacy.


00:07:00.560 --> 00:07:03.000
You know, like Python is not the fastest language


00:07:03.000 --> 00:07:04.880
on the planet, although we are trying to make it fast,


00:07:04.880 --> 00:07:07.000
but certainly not, we are not trying to make it compete


00:07:07.000 --> 00:07:07.880
with C++.


00:07:07.880 --> 00:07:10.480
So that C++ is both there and needed,


00:07:10.480 --> 00:07:13.200
because you know that you cannot just do everything in Python, for sure.


00:07:13.200 --> 00:07:15.120
So the situation that we have at Bloomberg,


00:07:15.120 --> 00:07:17.240
which is served by many other big companies,


00:07:17.240 --> 00:07:18.440
and finance companies as well,


00:07:18.440 --> 00:07:20.920
is that we have a lot of C++ under that Python.


00:07:20.920 --> 00:07:22.800
So, well, C++ by itself,


00:07:22.800 --> 00:07:25.600
but let's talk about the actual part that is interesting for Python.


00:07:25.600 --> 00:07:28.360
So you can write a lot of pure Python scripts, right?


00:07:28.360 --> 00:07:31.720
What most people, or companies, do is write some Python,


00:07:31.720 --> 00:07:34.800
and 99% of the time,


00:07:34.800 --> 00:07:37.160
it ends up reaching some C++ underneath.


00:07:37.160 --> 00:07:40.560
And this is not just because they are using NumPy or Pandas


00:07:40.560 --> 00:07:44.060
or any of these compiled, very common scenarios as well,


00:07:44.060 --> 00:07:46.460
but also because they are using Bloomberg code underneath,


00:07:46.460 --> 00:07:49.140
which just happens to be written in C++.


00:07:49.140 --> 00:07:50.560
And this means that, you know,


00:07:50.560 --> 00:07:52.840
now we have a huge community of people


00:07:52.840 --> 00:07:55.440
that need to be aware of both languages at the same time.


00:07:55.440 --> 00:07:56.740
So you have Python programmers


00:07:56.740 --> 00:07:57.940
that need to be aware of C++,


00:07:57.940 --> 00:08:01.020
as well as C++ programmers that need to be aware of Python,


00:08:01.020 --> 00:08:03.820
either because they just happen to switch to Python


00:08:03.820 --> 00:08:07.220
or because they use Python to run tests or things like that.


00:08:07.220 --> 00:08:08.520
So it's a very interesting scenario.


00:08:08.520 --> 00:08:11.660
- Yeah, and I imagine, leading up to this conversation,


00:08:11.660 --> 00:08:15.200
if something goes wrong, you might not be entirely sure,


00:08:15.200 --> 00:08:16.960
is it the Python code?


00:08:16.960 --> 00:08:18.340
Is it the C++ code?


00:08:18.340 --> 00:08:21.260
Is it the interaction of these things, right?


00:08:21.260 --> 00:08:22.100
That can make it tricky.


00:08:22.100 --> 00:08:25.340
- This is quite, what you point out is basically,


00:08:25.340 --> 00:08:27.500
among all the things, one of the things


00:08:27.500 --> 00:08:29.660
that make us work on this in the first place,


00:08:29.660 --> 00:08:32.300
because what happened normally is that when an application,


00:08:32.300 --> 00:08:35.580
One of these applications is hybrid crash and bloomer.


00:08:35.580 --> 00:08:38.180
We used to have this, many companies does this.


00:08:38.180 --> 00:08:40.220
I mean, I would assume all of them.


00:08:40.220 --> 00:08:42.340
But what happened is that when an application crashes,


00:08:42.340 --> 00:08:44.220
we either get a core file, right?


00:08:44.220 --> 00:08:47.540
Which is this kind of like file that is dumped by the kernel


00:08:47.540 --> 00:08:50.020
with all the memory dump of the process


00:08:50.020 --> 00:08:52.940
and a bunch of information and you can analyze it later.


00:08:52.940 --> 00:08:55.620
Or a debugger basically attaches to the process


00:08:55.620 --> 00:08:57.020
and shows you the back trees.


00:08:57.020 --> 00:08:59.020
But the problem is that this debugger was DDB,


00:08:59.020 --> 00:09:01.080
which means that the back trees that you get


00:09:01.080 --> 00:09:04.080
is a C backtrace, it's not a Python backtrace, right?


00:09:04.080 --> 00:09:06.580
And the backtrace is useless for everyone.


00:09:06.580 --> 00:09:09.080
So it's like, it doesn't matter if you're a C++ programmer


00:09:09.080 --> 00:09:11.080
or you're a Python programmer, it's always useless.


00:09:11.080 --> 00:09:14.580
It's useless for Python programmers because you see C functions.


00:09:14.580 --> 00:09:17.580
And like a Python programmer normally is like, "What is this?


00:09:17.580 --> 00:09:19.080
What is that register?"


00:09:19.080 --> 00:09:22.580
On the other hand, it's also useless for C++ programmers


00:09:22.580 --> 00:09:24.580
because the function that evaluates Python code,


00:09:24.580 --> 00:09:26.580
which is called pyEvalEvalFrameDefault,


00:09:26.580 --> 00:09:30.080
is repeated 600 times, and it doesn't make any sense.


00:09:30.080 --> 00:09:33.080
not only they also expect to see their Python code,


00:09:33.080 --> 00:09:37.080
but now their C++ code is just buried among this mysterious code.


00:09:37.080 --> 00:09:39.080
So nobody could make sense of what's going on,


00:09:39.080 --> 00:09:43.080
which means that for a long time, when a Python application crashed at Bloomberg,


00:09:43.080 --> 00:09:46.080
I mean, we're talking crash here as like hard crash, like segfault,


00:09:46.080 --> 00:09:51.080
which is common in C++ segfaults, or sometimes even Python can segfault, right?


00:09:51.080 --> 00:09:53.080
In some situations.


00:09:53.080 --> 00:09:56.080
So obviously, a Python exception is reported as a Python exception.


00:09:56.080 --> 00:09:58.080
We are not talking that our system picked GDB.


00:09:58.080 --> 00:10:00.980
if a Python exception is raised, obviously that is fine.


00:10:00.980 --> 00:10:04.980
It's when this kind of hybrid setup crashes very deeply,


00:10:04.980 --> 00:10:07.680
either because Python crashes or because NumPy crashes


00:10:07.680 --> 00:10:09.180
or because the Bloomberg code crashes.


00:10:09.180 --> 00:10:13.180
So in those cases, nobody could make sense of what's going on


00:10:13.180 --> 00:10:15.980
because the backtracing is useless by itself.


00:10:15.980 --> 00:10:20.180
And not just crashes, that it's also a problem for deadlocks as well.


00:10:20.180 --> 00:10:23.780
One of the big differences between Python and C++,


00:10:23.780 --> 00:10:27.180
they've got very different models for how they represent


00:10:27.180 --> 00:10:30.860
the lifetimes of objects and things like that, you can very easily get into a


00:10:30.860 --> 00:10:37.020
situation where a C++ object that is owned by a Python object in our hybrid


00:10:37.020 --> 00:10:42.540
work environment is trying to communicate with a background thread to, I don't know,


00:10:42.540 --> 00:10:45.980
tell it to stop or something like that. But that background thread winds up needing to pick up the


00:10:45.980 --> 00:10:50.220
GIL for some reason. And if you have the foreground thread still holding the GIL,


00:10:50.220 --> 00:10:54.860
you've just introduced a deadlock. And it's very difficult to track that down if the only tool at


00:10:54.860 --> 00:10:59.560
that your disposal is GDB and you can't easily see what Python stuff is being called.


00:10:59.560 --> 00:11:00.220
Right, sorry.


00:11:00.220 --> 00:11:03.760
Yeah, and Python, sorry, C++ multi-threading is like


00:11:03.760 --> 00:11:08.100
critical sections and locks and like it's really explicit.


00:11:08.100 --> 00:11:10.640
You enter a lock, you exit a lock and


00:11:10.640 --> 00:11:13.040
Python has that as well, but in addition,


00:11:13.040 --> 00:11:15.040
it just has this implicit gill


00:11:15.040 --> 00:11:16.380
that you're talking about, right?


00:11:16.380 --> 00:11:18.880
And that there was a whole nother layer of


00:11:18.880 --> 00:11:20.880
potential deadlocks in there that I imagine


00:11:20.880 --> 00:11:21.780
is pretty tricky.


00:11:21.780 --> 00:11:23.880
And some of them are not only difficult to spot,


00:11:23.880 --> 00:11:28.880
but it's very difficult to reason about just because most of these things are so difficult, actually,


00:11:28.880 --> 00:11:31.880
that even if you go to some popular tools in the wild,


00:11:31.880 --> 00:11:35.380
they don't handle all the edge cases because it's quite hardcore.


00:11:35.380 --> 00:11:39.380
Like the fact that you can just request the gil in the middle of...


00:11:39.380 --> 00:11:43.380
Like, for instance, we are not going... I don't know if we will end talking about memory profilers here,


00:11:43.380 --> 00:11:49.880
but most memory profilers that are measuring, like, native allocations in Python and C++,


00:11:49.880 --> 00:11:52.380
they need to see the Python stack somehow.


00:11:52.380 --> 00:11:55.380
Like when an allocation is made, you say, "Oh, give me some memory."


00:11:55.380 --> 00:11:57.080
You need to say, "Who called this function?"


00:11:57.080 --> 00:11:59.520
And then you need to see both the C sometimes.


00:11:59.520 --> 00:12:01.260
So you only care about Python, you just need to say,


00:12:01.260 --> 00:12:02.700
"Okay, what is the Python stack trace?"


00:12:02.700 --> 00:12:05.320
Right? Like an exception, but like, "Who called this function?"


00:12:05.320 --> 00:12:06.820
And for that, you need the GIL.


00:12:06.820 --> 00:12:09.300
So you need to say, "Give me the GIL," and then I will print the stack.


00:12:09.300 --> 00:12:12.840
But like sometimes, one of the situations that Matt is describing


00:12:12.840 --> 00:12:13.960
will introduce a deadlock.


00:12:13.960 --> 00:12:17.180
It's very, very rare situations, but it's the kind of situations


00:12:17.180 --> 00:12:20.640
that will involve threads and like, you know, specific things.


00:12:20.640 --> 00:12:23.800
But which means that it will happen very, very rarely,


00:12:23.800 --> 00:12:26.200
but it will happen or it can happen.


00:12:26.200 --> 00:12:28.960
So it's both going to be rare to debug


00:12:28.960 --> 00:12:31.760
because this person who's going to appear


00:12:31.760 --> 00:12:36.280
when the moon is high and Wednesday is going to say,


00:12:36.280 --> 00:12:39.320
well, only in this case is the deck locks.


00:12:39.320 --> 00:12:41.120
And it's going to be very difficult to fix as well


00:12:41.120 --> 00:12:42.760
because now you cannot just have the yield.


00:12:42.760 --> 00:12:45.360
So you need a complete redesign sometimes.


00:12:45.360 --> 00:12:47.520
So it can be very challenging to fix,


00:12:47.520 --> 00:12:49.560
to find to debug as well.


00:12:49.560 --> 00:12:51.560
Those situations are so tricky.


00:12:51.560 --> 00:12:54.560
You know that they often get the term


00:12:54.560 --> 00:12:56.680
Heisenbugs to indicate kind of


00:12:56.680 --> 00:12:59.720
the quantum mechanical uncertainty, right?


00:12:59.720 --> 00:13:01.560
Like it could be in some state,


00:13:01.560 --> 00:13:03.600
but if you measure it, then it's in a different state, right?


00:13:03.600 --> 00:13:06.080
It's kind of how do you actually track these down?


00:13:06.080 --> 00:13:08.480
And they happen in a lot of times in production,


00:13:08.480 --> 00:13:11.640
but only under heavy load after like 12 hours.


00:13:11.640 --> 00:13:13.320
So how do you use


00:13:13.320 --> 00:13:15.440
normal debugging techniques to step through that?


00:13:15.440 --> 00:13:17.240
All these things are really, really tricky.


00:13:17.240 --> 00:13:19.440
- But it's a high stack. - But also...


00:13:19.440 --> 00:13:21.440
They are very interesting as well.


00:13:21.440 --> 00:13:23.440
We can certainly discuss exactly what you just said


00:13:23.440 --> 00:13:24.940
because it's just spot on.


00:13:24.940 --> 00:13:27.880
And one of the reasons here is that, as you mentioned,


00:13:27.880 --> 00:13:29.880
the moment you touch a debugger,


00:13:29.880 --> 00:13:32.380
because the debugging process normally slows down the code,


00:13:32.380 --> 00:13:35.120
means that reproducing the dialogue may be harder.


00:13:35.120 --> 00:13:38.120
So sometimes the only way to properly debug this thing


00:13:38.120 --> 00:13:40.820
is letting it crash without the debugger,


00:13:40.820 --> 00:13:43.320
producing a core file and then analyzing the core file.


00:13:43.320 --> 00:13:45.320
But because the core file is dead,


00:13:45.320 --> 00:13:48.720
I mean, it's just basically a dump, you cannot call functions now.


00:13:48.720 --> 00:13:53.720
Then GDB can be useless if you don't know how to use certain tools.


00:13:53.720 --> 00:13:55.720
So PyStack actually is very useful here as well,


00:13:55.720 --> 00:13:59.060
because you can reproduce the deadlock at full speed,


00:13:59.060 --> 00:14:02.160
generating a call or letting it crash, and then use PyStack.


00:14:02.160 --> 00:14:03.960
But we can talk about that later.


00:14:03.960 --> 00:14:06.760
Or maybe you don't know that you're trying to reproduce a deadlock.


00:14:06.760 --> 00:14:07.760
-Right, right. -That just happens.


00:14:07.760 --> 00:14:10.400
Right, and you're like, you know, it won't respond,


00:14:10.400 --> 00:14:13.160
but the CPU load on the server is zero.


00:14:13.160 --> 00:14:21.160
That sort of is it waiting for something or is it ever going to respond or you just don't know what it's doing yet.


00:14:21.160 --> 00:14:23.160
Yeah, yeah, exactly.


00:14:23.160 --> 00:14:30.160
And you know, logging will help a little bit but not you got to have some pretty intense logging to get that level of what's going on.


00:14:30.160 --> 00:14:33.160
And usually that you don't want that in production either.


00:14:33.160 --> 00:14:38.160
This portion of Talk Python To Me is brought to you by century.


00:14:38.160 --> 00:14:42.160
You know that century captures the errors that would otherwise go unnoticed.


00:14:42.160 --> 00:14:46.320
Of course, they have incredible support for basically any Python framework.


00:14:46.320 --> 00:14:52.360
They have direct integrations with Flask, Django, FastAPI, and even things like AWS


00:14:52.360 --> 00:14:54.220
Lambda and Celery.


00:14:54.220 --> 00:14:58.360
But did you know they also have native integrations with mobile app frameworks?


00:14:58.360 --> 00:15:03.260
Whether you're building an Android or iOS app or both, you can gain complete visibility


00:15:03.260 --> 00:15:08.660
into your application's correctness both on the mobile side and server side.


00:15:08.660 --> 00:15:13.520
We just completely rewrote Talk Python's mobile apps for taking our courses.


00:15:13.520 --> 00:15:18.180
And we massively benefited from having Sentry integration right from the start.


00:15:18.180 --> 00:15:22.780
We used Flutter for our native mobile framework, and with Sentry, it was literally just two


00:15:22.780 --> 00:15:26.900
lines of code to start capturing errors as soon as they happen.


00:15:26.900 --> 00:15:31.100
Of course, we don't love errors, but we do love making our users happy.


00:15:31.100 --> 00:15:35.580
Solving problems as soon as possible with Sentry on the mobile Flutter code and the


00:15:35.580 --> 00:15:41.420
Python server side code together made understanding error reports a breeze. So whether you're


00:15:41.420 --> 00:15:47.240
building Python server side apps, or mobile apps, or both, give Sentry a try to get a


00:15:47.240 --> 00:15:52.460
complete view of your apps correctness. Thank you to Sentry for sponsoring the show and


00:15:52.460 --> 00:15:57.880
helping us ship more reliable mobile apps to all of you.


00:15:57.880 --> 00:16:04.300
So let's start our conversation about just the spectrum of what the options are out there.


00:16:04.300 --> 00:16:10.100
Hello. Now, you mentioned GDB, but I guess on one side of the spectrum,


00:16:10.100 --> 00:16:14.700
we have PyCharm and VS Code and friends where you press F5,


00:16:14.700 --> 00:16:17.500
or you press the little debug thing and you step through your code.


00:16:17.500 --> 00:16:21.140
And that's helpful when you're actually developing your application.


00:16:21.140 --> 00:16:25.340
But you're talking about running a production or running applications


00:16:25.340 --> 00:16:28.260
or applications that have crashed and here's a core file.


00:16:28.260 --> 00:16:30.580
Those are not exactly the same situation, are they?


00:16:30.580 --> 00:16:32.820
We are talking about the specific case.


00:16:32.820 --> 00:16:37.820
We are sending ourselves into many scenarios, although you can certainly use it in others.


00:16:37.820 --> 00:16:45.820
But just to have a good mental model over what these tools are going to be useful for and what are they different from PDB or VS Code, right?


00:16:45.820 --> 00:16:51.820
You're talking about things that crash, crash like hard crash, like, you know, or things that are frozen.


00:16:51.820 --> 00:16:57.820
It could be a deadlock, but it could be also that your application is waiting for something and it never arrives and you want to know what is going on.


00:16:57.820 --> 00:17:01.820
And specifically when these tools are going to become even more useful


00:17:01.820 --> 00:17:06.820
is when this code involves C++ or C code or RAS code for that matter.


00:17:06.820 --> 00:17:08.820
So some native code, right?


00:17:08.820 --> 00:17:10.820
And the reason this is going to be more useful is because


00:17:10.820 --> 00:17:15.820
PDB or VS Code, the barrier or PyCharm normally attach Python to the barriers,


00:17:15.820 --> 00:17:18.820
which means that these barriers only know about the Python world.


00:17:18.820 --> 00:17:22.820
And that normally is insufficient because you want to see both worlds at the same time.


00:17:22.820 --> 00:17:24.820
And this is going to become very critical.


00:17:24.820 --> 00:17:26.820
You don't want to be one world and the other separately.


00:17:26.820 --> 00:17:30.820
possibly, you want some tool that understands both worlds at the same time,


00:17:30.820 --> 00:17:34.820
and can show you what really is happening and how these worlds are, like, you're entering


00:17:34.820 --> 00:17:37.820
one world, leaving it, but then you're entering it again, or something like that.


00:17:37.820 --> 00:17:40.820
Right. So if you've got this mixed code, a Python profiler won't,


00:17:40.820 --> 00:17:43.820
they won't see the steps happening below that, right?


00:17:43.820 --> 00:17:47.820
Right. So, for instance, at Bloomberg, a Python profiler will tell you that the application,


00:17:47.820 --> 00:17:51.820
if it's, let's say, it's frozen, and then you say, you use VS Code, it's going to tell you


00:17:51.820 --> 00:17:55.820
that it's frozen on run, a function called run, and then there's 600 layers


00:17:55.820 --> 00:17:58.540
of C++ underneath, which ones you don't know.


00:17:58.540 --> 00:18:00.380
Or like, for instance, you just say,


00:18:00.380 --> 00:18:02.780
let's say for mysterious reasons,


00:18:02.780 --> 00:18:04.700
NumPy has a bug or something, right?


00:18:04.700 --> 00:18:06.340
And then you're adding two NumPy arrays,


00:18:06.340 --> 00:18:08.780
and it's telling you that the addition of the NumPy arrays


00:18:08.780 --> 00:18:10.900
is what is being frozen,


00:18:10.900 --> 00:18:13.100
but you don't know what is happening underneath.


00:18:13.100 --> 00:18:15.740
And then you want to see what's happening


00:18:15.740 --> 00:18:17.780
on the NumPy C++ code,


00:18:17.780 --> 00:18:20.820
or the SciPy code, or the TensorFlow code.


00:18:20.820 --> 00:18:22.420
You know, there is countless examples


00:18:22.420 --> 00:18:26.220
of heavy C++ or compile code underneath.


00:18:26.220 --> 00:18:29.220
For instance, Pydantic these days is running on Rust,


00:18:29.220 --> 00:18:31.620
which means that if something goes wrong there,


00:18:31.620 --> 00:18:34.420
or it just crashes or is freezing or whatever,


00:18:34.420 --> 00:18:36.420
you're going to not see it either.


00:18:36.420 --> 00:18:38.420
So we're talking about those cases.


00:18:38.420 --> 00:18:43.420
We've seen deadlocks on the GCDEL of an object


00:18:43.420 --> 00:18:45.420
that's defined in an extension module.


00:18:45.420 --> 00:18:48.920
And when that happens, all the Python debugger is going to tell you is absolutely nothing.


00:18:48.920 --> 00:18:51.920
It doesn't see the call into the tpdel method.


00:18:51.920 --> 00:18:57.920
it doesn't see. All it shows you is that there is a variable that's going out of scope or being reassigned or something like that


00:18:57.920 --> 00:19:02.920
on the last Python line that was run, and anything happening under that is just totally opaque to it.


00:19:02.920 --> 00:19:07.920
Right. On the other hand, just talking about the other tools. So on the other hand, things like GDB


00:19:07.920 --> 00:19:12.920
have the same problem that we're talking about. GDB only understands C code. So what it's going to show you is that


00:19:12.920 --> 00:19:19.920
your interpreter is going to show you the kind of NumPy code underneath or the C++ code underneath or the RAS code underneath.


00:19:19.920 --> 00:19:23.220
but it's not going to show you the Python code, so you don't know what we'll call that.


00:19:23.220 --> 00:19:24.880
So this is the other side of the coin.


00:19:24.880 --> 00:19:25.880
You're going to see like...


00:19:25.880 --> 00:19:27.420
I see a lot of C action happening.


00:19:27.420 --> 00:19:29.420
But how I reach this C, we don't know.


00:19:29.420 --> 00:19:36.020
And the situation when this is really bad is when you kind of enter and exit the C realm multiple times, right?


00:19:36.020 --> 00:19:38.520
So you have some Python code that calls some C code,


00:19:38.520 --> 00:19:40.520
and in turn it calls some Python code again,


00:19:40.520 --> 00:19:42.520
and some C code again.


00:19:42.520 --> 00:19:46.220
So that is kind of really hard because you're going to not see anything.


00:19:46.220 --> 00:19:49.720
Like it's impossible because you don't know how you reach this situation.


00:19:49.720 --> 00:19:55.080
And that's quite hard. So like the classic debuggers won't be able to do so.


00:19:55.080 --> 00:19:59.640
Interestingly, though, because we are going to see that there is some other tools that have some functionality


00:19:59.640 --> 00:20:01.960
close to what PyStack does.


00:20:01.960 --> 00:20:06.120
So in Python, in CPython, we provide some like plugins, let's call it,


00:20:06.120 --> 00:20:10.440
it's basically an extension files that you can kind of add to GDB


00:20:10.440 --> 00:20:13.240
that allows you to do some similar things.


00:20:13.240 --> 00:20:18.040
So for instance, the Python files that you can put in GDB


00:20:18.040 --> 00:20:20.120
allows you to pretty print Python objects.


00:20:20.120 --> 00:20:23.320
So even if you're in the C world, you can kind of print some objects.


00:20:23.320 --> 00:20:26.600
And you can also print like some kind of like Python stack tree.


00:20:26.600 --> 00:20:30.280
So you can ask like, hey, can you kind of show me what I'm in Python,


00:20:30.280 --> 00:20:31.640
but it's not a hybrid one.


00:20:31.640 --> 00:20:33.560
So it will only tell you where you are in Python,


00:20:33.560 --> 00:20:36.440
which means that you're going to miss the C version.


00:20:36.440 --> 00:20:39.080
Because this GDB, you can also ask for the C version,


00:20:39.080 --> 00:20:40.600
but you're not going to see them together.


00:20:40.600 --> 00:20:42.520
You're going to see either one or the other.


00:20:42.520 --> 00:20:45.800
And then it's up to you how to kind of like, like merge them,


00:20:45.800 --> 00:20:50.520
which sometimes is very hard because there's very hard rules to know how to do that,


00:20:50.520 --> 00:20:55.240
especially for instance in Python 3.11 and some of the optimizations we did in the Python 3,


00:20:55.240 --> 00:21:01.000
in the fastest in Python project, means that the same evaluator loop can be reused for multiple


00:21:01.000 --> 00:21:07.080
Python functions. So you, in 3.11, you are not even able to do it without extra metadata.


00:21:07.080 --> 00:21:12.680
So it's quite hard. And even if this, let's say, plugins are actually useful and can get you


00:21:12.680 --> 00:21:17.280
closer and for a lot of time that was useful and the only way to do that


00:21:17.280 --> 00:21:23.480
is specifically for core files because if you have a core file, your only option is using DDB or Wasp before Biostats.


00:21:23.480 --> 00:21:28.280
You could somehow do it. The problem is that DDB relies on


00:21:28.280 --> 00:21:31.280
to do this relies on debugging information inside the core,


00:21:31.280 --> 00:21:37.200
which means that if you have Python interpreters that don't have the right information, which by the way is most Python


00:21:37.200 --> 00:21:40.200
interpreters that are shipping distributions


00:21:40.200 --> 00:21:42.200
or most Python interpreters that are used normally,


00:21:42.200 --> 00:21:45.200
because you don't want to ship gigantic debugging information to production


00:21:45.200 --> 00:21:47.200
most of the time, because this can get really big.


00:21:47.200 --> 00:21:49.200
It means that GDB is not going to work,


00:21:49.200 --> 00:21:52.200
because it relies on the fact that it can inspect


00:21:52.200 --> 00:21:55.200
local C variables inside the frames.


00:21:55.200 --> 00:21:58.200
And as many C programmers will tell you,


00:21:58.200 --> 00:22:01.200
the most common thing that GDB will tell you


00:22:01.200 --> 00:22:05.200
is optimized expression, which means that I cannot tell you anything here,


00:22:05.200 --> 00:22:07.200
which means that it's not going to work.


00:22:07.200 --> 00:22:11.200
There's ways to make it work, but we are entering the expert realm here.


00:22:11.200 --> 00:22:15.200
Making GDB work here is the kind of like,


00:22:15.200 --> 00:22:19.200
you need two staff engineers or a CPython core that knows what is going on.


00:22:19.200 --> 00:22:23.200
So that's certainly not for your average Python program.


00:22:23.200 --> 00:22:27.200
Let's remember, we are trying to debug something, which probably we are under pressure.


00:22:27.200 --> 00:22:31.200
We don't want to read the main page of GDB


00:22:31.200 --> 00:22:35.200
and Python and how to debug Python with GDB and debugging.


00:22:35.200 --> 00:22:36.800
What is the right information?


00:22:36.800 --> 00:22:39.880
So if you're a Python programmer and just want to


00:22:39.880 --> 00:22:42.400
paste a stack trace in a back report, for instance,


00:22:42.400 --> 00:22:44.040
because someone asked you to do that,


00:22:44.040 --> 00:22:45.840
or you just want to see what's going on,


00:22:45.840 --> 00:22:48.040
or you just want to tell someone where it's crashing,


00:22:48.040 --> 00:22:49.760
you don't want to learn all of these things.


00:22:49.760 --> 00:22:50.720
You don't even have time.


00:22:50.720 --> 00:22:53.760
Maybe you need to fix it, it's crashing on production.


00:22:53.760 --> 00:22:55.720
You cannot just tell your boss,


00:22:55.720 --> 00:22:58.640
oh yes, wait here until I read the man page of GDB.


00:22:58.640 --> 00:22:59.480
It's not going to help.


00:22:59.480 --> 00:23:00.960
- Yeah, I don't know how many people,


00:23:00.960 --> 00:23:02.960
I imagine a good number,


00:23:02.960 --> 00:23:04.640
but not all of the people listening


00:23:04.640 --> 00:23:09.080
have had an application or an API or something crashing in production


00:23:09.080 --> 00:23:11.080
when people are trying to get to it, it's very stressful.


00:23:11.080 --> 00:23:12.080
Right.


00:23:12.080 --> 00:23:15.320
I should add that distributions do generally give you a way


00:23:15.320 --> 00:23:19.120
to get at the debug data for an interpreter.


00:23:19.120 --> 00:23:22.960
It's not as though they strip it off entirely and it's gone forever.


00:23:22.960 --> 00:23:25.120
It's just that the way that you get at it after the fact


00:23:25.120 --> 00:23:27.160
is different per distribution,


00:23:27.160 --> 00:23:31.760
and it's not something that necessarily everyone who's firing up GDB knows how to do.


00:23:31.760 --> 00:23:33.400
So it's not that it's gone forever,


00:23:33.400 --> 00:23:36.500
it's just that it's not easily accessible to everyone, I'd say.


00:23:36.500 --> 00:23:39.000
Sure. Can you add it afterwards?


00:23:39.000 --> 00:23:43.200
Like if my app crashes and I'm like, "Oh no, I didn't have the debug information."


00:23:43.200 --> 00:23:49.940
You can, actually. It'll either be like on Ubuntu, it'll be a Python 3-debug package that you install,


00:23:49.940 --> 00:23:56.540
or there's also a thing called DebugInfoD that can download the debug information


00:23:56.540 --> 00:24:02.340
from servers managed by your distribution as needed when a debugger requests it, which is pretty cool.


00:24:02.340 --> 00:24:05.340
But the problem is that this still doesn't assure you that it is going to work.


00:24:05.340 --> 00:24:07.140
It's just that it gives you more chances.


00:24:07.140 --> 00:24:10.560
But still, if your Python interpreter is heavily optimized,


00:24:10.560 --> 00:24:12.020
this may be not enough.


00:24:12.020 --> 00:24:15.320
And actually, for the sake of giving data,


00:24:15.320 --> 00:24:17.560
in most distributions, it's actually not enough.


00:24:17.560 --> 00:24:21.700
Because these variables, particularly the frame variable in the Python evaluator loop,


00:24:21.700 --> 00:24:25.540
is extremely heavily optimized, among other things, because it has to be.


00:24:25.540 --> 00:24:27.740
Because the Python evaluator loop is very hotbar.


00:24:27.740 --> 00:24:31.500
So most of the time, these tools are, let's say, unreliable.


00:24:31.500 --> 00:24:33.860
Let's introduce kind of like what PyStack does then


00:24:33.860 --> 00:24:36.660
and let's talk about also like what other tools you can use


00:24:36.660 --> 00:24:37.660
that are not PyStack maybe.


00:24:37.660 --> 00:24:40.500
- I think that's probably a good setup for PyStack.


00:24:40.500 --> 00:24:42.140
Like why does it exist?


00:24:42.140 --> 00:24:45.460
Why do people really, why is it such a game changer, right?


00:24:45.460 --> 00:24:49.300
It understands both of these worlds in a really nice way.


00:24:49.300 --> 00:24:50.140
Tell us about it.


00:24:50.140 --> 00:24:51.340
- Exactly, so the short version,


00:24:51.340 --> 00:24:53.060
because this is quite funny because like


00:24:53.060 --> 00:24:55.420
when we were at PyCon, we were presenting


00:24:55.420 --> 00:24:57.820
both projects that we maintain here, PyStack and Memory.


00:24:57.820 --> 00:25:00.900
And Memory, everybody knew, PyStack was the new one.


00:25:00.900 --> 00:25:03.700
A lot of people didn't kind of catch exactly what it does.


00:25:03.700 --> 00:25:06.060
And it's actually easier to explain than the profiler,


00:25:06.060 --> 00:25:09.180
which I think is quite funny that that was the other way.


00:25:09.180 --> 00:25:11.300
So the PyStack, what it does is very simple.


00:25:11.300 --> 00:25:14.780
So PyStack is a tool when you give it a Python program


00:25:14.780 --> 00:25:17.620
that is running or frozen, right?


00:25:17.620 --> 00:25:20.420
But let's say it's alive or a core file,


00:25:20.420 --> 00:25:22.740
and it will tell you what it's doing.


00:25:22.740 --> 00:25:24.460
So it will give you the stack trace, basically.


00:25:24.460 --> 00:25:25.660
So it's going to tell you,


00:25:25.660 --> 00:25:28.300
okay, so this Python program has this many threads,


00:25:28.300 --> 00:25:29.140
and for every thread,


00:25:29.140 --> 00:25:30.780
it's going to show you the stack trace, right?


00:25:30.780 --> 00:25:34.380
So this function is calling this function is calling this function and is running currently.


00:25:34.380 --> 00:25:36.220
Like a snapshot in time, right?


00:25:36.220 --> 00:25:39.380
When you asked it, it's like, boom, what are all the threads doing?


00:25:39.380 --> 00:25:39.980
Here you go.


00:25:39.980 --> 00:25:40.660
Exactly.


00:25:40.660 --> 00:25:44.740
So if the program is running, which you can absolutely run PyStack on a healthy running program,


00:25:44.740 --> 00:25:46.660
it's going to tell you what it was doing at that time.


00:25:46.660 --> 00:25:51.460
So by default, it's going to stop the program for a super small amount of time.


00:25:51.460 --> 00:25:53.780
It's going to take a photo of what the program is doing,


00:25:53.780 --> 00:25:55.820
and it's going to tell you what every thread was doing.


00:25:55.820 --> 00:25:59.540
So who calls who and what the program was actually running at that time.


00:25:59.540 --> 00:26:02.540
The program is frozen because you have a log or something like that.


00:26:02.540 --> 00:26:05.840
It's going to show you what is blocked, basically.


00:26:05.840 --> 00:26:08.240
And if you have a core file because your program crashed


00:26:08.240 --> 00:26:10.140
or because you generate one on demand,


00:26:10.140 --> 00:26:12.940
because by the way, you can absolutely generate one core on demand,


00:26:12.940 --> 00:26:14.940
just take a snapshot and it's there.


00:26:14.940 --> 00:26:17.640
It will tell you what the program was doing, what the core was generated.


00:26:17.640 --> 00:26:21.040
That's something you can do in Linux just in the terminal.


00:26:21.040 --> 00:26:24.240
You can just say, take a core dump of some running process.


00:26:24.240 --> 00:26:26.240
Yeah. For instance, you can do it with GDB


00:26:26.240 --> 00:26:29.140
or with a utility that sells out to GDB called gcore.


00:26:29.140 --> 00:26:31.140
which is installed by default when you install GDB.


00:26:31.140 --> 00:26:34.140
And the cherry on the top here is that it will tell you both


00:26:34.140 --> 00:26:36.140
the Python code and the C code.


00:26:36.140 --> 00:26:40.140
So it will tell you like, "Okay, so we are calling these Python functions,


00:26:40.140 --> 00:26:43.140
you know, main and main calls, you know, createDictionary


00:26:43.140 --> 00:26:46.140
and createDictionary calls addNumpyArray.


00:26:46.140 --> 00:26:48.140
But then when it enters C code, the C Realm,


00:26:48.140 --> 00:26:50.140
it's going to show you also the C calls.


00:26:50.140 --> 00:26:53.140
And then if it enters Python again, it's going to show you Python again


00:26:53.140 --> 00:26:56.140
and C again, and it's going to tell you if it's Python or C.


00:26:56.140 --> 00:26:58.740
and also it's going to show you code that is running.


00:26:58.740 --> 00:27:02.480
So if the source code is available, which most time it is,


00:27:02.480 --> 00:27:04.480
it's going to show you exactly what line--


00:27:04.480 --> 00:27:05.740
like the same thing as a traceback.


00:27:05.740 --> 00:27:08.280
Basically, it's going to show you what line was running.


00:27:08.280 --> 00:27:10.880
And very cool as well, since Python 3.11,


00:27:10.880 --> 00:27:13.820
it's going to show you what sub-expression is running.


00:27:13.820 --> 00:27:17.860
Because in Python 3.11, we have this vector error project


00:27:17.860 --> 00:27:20.620
that I started, and now we have line--


00:27:20.620 --> 00:27:24.360
sorry, column information, so we know you have a very complicated expression


00:27:24.360 --> 00:27:29.500
and something crashes, we can point you exactly to what part of the expression was generating the crash.


00:27:29.500 --> 00:27:32.400
But now we can use the same information in this tool


00:27:32.400 --> 00:27:34.240
to show you what part of the expression was running.


00:27:34.240 --> 00:27:36.840
So for instance, you were adding four NumPy arrays,


00:27:36.840 --> 00:27:40.340
and the application crashes adding the second and the third one,


00:27:40.340 --> 00:27:43.240
we can show you, okay, it's crashing, adding the second and the third one.


00:27:43.240 --> 00:27:47.040
So you can know exactly that was that operation and not the other one,


00:27:47.040 --> 00:27:48.280
which is quite cool.


00:27:48.280 --> 00:27:49.120
And the same for C.


00:27:49.120 --> 00:27:49.920
It sounds awesome.


00:27:49.920 --> 00:27:51.820
I also like the description here.


00:27:51.820 --> 00:27:54.280
PyStack is a tool that uses forbidden magic


00:27:54.280 --> 00:27:56.480
to let you inspect the stack frames.


00:27:56.480 --> 00:27:57.440
I have a process.


00:27:57.440 --> 00:27:58.820
- That's a funny trivia.


00:27:58.820 --> 00:28:01.200
I got a funny conversation with Mark Shannon.


00:28:01.200 --> 00:28:04.240
We work together on the 5.30 Python project


00:28:04.240 --> 00:28:07.360
because we say here nasty CPython internals.


00:28:07.360 --> 00:28:08.320
(laughs)


00:28:08.320 --> 00:28:09.700
Which mostly, you know, like,


00:28:09.700 --> 00:28:12.040
so we were into what is a nasty CPython internal


00:28:12.040 --> 00:28:14.660
because we both do those nasty CPython internals.


00:28:14.660 --> 00:28:15.960
But you know, I think it's,


00:28:15.960 --> 00:28:18.500
nobody really enjoys internal CPython,


00:28:18.500 --> 00:28:20.160
not even Core Devs, so there you go.


00:28:20.160 --> 00:28:23.660
Well, and I imagine that you're making your life harder with 3.11, all of you.


00:28:23.660 --> 00:28:26.960
This is kind of weird because I'm making my own job harder every single time.


00:28:26.960 --> 00:28:32.060
So I work on Python, I'm happy, and then I'm sad because I just make my own life harder


00:28:32.060 --> 00:28:33.460
on the other side of the pool, right?


00:28:33.460 --> 00:28:35.960
This is a project that would be much, much harder to maintain


00:28:35.960 --> 00:28:37.760
if Pablo wasn't around to help on it.


00:28:37.760 --> 00:28:40.960
Because, yeah, in order to keep this forbidden magic working,


00:28:40.960 --> 00:28:43.860
we do need to keep up with changes to the interpreter.


00:28:43.860 --> 00:28:48.060
And it's a place where if we didn't have core devs telling us what changed in the interpreter,


00:28:48.060 --> 00:28:50.420
it would be very hard to keep up with those changes


00:28:50.420 --> 00:28:51.920
and figure out just what has changed.


00:28:51.920 --> 00:28:55.760
- Especially since the faster CPython stuff has kicked into gear.


00:28:55.760 --> 00:28:57.860
- One thing here, which is also quite interesting,


00:28:57.860 --> 00:29:01.360
is that we are not the only people to enjoy this forbidden magic.


00:29:01.360 --> 00:29:03.100
We have a coen, let's say.


00:29:03.100 --> 00:29:05.540
This forbidden magic is shared in one way or the other


00:29:05.540 --> 00:29:07.100
with performance profilers.


00:29:07.100 --> 00:29:09.940
So, for instance, some of the ones that use similar techniques


00:29:09.940 --> 00:29:14.280
are Austin, the Austin profiler, and also PySpy.


00:29:14.280 --> 00:29:16.980
And it's quite interesting because there is a difference.


00:29:16.980 --> 00:29:19.340
both tools can actually do something similar.


00:29:19.340 --> 00:29:22.220
So both PyStack and Austin kind of take a snapshot


00:29:22.220 --> 00:29:24.580
and show you what the application is doing.


00:29:24.580 --> 00:29:26.680
At the time of this podcast,


00:29:26.680 --> 00:29:28.280
they can do it for a live process,


00:29:28.280 --> 00:29:29.660
they cannot do it for a core file.


00:29:29.660 --> 00:29:31.380
So if you have a core file, you are out of luck,


00:29:31.380 --> 00:29:32.560
you can only use PyStack.


00:29:32.560 --> 00:29:35.720
If you have a live process, you can use PyStack,


00:29:35.720 --> 00:29:39.060
but you can also use PySpy or Austin, both can do that.


00:29:39.060 --> 00:29:42.040
The main difference here, even if we share functionality,


00:29:42.040 --> 00:29:44.560
is that we are not a profiler, we are a debugger,


00:29:44.560 --> 00:29:48.560
which means that we try really, really hard


00:29:48.560 --> 00:29:50.360
to find that information,


00:29:50.360 --> 00:29:53.000
even in the most weird situation.


00:29:53.000 --> 00:29:55.920
So for instance, even if you have corrupted memory


00:29:55.920 --> 00:29:58.200
or your file or your core file is corrupted


00:29:58.200 --> 00:30:01.440
or your process is really, really in a bad state,


00:30:01.440 --> 00:30:03.200
we can still give you the information,


00:30:03.200 --> 00:30:05.240
even if you don't have the back symbols


00:30:05.240 --> 00:30:07.880
or we are slower than both profilers


00:30:07.880 --> 00:30:11.480
because both PySpy and Austin need to basically take photos


00:30:11.480 --> 00:30:12.680
at a very high speed


00:30:12.680 --> 00:30:14.680
because that's what the profiler does.


00:30:14.680 --> 00:30:16.880
It basically takes a lot of photos very fast.


00:30:16.880 --> 00:30:17.840
And then it's going to show you,


00:30:17.840 --> 00:30:20.480
okay, I took like 1 million photos in a second.


00:30:20.480 --> 00:30:21.600
And most of the time,


00:30:21.600 --> 00:30:23.960
the photos show that you were in this function


00:30:23.960 --> 00:30:25.240
called various low function.


00:30:25.240 --> 00:30:26.980
So that is going to tell you,


00:30:26.980 --> 00:30:28.920
well, you're spending most of the time in this function,


00:30:28.920 --> 00:30:30.340
you should optimize that function.


00:30:30.340 --> 00:30:32.400
So for them, it's really, really important


00:30:32.400 --> 00:30:34.160
to take those photos really fast, right?


00:30:34.160 --> 00:30:36.880
Sometimes even sacrificing correctness in some cases.


00:30:36.880 --> 00:30:39.720
- Yeah, the same thing with profilers especially, yeah.


00:30:39.720 --> 00:30:41.600
- Right, they have some option to control the correctness


00:30:41.600 --> 00:30:43.240
because they need to kind of sometimes guess


00:30:43.240 --> 00:30:45.320
and sometimes these photos they take


00:30:45.320 --> 00:30:47.400
with the process running.


00:30:47.400 --> 00:30:49.400
So, you know, it can be like half of the photo


00:30:49.400 --> 00:30:51.200
in one place and half of the other in the other


00:30:51.200 --> 00:30:53.400
and both have like options to control


00:30:53.400 --> 00:30:54.840
if you want that or not.


00:30:54.840 --> 00:30:56.800
- It's like a friendly pair in a video game.


00:30:56.800 --> 00:30:58.120
- Yeah, pretty much.


00:30:58.120 --> 00:31:01.560
I always think about that particular metaphor


00:31:01.560 --> 00:31:02.560
when I explain this,


00:31:02.560 --> 00:31:04.040
but most people don't know what that is.


00:31:04.040 --> 00:31:08.080
So I'm very happy to know that you're a connoisseur as well.


00:31:08.080 --> 00:31:10.160
The main difference is that for them,


00:31:10.160 --> 00:31:12.160
they do a very good work just to be clear here.


00:31:12.160 --> 00:31:14.560
But for them, the main concern is the speed, right?


00:31:14.560 --> 00:31:18.040
And the whole thing is surrounded by this idea


00:31:18.040 --> 00:31:19.280
of doing this operation very fast.


00:31:19.280 --> 00:31:21.680
And because they do it very fast, they can do it once.


00:31:21.680 --> 00:31:24.760
So you just ask for one photo, they can give you that photo.


00:31:24.760 --> 00:31:27.160
In our case, our concern is not the speed


00:31:27.160 --> 00:31:28.160
because we are not a profiler.


00:31:28.160 --> 00:31:30.640
Our concern is correctness and the photo.


00:31:30.640 --> 00:31:32.640
So we really, really, really hard


00:31:32.640 --> 00:31:36.440
try to get the correct photo and the photo if it is possible.


00:31:36.440 --> 00:31:38.340
So that's kind of the main difference.


00:31:38.340 --> 00:31:44.140
This portion of Talk Python to Me is sponsored by the Compiler Podcast from Red Hat.


00:31:44.140 --> 00:31:48.140
Just like you, I'm a big fan of podcasts, and I'm happy to share a new one from a highly


00:31:48.140 --> 00:31:52.940
respected open source company, Compiler, an original podcast from Red Hat.


00:31:52.940 --> 00:31:56.860
Do you want to stay on top of tech without dedicating tons of time to it?


00:31:56.860 --> 00:32:00.940
Compiler presents perspectives, topics, and insights from the tech industry, free from


00:32:00.940 --> 00:32:02.540
jargon and judgment.


00:32:02.540 --> 00:32:05.820
They want to discover where technology is headed beyond the headlines and create a place


00:32:05.820 --> 00:32:09.540
for new IT professionals to learn, grow, and thrive.


00:32:09.540 --> 00:32:13.260
Compiler helps people break through the barriers and challenges turning code into community


00:32:13.260 --> 00:32:16.080
at all levels of the enterprise.


00:32:16.080 --> 00:32:19.300
One recent and interesting episode is there, the Great Stack Debate.


00:32:19.300 --> 00:32:23.520
I love love love talking to people about how they architect their code, the trade-offs


00:32:23.520 --> 00:32:28.860
and conventions they chose, and the costs, challenges, and smiles that result.


00:32:28.860 --> 00:32:31.300
This Great Stack Debate episode is like that.


00:32:31.300 --> 00:32:35.840
Check it out and see if software is more like an onion, or more like lasagna, or maybe even


00:32:35.840 --> 00:32:37.480
more complicated than that.


00:32:37.480 --> 00:32:41.420
It's the first episode in Compiler's series on software stacks.


00:32:41.420 --> 00:32:45.340
Learn more about Compiler at talkpython.fm/compiler.


00:32:45.340 --> 00:32:47.460
The link is in your podcast player show notes.


00:32:47.460 --> 00:32:52.500
And yes, you could just go search for Compiler and subscribe to it, but follow that link


00:32:52.500 --> 00:32:57.320
and click on your player's icon to add it, that way they know you came from us.


00:32:57.320 --> 00:33:01.640
Our thanks to the compiler podcast for keeping this podcast going strong.


00:33:01.640 --> 00:33:08.020
This means that if you are already using a lot of people are using


00:33:08.020 --> 00:33:11.480
PySpy for instance for this kind of my Python application is frozen.


00:33:11.480 --> 00:33:14.820
So in that case, you don't care if the photo is fast or slow because it's already


00:33:14.820 --> 00:33:18.080
frozen. Like who cares, right? But on the other hand, if you have a crashing


00:33:18.080 --> 00:33:20.780
application, especially a core file, then you're kind of over the luck because


00:33:20.780 --> 00:33:24.000
this process, these projects don't work at the time that we're speaking for core


00:33:24.000 --> 00:33:27.400
Yeah, PyStack really seems to have a unique feature set,


00:33:27.400 --> 00:33:29.600
a special place in the ecosystem.


00:33:29.600 --> 00:33:33.240
And most of the extra features that PyStack has,


00:33:33.240 --> 00:33:34.760
which are not the main functionality,


00:33:34.760 --> 00:33:38.680
are basically around this idea of we are the buyer.


00:33:38.680 --> 00:33:40.880
So for instance, we can give you extra metadata.


00:33:40.880 --> 00:33:42.840
Like, you know, some of this metadata


00:33:42.840 --> 00:33:44.200
actually also is shared with these tools,


00:33:44.200 --> 00:33:45.120
but some others is not.


00:33:45.120 --> 00:33:46.360
So we give you things like,


00:33:46.360 --> 00:33:48.200
which thread has the gil at the time,


00:33:48.200 --> 00:33:51.200
or like if the GC is running on the thread or not.


00:33:51.200 --> 00:33:54.960
we also tell you like the column offsets and things like that.


00:33:54.960 --> 00:33:59.160
So there is a lot of like extra stuff that we can provide to you


00:33:59.160 --> 00:34:03.000
so you can back easily, more easily your applications.


00:34:03.000 --> 00:34:05.440
For instance, for the SQL, if it's available,


00:34:05.440 --> 00:34:08.880
which means that we can give you the column offsets as well


00:34:08.880 --> 00:34:12.080
of the source code that generated the binaries.


00:34:12.080 --> 00:34:14.400
You need a modern compiler to do that.


00:34:14.400 --> 00:34:18.000
Like only DWARF 4, I think, has this information.


00:34:18.000 --> 00:34:19.800
DWARF is the debugging format for C,


00:34:19.800 --> 00:34:22.200
which is kind of funny because the binary format is ELF.


00:34:22.200 --> 00:34:23.840
So, you know, it's ELF and DWARF.


00:34:23.840 --> 00:34:27.080
ELF stands for Ex-Final-Unlinkable Format.


00:34:27.080 --> 00:34:30.600
But DWARF doesn't have an acronym.


00:34:30.600 --> 00:34:32.160
It's just funny.


00:34:32.160 --> 00:34:34.760
They come with this weird backronym, I think they call it,


00:34:34.760 --> 00:34:37.040
when you come with acronym after the fact.


00:34:37.040 --> 00:34:38.840
So you just say, "Oh, DWARF is very funny.


00:34:38.840 --> 00:34:40.200
"Let's try to put it."


00:34:40.200 --> 00:34:42.520
And I think now it stands on


00:34:42.520 --> 00:34:45.200
debugging with arbitrary format something.


00:34:45.200 --> 00:34:46.640
Like, it's just really bad.


00:34:46.640 --> 00:34:51.340
- Yeah, yeah, yeah, you try to fit the acronym into the thing, yeah, yeah.


00:34:51.340 --> 00:34:54.540
Then we call it the TREC service, and we'll see where it goes from there.


00:34:54.540 --> 00:34:56.540
- Exactly, yeah, literally.


00:34:56.540 --> 00:34:59.940
So the idea is that we give you this extra kind of metadata around it.


00:34:59.940 --> 00:35:02.180
Every time we do this, we try to do more.


00:35:02.180 --> 00:35:05.220
For instance, we are now talking about with 3.12,


00:35:05.220 --> 00:35:07.520
we are going to release in Python subinterpreters.


00:35:07.520 --> 00:35:11.620
So we are discussing the possibility of showing subinterpreters also in PyStack


00:35:11.620 --> 00:35:13.020
or maybe async.io task.


00:35:13.020 --> 00:35:15.300
I mean, these are not actual features that we are running right now,


00:35:15.300 --> 00:35:17.700
but the idea is that we are considering these things


00:35:17.700 --> 00:35:20.100
and that for a profiler, maybe it's just too hard


00:35:20.100 --> 00:35:23.260
because it means that you need to inspect a lot more memory


00:35:23.260 --> 00:35:26.540
and your photo is going to be prohibited as low.


00:35:26.540 --> 00:35:28.700
For us, it's not because we just take one photo


00:35:28.700 --> 00:35:30.380
and it just needs to be a very good one.


00:35:30.380 --> 00:35:31.420
- Yeah, excellent.


00:35:31.420 --> 00:35:33.820
Yeah, see, you are making your life harder over and over.


00:35:33.820 --> 00:35:36.860
Quick question from the audience in the live stream.


00:35:36.860 --> 00:35:39.580
Tony says, "Could this be utilized in something like


00:35:39.580 --> 00:35:41.660
AWS Lambda as error handling?


00:35:41.660 --> 00:35:43.940
Grab the core dump if it bombs,


00:35:43.940 --> 00:35:47.040
since you wouldn't have access to the runtime after the lambda executed?


00:35:47.040 --> 00:35:49.740
I wouldn't. It's not the...


00:35:49.740 --> 00:35:53.340
As a compiler engineer, I would say I don't know anything about AWS.


00:35:53.340 --> 00:35:56.240
So I don't know if it's the best way to do it.


00:35:56.240 --> 00:35:58.240
But yeah, absolutely, this is something that you can do.


00:35:58.240 --> 00:36:01.940
If you generate a core file, then PyStack can absolutely handle your core file.


00:36:01.940 --> 00:36:02.540
No problem.


00:36:02.540 --> 00:36:06.240
I think the only question I have there is if you can get the core file out after it has crashed.


00:36:06.240 --> 00:36:08.440
But as long as there's some way to get the core file out,


00:36:08.440 --> 00:36:10.740
you definitely could inspect it with PyStack.


00:36:10.740 --> 00:36:11.740
Oh, interesting.


00:36:11.740 --> 00:36:17.660
Is there a Python code level API for working with PyStack or is it an outside only thing?


00:36:17.660 --> 00:36:19.980
No, at the time it's just a command line application.


00:36:19.980 --> 00:36:20.940
Gotcha. Okay.


00:36:20.940 --> 00:36:25.340
We could expose it like PyStack is mainly a library with a lot of like functionality.


00:36:25.340 --> 00:36:29.820
So if there is people that want to use it for other things, we are quite happy to expose it.


00:36:29.820 --> 00:36:35.420
Yeah, I'm thinking things like for CProfile, you can, you know, turn off the profiling at startup


00:36:35.420 --> 00:36:40.940
and then turn it back on with Python code or where you could set like an at exit callback


00:36:40.940 --> 00:36:43.220
potentially to like those kinds of things.


00:36:43.220 --> 00:36:46.780
We don't have these, but we do have some other cool thing that,


00:36:46.780 --> 00:36:50.260
let's say, intersects 20% with what you said, just to be clear.


00:36:50.260 --> 00:36:53.260
I'm not trying to answer your question fully, but I think it's right.


00:36:53.260 --> 00:36:56.900
We have this pytest plugin, which basically you can install.


00:36:56.900 --> 00:37:00.100
And if some of your tests crashes, it's going to just run PyStack.


00:37:00.100 --> 00:37:01.300
It crashes or freezes.


00:37:01.300 --> 00:37:02.940
It's going to run PyStack on that.


00:37:02.940 --> 00:37:04.740
And it's going to show you what happened.


00:37:04.740 --> 00:37:07.420
We are talking also to have something similar to FoldHandler,


00:37:07.420 --> 00:37:10.620
which is a standard library module that you can activate.


00:37:10.620 --> 00:37:13.220
And if your process crashes, it shows you the Python stack,


00:37:13.220 --> 00:37:14.860
but again, you're missing the C stack.


00:37:14.860 --> 00:37:18.220
So we are going to allow you to also have this idea of like,


00:37:18.220 --> 00:37:20.300
oh, I want to just run my Python application.


00:37:20.300 --> 00:37:23.860
And if it crashes, then I want PyStack to be run on the process


00:37:23.860 --> 00:37:26.260
so I can see what was happening there.


00:37:26.260 --> 00:37:29.340
By the way, this literally is something that was used,


00:37:29.340 --> 00:37:32.580
for instance, URLib3, the project URLib3,


00:37:32.580 --> 00:37:36.500
I think is the most downloaded package on PyPI, or it's close to be.


00:37:36.500 --> 00:37:39.780
So they use Memroy, which is our memory profiler.


00:37:39.780 --> 00:37:43.620
And sometimes, you know, again, when the mall was full on Wednesdays,


00:37:43.620 --> 00:37:46.260
it was crashing on some weird test.


00:37:46.260 --> 00:37:48.960
And, you know, at the time we asked them,


00:37:48.960 --> 00:37:52.200
"Well, you know, memory uses C++ code underneath,


00:37:52.200 --> 00:37:53.500
no surprise there.


00:37:53.500 --> 00:37:56.040
And you're using Python code that uses memory,


00:37:56.040 --> 00:37:58.400
so the crash is happening in some combination of both."


00:37:58.400 --> 00:38:01.380
And we needed both stacks to debug what was going on.


00:38:01.380 --> 00:38:05.340
And I thought, "Man, if only we have PyStack open source,


00:38:05.340 --> 00:38:08.080
we could just tell them, like, 'Run this thing on your test suite.'"


00:38:08.080 --> 00:38:09.480
but at the time we didn't have it.


00:38:09.480 --> 00:38:12.280
So we had to ask them for a core file.


00:38:12.280 --> 00:38:17.280
They tried, but at the end we ended up having to try to reproduce it on our side,


00:38:17.280 --> 00:38:20.280
which was really hard because this was a race condition, basically.


00:38:20.280 --> 00:38:23.180
And the race... So I did all the weird techniques,


00:38:23.180 --> 00:38:27.680
like running a Docker container with 0.001 CPU quota,


00:38:27.680 --> 00:38:30.780
like running hundreds of test suites at the same time.


00:38:30.780 --> 00:38:32.680
It was not a fun afternoon, let's say.


00:38:32.680 --> 00:38:36.280
If I recall correctly, that took us a full 24 hours to reproduce,


00:38:36.280 --> 00:38:39.720
just running the tests in a loop until we managed to catch it the first time.


00:38:39.720 --> 00:38:40.280
Wow.


00:38:40.280 --> 00:38:44.200
You're running to my room at the time, you see this meme when there's this guy


00:38:44.200 --> 00:38:48.360
with the blackboard without the threads, like, moving their hands like super crazy.


00:38:48.360 --> 00:38:54.280
Like, so that was me at the time, running like six, like six DMX splits with the test suite.


00:38:54.280 --> 00:38:58.120
So yeah, this tool is when you need it, it's really useful.


00:38:58.120 --> 00:39:00.440
It's the kind of thing that a lot of times you don't need.


00:39:00.440 --> 00:39:03.160
That's interesting. And then when you do need it, amazing.


00:39:03.160 --> 00:39:06.160
And this is key because what happens normally with the bargaining tools,


00:39:06.160 --> 00:39:08.360
like GDB is a very good example of this,


00:39:08.360 --> 00:39:10.000
is that they are very hard to use.


00:39:10.000 --> 00:39:13.760
Like the amount of knowledge that you need is quite high.


00:39:13.760 --> 00:39:15.240
They are not very ergonomic,


00:39:15.240 --> 00:39:17.280
which means that it's not the easiest thing.


00:39:17.280 --> 00:39:19.640
You need to get used to them and their language


00:39:19.640 --> 00:39:21.520
and what they can do and what they cannot do.


00:39:21.520 --> 00:39:25.440
And it's the kind of thing that normally people learn when they need to,


00:39:25.440 --> 00:39:26.880
which is the worst time to learn it


00:39:26.880 --> 00:39:29.120
because you need to solve the problem, not learn how to use it.


00:39:29.120 --> 00:39:30.760
You're already in a bad mental state.


00:39:30.760 --> 00:39:32.280
It's very annoying.


00:39:32.280 --> 00:39:38.600
We are trying to do quite a lot, both on PiusTech, but also on our memory profiler membrane,


00:39:38.600 --> 00:39:41.400
is to offer a really good UX around these tools.


00:39:41.400 --> 00:39:47.040
So that's why we are offering this pytest plugin and thinking about doing this full handler thing.


00:39:47.040 --> 00:39:49.880
Because it's not just like the tool itself that you can execute,


00:39:49.880 --> 00:39:52.680
but also like we want you to not have to think about it.


00:39:52.680 --> 00:39:56.600
So it's not the tool to reach, it's the tool that is backing you up.


00:39:56.600 --> 00:40:00.000
So you set it once, you forget about the fact that it exists.


00:40:00.000 --> 00:40:03.640
When something happens, you are really happy that you set that thing up.


00:40:03.640 --> 00:40:05.400
And that's the experience that we want people.


00:40:05.400 --> 00:40:10.240
This is the other kind of extra thing that we are trying to put into Biostack.


00:40:10.240 --> 00:40:12.040
That the UX is really good.


00:40:12.040 --> 00:40:14.040
- So, you know, like Matt, I think you want to... - Yeah.


00:40:14.040 --> 00:40:17.280
And as far as the UX goes, I think it's helpful to keep in mind


00:40:17.280 --> 00:40:20.720
that when people are using these tools, it's almost certainly not because they want to.


00:40:20.720 --> 00:40:23.160
Like, no one is having a good time when they're using these tools.


00:40:23.160 --> 00:40:25.880
They're using these tools because something has already gone wrong


00:40:25.880 --> 00:40:28.480
and stopped them from doing what they wanted to be doing in the first place.


00:40:28.480 --> 00:40:31.020
and now they need to backtrack and figure out why.


00:40:31.020 --> 00:40:33.020
You're kind of like an emergency room doctor.


00:40:33.020 --> 00:40:35.420
People don't ever want to meet the emergency room doctor,


00:40:35.420 --> 00:40:36.520
but they're happy they're there.


00:40:36.520 --> 00:40:38.280
Exactly. Yeah, that's the key.


00:40:38.280 --> 00:40:38.820
Yeah.


00:40:38.820 --> 00:40:41.820
Matt, I noticed looking at the GitHub repo for PySec


00:40:41.820 --> 00:40:44.360
that there's a lot of languages involved here.


00:40:44.360 --> 00:40:48.820
We got a good chunk of Python, C++, Cython, C,


00:40:48.820 --> 00:40:50.320
only a little bit of C, I guess.


00:40:50.320 --> 00:40:54.620
But you both have to keep a lot of technology interplay in mind


00:40:54.620 --> 00:40:55.780
just working on this, right?


00:40:55.780 --> 00:40:56.780
Yeah, definitely.


00:40:56.780 --> 00:40:59.440
My career has been as a C++ developer mostly.


00:40:59.440 --> 00:41:04.580
So it tends to surprise people when we tell them that on the Python infrastructure team,


00:41:04.580 --> 00:41:09.780
we spend most of our time working on C++ and relatively little time writing Python,


00:41:09.780 --> 00:41:10.820
comparatively little.


00:41:10.820 --> 00:41:14.740
If you actually looked at the way this code breaks down in the PyStack repo,


00:41:14.740 --> 00:41:17.340
you would see that even though it's predominantly Python code,


00:41:17.340 --> 00:41:19.680
the Python code is predominantly in the test suite.


00:41:19.680 --> 00:41:26.820
most of the actual code for PyStack is in C++ or in Cython, not in Python.


00:41:26.820 --> 00:41:31.320
I was going to guess that Python might be in there, like, reporting, CLI parsing.


00:41:31.320 --> 00:41:34.420
- Later is when it is, yes. - You're exactly right.


00:41:34.420 --> 00:41:40.200
And then it is in some parts when really C++ will be overkill or too verbose or too annoying.


00:41:40.200 --> 00:41:46.740
Like, I think parsing some stuff, I think, is preparing the input to the C++ code, let's say.


00:41:46.740 --> 00:41:49.080
Yeah, parsing proc maps and things like that.


00:41:49.080 --> 00:41:52.200
But that's the thing, like one of the reasons there is so much C++ up,


00:41:52.200 --> 00:41:54.040
actually, it's not only because of performance,


00:41:54.040 --> 00:41:59.240
but because these tools need to play quite heavily on systems programming techniques.


00:41:59.240 --> 00:42:04.520
So PyStack plays a lot of, let's say, quote-unquote, "dark magic."


00:42:04.520 --> 00:42:06.920
It's not as dark as our other tool, the Profiler,


00:42:06.920 --> 00:42:10.360
because the Profiler is just in another level of darkness


00:42:10.360 --> 00:42:13.240
that has like gone through many dark rituals already.


00:42:13.240 --> 00:42:15.560
But here as well, because like at the end of the day,


00:42:15.560 --> 00:42:20.560
what these tools do, what PyStack does is that it's reading memory from a different program.


00:42:20.560 --> 00:42:24.200
That is quite complicated because when you read memory from a different program,


00:42:24.200 --> 00:42:26.940
there is nothing, it's just bytes. Here's some bytes.


00:42:26.940 --> 00:42:28.940
And then you need to figure out what they are.


00:42:28.940 --> 00:42:32.940
And most of the time, the bytes that you're reading are not backed by anything


00:42:32.940 --> 00:42:35.940
that you can use to make sense of. Because, you know, for instance, GDB,


00:42:35.940 --> 00:42:38.940
when it reads those bytes, it has the debugging information.


00:42:38.940 --> 00:42:41.940
So it knows that, oh, I'm reading bytes at this address,


00:42:41.940 --> 00:42:43.940
but these bytes means like, oh,


00:42:43.940 --> 00:42:45.940
a Pyinterpreter state extract.


00:42:45.940 --> 00:42:47.940
So I know that, you know, the first eight bytes are this


00:42:47.940 --> 00:42:49.940
and that, and I know where to locate things.


00:42:49.940 --> 00:42:51.940
We do that if it's available


00:42:51.940 --> 00:42:53.940
because we don't want to make our lives


00:42:53.940 --> 00:42:55.940
harder just for no reason, but because


00:42:55.940 --> 00:42:57.940
we have to support the cases when that information is not


00:42:57.940 --> 00:42:59.940
there, we employ these


00:42:59.940 --> 00:43:01.940
extra techniques trying to make


00:43:01.940 --> 00:43:03.940
sense of those bytes without knowing what they


00:43:03.940 --> 00:43:05.940
are. So there is like a bunch of heuristics


00:43:05.940 --> 00:43:07.940
and checks the heuristics, and this


00:43:07.940 --> 00:43:09.940
can get like quite hardcore because like, I think


00:43:09.940 --> 00:43:12.940
I think at some point we had like four levels of checks,


00:43:12.940 --> 00:43:14.940
just because of one heuristic.


00:43:14.940 --> 00:43:16.940
You know, the kind of thing when you say,


00:43:16.940 --> 00:43:19.940
"Well, there is no way in the world if these things are true


00:43:19.940 --> 00:43:21.940
is not what I'm searching for."


00:43:21.940 --> 00:43:23.940
Well, I will tell you, yes, it will happen.


00:43:23.940 --> 00:43:25.940
We have seen those.


00:43:25.940 --> 00:43:27.940
I remember that we were having this discussion.


00:43:27.940 --> 00:43:29.940
We have four checks for something.


00:43:29.940 --> 00:43:31.940
Basically, we are reading some bytes,


00:43:31.940 --> 00:43:33.940
and we are making some pointers,


00:43:33.940 --> 00:43:35.940
and if a bunch of conditions are true,


00:43:35.940 --> 00:43:38.940
we are sure that we have located some important piece of information,


00:43:38.940 --> 00:43:41.020
state, I think, or a thread state, whatever it is.


00:43:41.020 --> 00:43:44.620
And Matt was saying, "Well, but you know, there is this case when these things can be


00:43:44.620 --> 00:43:49.180
true and it's still not it because, you know, it just happens to have these properties."


00:43:49.180 --> 00:43:53.020
And I said, "Okay, let me calculate mathematically the probability of that happening."


00:43:53.020 --> 00:43:55.260
And it was 0.001%, right?


00:43:55.260 --> 00:43:57.340
And then we said, "Cool, never happening."


00:43:57.340 --> 00:43:59.020
I think it was three months until it happened.


00:43:59.020 --> 00:44:04.540
So it's like, yes, we need to take care of a lot of these things to ensure that.


00:44:04.540 --> 00:44:05.540
A lot of edge cases.


00:44:05.540 --> 00:44:07.500
I'm starting to understand the black magic.


00:44:07.500 --> 00:44:36.500
That's part of it. The other part is just like all the synonyms with like, you know, stopping the process making sense of CPython, trying to extract information from CPython in ways that CPython is not prepared to. So you need to know a lot about everything, a lot about systems programming, how to read memory from processes, how to stop processes. And also these tools, this is quite important to mention as well, these tools are supposed to GDB because when you attach GDB to a project, you can do whatever you want. You can either inject code into the process, you can call from the process, you can call from the memory, you can do whatever you want.


00:44:36.500 --> 00:44:38.500
It can call things in the process.


00:44:38.500 --> 00:44:41.500
So many teams have GDB forbidden in production


00:44:41.500 --> 00:44:44.500
because GDB, attaching GDB can do arbitrary things, right?


00:44:44.500 --> 00:44:46.500
So you don't want that a lot of the time,


00:44:46.500 --> 00:44:49.500
especially if you are under compliance or you have like secrets or whatever.


00:44:49.500 --> 00:44:53.500
- Right, right. If you're in a banking industry, say, or something like that,


00:44:53.500 --> 00:44:56.500
and you try to catch a problem and it changes,


00:44:56.500 --> 00:44:58.500
now it makes decisions, that might not be awesome.


00:44:58.500 --> 00:45:00.500
- And GDB can make your application crash.


00:45:00.500 --> 00:45:03.500
Like, you can absolutely do that because it can inject code.


00:45:03.500 --> 00:45:07.000
You see, like I invite everyone interested on,


00:45:07.000 --> 00:45:10.500
try to learn how GDB calls functions in your process.


00:45:10.500 --> 00:45:13.500
So you attach GDB, you can call a function in the process,


00:45:13.500 --> 00:45:16.220
just learn how that is done, and you're going to cry.


00:45:16.220 --> 00:45:17.500
And if you want to cry even more,


00:45:17.500 --> 00:45:19.680
because you say, "Well, man, I still have some tears


00:45:19.680 --> 00:45:21.460
"in my eyes, and it's not enough,"


00:45:21.460 --> 00:45:23.800
just learn how LLDB does it.


00:45:23.800 --> 00:45:26.520
Like this is the other debugger from LLVM,


00:45:26.520 --> 00:45:27.800
because that is just bananas.


00:45:27.800 --> 00:45:29.680
That is just another level of craziness.


00:45:29.680 --> 00:45:31.100
So these tools are very powerful,


00:45:31.100 --> 00:45:32.780
but they are also a bit dangerous.


00:45:32.780 --> 00:45:35.380
So the other thing that we really, really put a lot of effort in


00:45:35.380 --> 00:45:37.460
is that these tools just read memory.


00:45:37.460 --> 00:45:39.660
That didn't modify the process at all.


00:45:39.660 --> 00:45:42.260
The only thing they do is stop it, which is always a safe operation.


00:45:42.260 --> 00:45:44.780
Then they restart the process, that's all.


00:45:44.780 --> 00:45:47.180
And you can also choose not to stop it if you don't want to.


00:45:47.180 --> 00:45:50.500
Because, for instance, you have some super performance applications,


00:45:50.500 --> 00:45:53.340
so Biostack can still take snapshots with the process running


00:45:53.340 --> 00:45:55.740
if you really need to, sacrificing, obviously,


00:45:55.740 --> 00:45:58.460
that the photo may be a little blurry, let's say.


00:45:58.460 --> 00:46:00.660
Most of the time it will be, but it can be.


00:46:00.660 --> 00:46:01.580
But you can also ask for that.


00:46:01.580 --> 00:46:04.080
But the idea is that these are safe to use on running processes


00:46:04.080 --> 00:46:06.280
because we don't touch the memory at all, we just read it.


00:46:06.280 --> 00:46:09.380
I will say, you say that stopping a process is always safe.


00:46:09.380 --> 00:46:11.080
That's not necessarily true.


00:46:11.080 --> 00:46:14.720
It does change the behavior of syscalls that are in the middle of happening.


00:46:14.720 --> 00:46:16.580
– They get an e-enter. – E-enter.


00:46:16.580 --> 00:46:19.620
Yeah, they'll get an e-enter, and that can change the behavior of the program.


00:46:19.620 --> 00:46:21.660
What's supposed to happen is that the program detects


00:46:21.660 --> 00:46:24.420
that the syscall has been interrupted and retries it.


00:46:24.420 --> 00:46:26.660
But not all of them do that all the time,


00:46:26.660 --> 00:46:29.220
because it's C and your error handling is all manual.


00:46:29.220 --> 00:46:32.220
it's very easy to miss a place where you needed to retry something.


00:46:32.220 --> 00:46:37.020
- Especially Python does it. So it's kind of, unless you have your custom code, most of the time it's safe to do.


00:46:37.020 --> 00:46:37.520
- That's true.


00:46:37.520 --> 00:46:40.160
- But this can happen also, you send signals to your process.


00:46:40.160 --> 00:46:45.160
So for instance, you have a new process, and then it just happens to send a signal or


00:46:45.160 --> 00:46:48.860
someone interrupts the process, like for instance, because you have it under a scheduler,


00:46:48.860 --> 00:46:52.860
or you're using some very old kernel, for instance, that sends six stops,


00:46:52.860 --> 00:46:56.860
or you're running it in a cluster, when it can put you in the phrase


00:46:56.860 --> 00:46:59.280
C group, you will get the same situation.


00:46:59.280 --> 00:47:01.460
And you will see, for instance, you see Python all the time,


00:47:01.460 --> 00:47:03.260
this loop that just checks either,


00:47:03.260 --> 00:47:04.700
for instance, you're reading bytes,


00:47:04.700 --> 00:47:06.700
and then your read call finishes.


00:47:06.700 --> 00:47:08.800
And then you normally assume, well, it has finished


00:47:08.800 --> 00:47:10.800
because I have read all the bytes that I wanted.


00:47:10.800 --> 00:47:12.180
Well, it may be not true,


00:47:12.180 --> 00:47:14.100
because you may have been interrupted.


00:47:14.100 --> 00:47:15.180
So you need to try again.


00:47:15.180 --> 00:47:17.380
Sure. And at a higher level, it could be,


00:47:17.380 --> 00:47:19.140
I was calling an API,


00:47:19.140 --> 00:47:22.140
and it paused, and that actually caused it to time out.


00:47:22.140 --> 00:47:23.480
Or something like that, right?


00:47:23.480 --> 00:47:25.620
Or a database connection reset,


00:47:25.620 --> 00:47:28.120
or something weird at that level.


00:47:28.120 --> 00:47:30.540
But I think a big difference here is


00:47:30.540 --> 00:47:33.840
these are a single call went crazy


00:47:33.840 --> 00:47:36.140
while you paused it, whereas


00:47:36.140 --> 00:47:38.140
when you talk about injecting code,


00:47:38.140 --> 00:47:41.340
you could have messed it up for the rest of the life of the process.


00:47:41.340 --> 00:47:42.720
In unknown ways.


00:47:42.720 --> 00:47:43.520
Yeah, absolutely.


00:47:43.520 --> 00:47:45.980
Technically, attaching GDB is undefined behavior


00:47:45.980 --> 00:47:48.220
because you can modify a retry memory


00:47:48.220 --> 00:47:49.820
in ways that you don't know what's going on.


00:47:49.820 --> 00:47:51.560
Obviously, it's not going to be the case


00:47:51.560 --> 00:47:53.480
because GDB doesn't do that by default.


00:47:53.480 --> 00:47:56.280
But just calling functions can alter...


00:47:56.280 --> 00:47:58.280
Like, especially if you're calling to a C API.


00:47:58.280 --> 00:48:01.280
If you just happen to have a pointer and then you want to print the pointer


00:48:01.280 --> 00:48:05.080
and you call PyDumpObject, now you are like, "Who knows what happened?"


00:48:05.080 --> 00:48:08.080
You are just calling... You need the GIL, for instance, to do that.


00:48:08.080 --> 00:48:10.380
So it's very unclear what's going on.


00:48:10.380 --> 00:48:11.380
So we don't do any of that.


00:48:11.380 --> 00:48:14.880
Even in cases where you're able to successfully call a function with GDB,


00:48:14.880 --> 00:48:18.780
it manages to get its stub injected and do everything that it needs to do to set up the call,


00:48:18.780 --> 00:48:23.780
You can wind up in a situation where you don't satisfy some of the invariants for that call,


00:48:23.780 --> 00:48:27.280
and that call winds up segfaulting in code injected by GDB.


00:48:27.280 --> 00:48:30.080
And it tries to recover from that, but it can't always.


00:48:30.080 --> 00:48:34.080
So you can very easily get yourself in a situation where you thought you were doing something read-only


00:48:34.080 --> 00:48:36.580
and managed to crash the process that you were trying to inspect.


00:48:36.580 --> 00:48:40.180
You can see that we learned this the hard way from our other tool.


00:48:40.180 --> 00:48:44.480
Because one thing our memory profiler does, this is memory.


00:48:44.480 --> 00:48:46.180
So not PyStack, this is the other tool.


00:48:46.180 --> 00:48:49.360
So the other tool allows you to attach to a process, right?


00:48:49.360 --> 00:48:51.600
You have a process that is happily running,


00:48:51.600 --> 00:48:55.300
and then you say, "Now I want to profile this process that is already running."


00:48:55.300 --> 00:48:58.140
So I just want to know, every time it makes allocations,


00:48:58.140 --> 00:49:00.940
I just want to know that it's happening, or you just want to see it live.


00:49:00.940 --> 00:49:03.140
And so what we do is that in that case,


00:49:03.140 --> 00:49:06.500
we inject memory into the process to just prepare the profiler


00:49:06.500 --> 00:49:09.220
and I'll do all the stuff, which then we learn the hard way


00:49:09.220 --> 00:49:11.080
all the cases when you cannot do that.


00:49:11.080 --> 00:49:12.820
Like calling malloc under malloc,


00:49:12.820 --> 00:49:16.160
Because if your setup process requires memory,


00:49:16.160 --> 00:49:18.860
and your process is already allocated memory,


00:49:18.860 --> 00:49:21.060
then you're calling malloc under malloc,


00:49:21.060 --> 00:49:22.860
and that is undefined behavior.


00:49:22.860 --> 00:49:24.460
Well, most of the times that crash.


00:49:24.460 --> 00:49:27.580
>> Yeah, I can't imagine how tricky that stuff is, the memory stuff.


00:49:27.580 --> 00:49:29.660
All right. Let's talk through some of the features.


00:49:29.660 --> 00:49:31.080
We've touched on a lot of these,


00:49:31.080 --> 00:49:35.380
but I just got a great long list of amazing things that PyStack can do.


00:49:35.380 --> 00:49:37.580
I'll just breeze over the ones we've talked about already,


00:49:37.580 --> 00:49:40.700
but then potentially dive into the others.


00:49:40.700 --> 00:49:43.500
So it works on both running processes


00:49:43.500 --> 00:49:45.900
and it's one of the really unique aspects


00:49:45.900 --> 00:49:47.540
is on the core dump files.


00:49:47.540 --> 00:49:48.380
That's very cool.


00:49:48.380 --> 00:49:49.700
- Just to complete this part,


00:49:49.700 --> 00:49:52.020
it works on all core dump files,


00:49:52.020 --> 00:49:53.380
which is a huge,


00:49:53.380 --> 00:49:55.180
like if you are in the world


00:49:55.180 --> 00:49:56.780
of like how these things work,


00:49:56.780 --> 00:49:59.220
it's really hard because core dumps


00:49:59.220 --> 00:50:00.780
don't have a specification.


00:50:00.780 --> 00:50:01.780
So this is very important.


00:50:01.780 --> 00:50:03.140
Like there is no document


00:50:03.140 --> 00:50:05.220
that will tell you how core dumps work.


00:50:05.220 --> 00:50:06.900
This is the first surprise that you will have


00:50:06.900 --> 00:50:08.460
if you try to search for it.


00:50:08.460 --> 00:50:11.960
You will see how they normally work,


00:50:11.960 --> 00:50:15.600
but the amount of weird stuff that can happen is just countless.


00:50:15.600 --> 00:50:17.440
This is whatever the kernel is doing,


00:50:17.440 --> 00:50:19.800
and whatever the version of the kernel is doing.


00:50:19.800 --> 00:50:22.440
So you can see super weird stuff.


00:50:22.440 --> 00:50:23.740
>> Not just the kernel either.


00:50:23.740 --> 00:50:26.000
What Gcore does doesn't go through the kernel.


00:50:26.000 --> 00:50:28.200
So if you're using GDB to generate a core file,


00:50:28.200 --> 00:50:30.500
you might get something that's in an entirely different format


00:50:30.500 --> 00:50:31.680
than what the kernel would have dumped.


00:50:31.680 --> 00:50:33.380
>> The core files can miss data.


00:50:33.380 --> 00:50:36.560
So it's not really always a memory dump of the process,


00:50:36.560 --> 00:50:37.740
like a complete one.


00:50:37.740 --> 00:50:40.280
Because for instance, imagine that you're in a system


00:50:40.280 --> 00:50:42.280
and you have like five Python applications,


00:50:42.280 --> 00:50:44.280
and then you generate the whole dump of the process.


00:50:44.280 --> 00:50:48.280
Well, those five Python applications are going to have loaded a lot of libraries that are common,


00:50:48.280 --> 00:50:52.280
like libc, OpenSSL, so a bunch of these libraries.


00:50:52.280 --> 00:50:54.280
So are you going to just include all of them?


00:50:54.280 --> 00:50:57.580
Well, technically you should, because that's what was loaded in the memory,


00:50:57.580 --> 00:51:01.080
but that's going to generate huge core files, like gigabytes in size.


00:51:01.080 --> 00:51:04.280
So a lot of the optimizations that are done is that, well,


00:51:04.280 --> 00:51:07.280
if it's a certain library, just go and read the certain library.


00:51:07.280 --> 00:51:11.360
I'm not going to include it, which means that tools need to know that this is happening.


00:51:11.360 --> 00:51:15.000
And then when they see a pointer, and they try to search in the core, they are going


00:51:15.000 --> 00:51:16.200
to find that there's nothing there.


00:51:16.200 --> 00:51:17.880
So they need to go to the library.


00:51:17.880 --> 00:51:20.460
So there's a lot of layers that you need to go.


00:51:20.460 --> 00:51:24.720
So the second part when it says works on core and files, it works on all of them, which


00:51:24.720 --> 00:51:26.600
is quite a huge statement.


00:51:26.600 --> 00:51:30.640
I guess we should touch on what platforms PyStack can run on.


00:51:30.640 --> 00:51:31.640
Just Linux.


00:51:31.640 --> 00:51:32.640
Linux, all right.


00:51:32.640 --> 00:51:35.000
Because I mean, it could work.


00:51:35.000 --> 00:51:36.240
And this is an important fact.


00:51:36.240 --> 00:51:39.200
For instance, if you're running on Windows or macOS,


00:51:39.200 --> 00:51:41.840
you probably want to use the other tools that we mentioned,


00:51:41.840 --> 00:51:43.500
like PySpy or Austin.


00:51:43.500 --> 00:51:46.080
I think both run on all platforms.


00:51:46.080 --> 00:51:51.220
But yes, this is because we want to ensure that we do this very well,


00:51:51.220 --> 00:51:52.640
and we cover all the cases,


00:51:52.640 --> 00:51:55.180
and we have enough with one operative system.


00:51:55.180 --> 00:51:57.480
Our other tools work on macOS as well.


00:51:57.480 --> 00:51:59.480
So the profiler memory works on macOS.


00:51:59.480 --> 00:52:01.620
So we don't only do tools that work on Linux,


00:52:01.620 --> 00:52:03.700
but this one only works on Linux.


00:52:03.700 --> 00:52:07.340
And to be fair, it does also work on Windows in WSL.


00:52:07.340 --> 00:52:09.180
That is my main development environment.


00:52:09.180 --> 00:52:11.500
So if not natively on Windows,


00:52:11.500 --> 00:52:14.100
but at least if you're in a virtual machine on Windows, you're fine.


00:52:14.100 --> 00:52:16.100
PyStack will work on WSL?


00:52:16.100 --> 00:52:17.100
- Yep. - Yeah, absolutely.


00:52:17.100 --> 00:52:18.780
Yeah. Okay, cool.


00:52:18.780 --> 00:52:21.100
And I suppose it works on Docker,


00:52:21.100 --> 00:52:23.060
running Linux on a bunch of machines,


00:52:23.060 --> 00:52:25.580
like on, you know, Parallels on Mac.


00:52:25.580 --> 00:52:28.260
And there's a lot of ways on the different platforms.


00:52:28.260 --> 00:52:29.700
Yeah, I develop on Docker on Mac.


00:52:29.700 --> 00:52:32.500
So for instance, I run PyStack on Docker on Mac, no problem.


00:52:32.500 --> 00:52:35.860
and even in the new ones, the M1 ones works nicely.


00:52:35.860 --> 00:52:38.580
- Cool. Includes calls to inlined functions


00:52:38.580 --> 00:52:39.700
in the native stack.


00:52:39.700 --> 00:52:41.300
- Ah, that's a funny one.


00:52:41.300 --> 00:52:43.500
So one of the things we do is that,


00:52:43.500 --> 00:52:46.060
one thing that can happen is that the C compilers,


00:52:46.060 --> 00:52:48.260
they really like to do this because it's very efficient.


00:52:48.260 --> 00:52:50.340
Sometimes following some heuristics,


00:52:50.340 --> 00:52:52.380
they can say, "Well, you're calling this function,


00:52:52.380 --> 00:52:53.940
"but this function is kind of small."


00:52:53.940 --> 00:52:57.860
So generating all the assembly code to prepare the call


00:52:57.860 --> 00:53:00.220
and finalize the call, plus all the locals


00:53:00.220 --> 00:53:02.820
and the stack and whatnot is kind of very expensive.


00:53:02.820 --> 00:53:04.900
So what they do basically is copy paste the code


00:53:04.900 --> 00:53:05.740
in the caller.


00:53:05.740 --> 00:53:07.500
So, and they set up everything so, you know,


00:53:07.500 --> 00:53:08.780
it works nicely.


00:53:08.780 --> 00:53:10.860
The locals are not overwritten just because you use


00:53:10.860 --> 00:53:12.060
the name foo in both, right?


00:53:12.060 --> 00:53:15.580
So it kind of works, but it is that instead of calling


00:53:15.580 --> 00:53:17.580
a function, you just copy paste the code.


00:53:17.580 --> 00:53:21.180
But the basically the effect that this has on the backtrace


00:53:21.180 --> 00:53:22.260
is that there is no function called.


00:53:22.260 --> 00:53:23.180
So there is no function.


00:53:23.180 --> 00:53:25.740
So when you are calling that function, it disappears.


00:53:25.740 --> 00:53:27.420
So it's like you never call it.


00:53:27.420 --> 00:53:29.180
And this can be quite confusing when you're looking


00:53:29.180 --> 00:53:33.420
stack trace because if you have function B that call the function C and C calls D


00:53:33.420 --> 00:53:37.260
and the middle one is in line, you're not going to see it and then you're going to say A calling C.


00:53:37.260 --> 00:53:40.700
And you say, well, there's no way that happens because I'm not going to see here. This can make


00:53:40.700 --> 00:53:45.420
this kind of like backtrace is very confusing. This is in C, not in Python, right? Because Python


00:53:45.420 --> 00:53:49.660
doesn't have inlining. Exactly. Python doesn't have inlining. That's true. We have something


00:53:49.660 --> 00:53:53.820
that we call inlining, but it's not the same thing. So I'm not going to explain that. Compiler


00:53:53.820 --> 00:53:57.340
optimization type of thing. Yeah. There is no inlining in Python. That's correct. Let's just


00:53:57.340 --> 00:53:58.500
let's leave it like that.


00:53:58.500 --> 00:54:01.380
And that is in C and C++ and Rust and whatnot.


00:54:01.380 --> 00:54:03.460
So if there is debugging information,


00:54:03.460 --> 00:54:05.980
we can recover these inline calls.


00:54:05.980 --> 00:54:07.540
So which is something that by the way,


00:54:07.540 --> 00:54:10.100
GDB can also do, but we can do it as well.


00:54:10.100 --> 00:54:12.220
So there is another debugging information.


00:54:12.220 --> 00:54:14.540
We actually work in some cases when GDB doesn't,


00:54:14.540 --> 00:54:16.500
just because GDB tries to be very correct


00:54:16.500 --> 00:54:17.380
in some of these cases,


00:54:17.380 --> 00:54:21.020
but for whatever reason is over correct,


00:54:21.020 --> 00:54:23.060
we can actually do it most of the time.


00:54:23.060 --> 00:54:24.420
But yes, this is a feature that,


00:54:24.420 --> 00:54:26.560
so you have one of these inline calls,


00:54:26.560 --> 00:54:30.560
And we do more than that. So for instance, if you have like extreme debug information


00:54:30.560 --> 00:54:34.360
that you can activate by passing, for instance, you compile something with GCC,


00:54:34.360 --> 00:54:38.000
you can pass -g3 as debug information level three.


00:54:38.000 --> 00:54:40.640
So put everything there. We can even show you macros.


00:54:40.640 --> 00:54:44.680
So you're using macros, and the macro expands to source basically,


00:54:44.680 --> 00:54:46.680
and then that source is passed to the compiler.


00:54:46.680 --> 00:54:50.960
So there is no macro at the compiler level, the compiler is going to see the source itself


00:54:50.960 --> 00:54:53.680
because the processor kind of expand the macro.


00:54:53.680 --> 00:54:56.000
But there is a technique in the debugging information


00:54:56.000 --> 00:54:58.180
that can include the fact that there was a macro there.


00:54:58.180 --> 00:54:59.440
So we can show you the macro.


00:54:59.440 --> 00:55:00.800
We can say this was a macro.


00:55:00.800 --> 00:55:03.000
So we can pretend that that was a function call.


00:55:03.000 --> 00:55:03.880
That's quite cool.


00:55:03.880 --> 00:55:05.600
- That's crazy, I didn't see that coming, yeah.


00:55:05.600 --> 00:55:08.200
So when are we getting inlining of functions


00:55:08.200 --> 00:55:09.960
as an optimization in Python, huh?


00:55:09.960 --> 00:55:11.400
- To be honest, there is some interesting thing


00:55:11.400 --> 00:55:12.240
that are close.


00:55:12.240 --> 00:55:14.540
There is this PEP that was approved


00:55:14.540 --> 00:55:17.720
to inline at least comprehensions in function calls.


00:55:17.720 --> 00:55:19.040
- I was about to say.


00:55:19.040 --> 00:55:20.360
- As you can see, what I said,


00:55:20.360 --> 00:55:22.680
the consequences is that you basically copy paste calls.


00:55:22.680 --> 00:55:24.480
so the function call disappears.


00:55:24.480 --> 00:55:26.360
This will happen in Python, by the way.


00:55:26.360 --> 00:55:28.360
So when the PEP is implemented,


00:55:28.360 --> 00:55:29.720
which by the way, it is implemented,


00:55:29.720 --> 00:55:30.840
if I recall correctly,


00:55:30.840 --> 00:55:32.920
what happens is that you see a backtrace


00:55:32.920 --> 00:55:34.280
with PyStack, for instance,


00:55:34.280 --> 00:55:37.280
you're now going to see the least comprehension frame,


00:55:37.280 --> 00:55:39.000
which is fine because most of the time


00:55:39.000 --> 00:55:39.960
doesn't tell you anything


00:55:39.960 --> 00:55:41.240
because you're going to tell you


00:55:41.240 --> 00:55:42.160
here's a least comprehension


00:55:42.160 --> 00:55:43.320
and then you're calling a function call


00:55:43.320 --> 00:55:44.160
least comprehension.


00:55:44.160 --> 00:55:45.520
So it's kind of like weird.


00:55:45.520 --> 00:55:48.040
But the interesting parts of least comprehensions


00:55:48.040 --> 00:55:49.720
being function calls, basically.


00:55:49.720 --> 00:55:51.480
I mean, it's not really functions call,


00:55:51.480 --> 00:55:52.760
they have their own frame.


00:55:52.760 --> 00:55:55.060
But the interesting part here, which was one big change


00:55:55.060 --> 00:55:57.440
from Python 2 to Python 3, is that variables


00:55:57.440 --> 00:55:59.980
inside the comprehensions are local to the comprehension,


00:55:59.980 --> 00:56:03.400
which means that you have a variable called x outside,


00:56:03.400 --> 00:56:05.200
and then you use a variable called x inside,


00:56:05.200 --> 00:56:08.200
and you assign to that by using the comprehension name.


00:56:08.200 --> 00:56:10.580
The one outside is not modified, right?


00:56:10.580 --> 00:56:12.920
This is maintained here, even if it's in line,


00:56:12.920 --> 00:56:15.080
because even if it's in line, that is maintained.


00:56:15.080 --> 00:56:17.720
But there is some cases when that behavior


00:56:17.720 --> 00:56:20.500
is very, very tricky, particularly class scopes.


00:56:20.500 --> 00:56:22.420
So you have a comprehension in a class scope,


00:56:22.420 --> 00:56:24.340
which already is something weird to do,


00:56:24.340 --> 00:56:25.660
but you can absolutely do it.


00:56:25.660 --> 00:56:27.740
Like class scopes are quite wild.


00:56:27.740 --> 00:56:30.140
They don't behave like function scopes.


00:56:30.140 --> 00:56:33.340
There was a bunch of edge cases that we saw.


00:56:33.340 --> 00:56:34.660
This comprehension inlining


00:56:34.660 --> 00:56:36.780
is deactivated on class scopes, for instance,


00:56:36.780 --> 00:56:39.860
just because there was some consequences of the inlining.


00:56:39.860 --> 00:56:41.940
There is some in the discussion of the PEP


00:56:41.940 --> 00:56:43.580
that is the case if you want to see it.


00:56:43.580 --> 00:56:45.180
He explained this here, it will be a bit weird,


00:56:45.180 --> 00:56:46.300
but it's quite important


00:56:46.300 --> 00:56:49.140
because inlining always has consequences.


00:56:49.140 --> 00:56:52.580
One of them is the frame is missing, but this frame is not going to be missed by anyone


00:56:52.580 --> 00:56:53.880
because it doesn't really add anything.


00:56:53.880 --> 00:56:54.740
We sort of have them.


00:56:54.740 --> 00:56:59.220
One of the things I think is really cool about asking for information here,


00:56:59.220 --> 00:57:03.780
and it's just really helpful, maybe beyond even a good log message and stuff,


00:57:03.780 --> 00:57:07.460
is not only do you see the stack trace, the call stack here,


00:57:07.460 --> 00:57:11.120
when you this line and this file called this function and so on,


00:57:11.120 --> 00:57:14.300
but you can see optionally the local variables, right?


00:57:14.300 --> 00:57:14.740
Yes.


00:57:14.740 --> 00:57:19.540
What's extremely interesting is that you would normally need to call like dunder


00:57:19.540 --> 00:57:24.180
repper method of an object in order to figure out how to print it out in a user-friendly way.


00:57:24.180 --> 00:57:28.660
But we can't do that, right? We're working on crash processes. We're reading one byte of memory


00:57:28.660 --> 00:57:34.020
at a time to try to interpret it. So in order to give you these locals, PyStack needs to be able to


00:57:34.020 --> 00:57:38.820
understand the CPython representation of a list and know how to iterate over a list manually to


00:57:38.820 --> 00:57:43.700
figure out what elements it contains and recursively get the repper for each of those


00:57:43.700 --> 00:57:46.820
method for each of those objects that are in the collection as well.


00:57:46.820 --> 00:57:50.500
It can't just rely on being able to call Python code to get you this string.


00:57:50.500 --> 00:57:54.020
Right, and manually here means that it needs to know that at least in Python,


00:57:54.020 --> 00:57:58.260
really, it's a bunch of pointers that points to a buffer, and the buffer is a bunch of PyObjects,


00:57:58.260 --> 00:58:02.340
and then every object can be different. So obviously, this means that we cannot print


00:58:02.340 --> 00:58:07.060
all objects. So if you have a custom object, we cannot print that. We will print something.


00:58:07.060 --> 00:58:09.940
We will tell you, for instance, the name of the class. We will say,


00:58:09.940 --> 00:58:12.940
We will almost act like if there is no report,


00:58:12.940 --> 00:58:15.940
so we will say custom object instance at location blah blah blah.


00:58:15.940 --> 00:58:18.940
So the default report that you will get if you create a class.


00:58:18.940 --> 00:58:22.940
But for most of the common types, dictionary sets,


00:58:22.940 --> 00:58:25.940
integer floats, etc., functions, all these things,


00:58:25.940 --> 00:58:28.940
we actually are able to print it.


00:58:28.940 --> 00:58:30.940
Again, here the idea is adding debugging,


00:58:30.940 --> 00:58:32.940
help you debug these things.


00:58:32.940 --> 00:58:34.940
So obviously it's not going to be the same as, you know,


00:58:34.940 --> 00:58:37.940
having a debugger attached to something that you can inspect.


00:58:37.940 --> 00:58:40.940
but most of the time you don't really need it


00:58:40.940 --> 00:58:43.440
because most of the time you need to know the locals


00:58:43.440 --> 00:58:45.440
is because you have a function call


00:58:45.440 --> 00:58:47.940
and the function call has a specific argument


00:58:47.940 --> 00:58:48.940
that are passed to the function


00:58:48.940 --> 00:58:50.940
and it modifies how the function behaves.


00:58:50.940 --> 00:58:52.940
For instance, imagine that it has a keyword argument


00:58:52.940 --> 00:58:54.940
and the keyword argument is strict or replaced


00:58:54.940 --> 00:58:56.940
by the unique code in code.


00:58:56.940 --> 00:58:58.940
You really want to know if you pass one or the other


00:58:58.940 --> 00:59:00.940
because otherwise it's going to trigger different call paths.


00:59:00.940 --> 00:59:04.940
So if you use this local option in PyStack,


00:59:04.940 --> 00:59:07.940
you will see what arguments were passed to the functions


00:59:07.940 --> 00:59:09.940
and also the local variables in the functions.


00:59:09.940 --> 00:59:13.940
And if most of the time it's just these built-in types,


00:59:13.940 --> 00:59:14.940
like lists or things like that,


00:59:14.940 --> 00:59:16.940
then it's going to be very useful.


00:59:16.940 --> 00:59:18.940
And it's going to be mostly enough.


00:59:18.940 --> 00:59:20.940
I think, I mean, it's kind of weird


00:59:20.940 --> 00:59:22.940
being the authors we say this


00:59:22.940 --> 00:59:24.940
because obviously we're going to say nice things,


00:59:24.940 --> 00:59:25.940
but I swear it's true.


00:59:25.940 --> 00:59:28.940
Every time I particularly myself needed this option,


00:59:28.940 --> 00:59:29.940
the things that we were printing


00:59:29.940 --> 00:59:31.940
were the things that I needed to know.


00:59:31.940 --> 00:59:33.940
So I didn't really need to know.


00:59:33.940 --> 00:59:37.580
"Well, if I have a NumPy array, I won't see the array, right?


00:59:37.580 --> 00:59:39.080
You will show me NumPy array.


00:59:39.080 --> 00:59:42.340
Well, sure, but that won't help you debug a crashing code


00:59:42.340 --> 00:59:44.580
because it doesn't really matter what is in the NumPy array."


00:59:44.580 --> 00:59:48.080
It's also fair to point out that if someone ever finds a built-in type


00:59:48.080 --> 00:59:51.280
that they needed to know the value of in order to debug a problem,


00:59:51.280 --> 00:59:53.680
they can bring it to us and we can see if we can implement it.


00:59:53.680 --> 00:59:54.940
Benefits of open source.


00:59:54.940 --> 00:59:59.140
Yeah, two thoughts sort of came up for me when I was listening to you all describe that.


00:59:59.140 --> 01:00:00.640
And this is just such a cool feature.


01:00:00.640 --> 01:00:06.720
One, if it's a class, custom object that does not have slots,


01:00:06.720 --> 01:00:10.320
you could grab just the dunderdick and kind of print it as a dict.


01:00:10.320 --> 01:00:13.800
-It'd be one, like if you... -Yes, but no.


01:00:13.800 --> 01:00:16.600
This is a very interesting question, actually, you ask.


01:00:16.600 --> 01:00:18.600
For instance, in Python 3.12,


01:00:18.600 --> 01:00:21.600
there is an optimization in which there is no dunderdick.


01:00:21.600 --> 01:00:24.080
So this is quite funny, actually.


01:00:24.080 --> 01:00:26.600
It's quite funny because what happens is that


01:00:26.600 --> 01:00:29.440
this is one of the optimizations of the FastestCPython project.


01:00:29.440 --> 01:00:32.640
This I think was done by Inada Sun and Mark Shannon.


01:00:32.640 --> 01:00:35.340
So the idea here is that if you think about it,


01:00:35.340 --> 01:00:37.980
if you have a object that has a DunderDict, right?


01:00:37.980 --> 01:00:39.220
And it has a hash table.


01:00:39.220 --> 01:00:41.040
Unless you want the dictionary itself


01:00:41.040 --> 01:00:43.320
and wants to just say, "Here is a dictionary.


01:00:43.320 --> 01:00:47.120
"I can just take a photo and put it in a poster in my room


01:00:47.120 --> 01:00:47.960
"because I like it."


01:00:47.960 --> 01:00:49.760
Unless you want the dictionary as itself--


01:00:49.760 --> 01:00:51.640
- Should we maybe take a second


01:00:51.640 --> 01:00:53.320
to explain what DunderDict is?


01:00:53.320 --> 01:00:55.800
- All right, so most objects in Python,


01:00:55.800 --> 01:00:57.920
like you have my class Animal,


01:00:57.920 --> 01:01:01.040
An animal has a bunch of attributes like name and age


01:01:01.040 --> 01:01:03.800
and like, you know, kind of animal or whatever.


01:01:03.800 --> 01:01:06.520
So in Python, those attributes are internally represented


01:01:06.520 --> 01:01:09.040
with a hash table, which in Python we call a dictionary.


01:01:09.040 --> 01:01:11.800
And you can ask the Python interpreter


01:01:11.800 --> 01:01:13.360
to show you that internal dictionary.


01:01:13.360 --> 01:01:16.480
So normally you will say my animal.name,


01:01:16.480 --> 01:01:19.160
that will print bimo, which is the name of my cat.


01:01:19.160 --> 01:01:21.440
But you can actually ask for that hash table


01:01:21.440 --> 01:01:23.400
that is internally, and for that you will need to know


01:01:23.400 --> 01:01:26.400
my animal.dander_dig, so underscore, underscore, dig,


01:01:26.400 --> 01:01:27.240
underscore, underscore.


01:01:27.240 --> 01:01:28.800
that will give you the internal hash table


01:01:28.800 --> 01:01:30.640
with the name of all the attributes that you have.


01:01:30.640 --> 01:01:34.040
So it will show name, kind, age as a strings,


01:01:34.040 --> 01:01:35.720
and they will show you the actual values.


01:01:35.720 --> 01:01:39.120
So that's normally how Python is represented internally.


01:01:39.120 --> 01:01:41.160
When you do attribute access internally


01:01:41.160 --> 01:01:43.060
it goes to this hash table in different ways


01:01:43.060 --> 01:01:44.600
and fetches this out, right?


01:01:44.600 --> 01:01:47.680
But in Python 3.12, we said, well, among other things,


01:01:47.680 --> 01:01:50.040
because this optimization touches many things,


01:01:50.040 --> 01:01:52.280
really having a hash table represented


01:01:52.280 --> 01:01:54.920
with a full dictionary is a bit expensive,


01:01:54.920 --> 01:01:56.560
because if you think about it,


01:01:56.560 --> 01:01:59.960
you access an attribute, having the full hash table


01:01:59.960 --> 01:02:01.320
is not really needed.


01:02:01.320 --> 01:02:02.720
Among other things, because the hash table


01:02:02.720 --> 01:02:05.360
has a bunch of things that allow it to work


01:02:05.360 --> 01:02:08.120
as a Python object, but you don't really enjoy those things.


01:02:08.120 --> 01:02:10.640
Like for instance, it has a pointer to the class


01:02:10.640 --> 01:02:12.000
and it tells you, I'm a dictionary,


01:02:12.000 --> 01:02:13.360
but you already know that it's a dictionary


01:02:13.360 --> 01:02:14.820
because that's what we put there.


01:02:14.820 --> 01:02:17.640
So having the whole full dictionary with reference counts


01:02:17.640 --> 01:02:19.920
and all that stuff as a normal Python object


01:02:19.920 --> 01:02:22.880
is expensive memory-wise, but also forces you


01:02:22.880 --> 01:02:24.960
to have a bunch of indirections.


01:02:24.960 --> 01:02:27.460
And we already have a bunch of optimizations here.


01:02:27.460 --> 01:02:29.460
For instance, one of the optimizations that we had


01:02:29.460 --> 01:02:32.100
is that if you have a class, let's say animal again,


01:02:32.100 --> 01:02:34.140
most of the instances of the class, if not all,


01:02:34.140 --> 01:02:35.680
are going to have the same attributes,


01:02:35.680 --> 01:02:39.140
because normally all animals, all cats have name, age,


01:02:39.140 --> 01:02:40.340
and whatever, right?


01:02:40.340 --> 01:02:42.140
You absolutely can add new attributes,


01:02:42.140 --> 01:02:44.320
so this is something that you can, but normally you don't.


01:02:44.320 --> 01:02:48.320
So what we do is that instead of storing the same names


01:02:48.320 --> 01:02:50.860
in the dictionary of every instance,


01:02:50.860 --> 01:02:52.520
we put those names in the class


01:02:52.520 --> 01:02:53.960
because they are going to be common.


01:02:53.960 --> 01:02:56.400
And then if you add kind of like extra attributes,


01:02:56.400 --> 01:02:58.580
we kind of add it to the dictionary after the fact.


01:02:58.580 --> 01:03:00.480
But there is already the diction,


01:03:00.480 --> 01:03:02.040
that dictionary is already weird.


01:03:02.040 --> 01:03:03.960
Like in the sense that sometimes the keys


01:03:03.960 --> 01:03:06.120
are outside the dictionary just because they're shared.


01:03:06.120 --> 01:03:08.720
This is the shared key dictionary optimization.


01:03:08.720 --> 01:03:10.320
So we went a step ahead


01:03:10.320 --> 01:03:12.600
and we just eliminated the dictionary.


01:03:12.600 --> 01:03:15.440
So now what we have is the internals of the hash table,


01:03:15.440 --> 01:03:16.680
like let's say row.


01:03:16.680 --> 01:03:19.960
So there is no Python object kind of wrap it around it.


01:03:19.960 --> 01:03:22.460
It's kind of like just row pointers.


01:03:22.460 --> 01:03:25.460
And if only if you ask for that DunderDig,


01:03:25.460 --> 01:03:26.460
and you want, you say,


01:03:26.460 --> 01:03:28.100
well, I don't care about your optimization,


01:03:28.100 --> 01:03:29.100
just give me the hashtag,


01:03:29.100 --> 01:03:31.900
because code that does that still needs to see the hashtag,


01:03:31.900 --> 01:03:32.780
we cannot break that.


01:03:32.780 --> 01:03:34.260
So only when you ask for the dictionary,


01:03:34.260 --> 01:03:36.660
we instantiate that dictionary,


01:03:36.660 --> 01:03:37.940
and then we give it to you.


01:03:37.940 --> 01:03:40.700
So before calling DunderDig was just getting a pointer,


01:03:40.700 --> 01:03:42.020
and that's it, here's the dictionary.


01:03:42.020 --> 01:03:44.120
Now calling DunderDig computes stuff,


01:03:44.120 --> 01:03:46.380
like it just creates a dictionary on the fly


01:03:46.380 --> 01:03:47.220
and give it to you.


01:03:47.220 --> 01:03:50.060
Which means, by the way, this is a nice piece of trivia.


01:03:50.060 --> 01:03:53.740
Before, if you want to calculate the approximate,


01:03:53.740 --> 01:03:55.300
because this is always approximate,


01:03:55.300 --> 01:03:58.620
there is no full way to say how big is my Python object


01:03:58.620 --> 01:03:59.640
and everything it contains,


01:03:59.640 --> 01:04:01.580
because Python objects are a graph,


01:04:01.580 --> 01:04:04.680
and that question, most of the time, doesn't make sense.


01:04:04.680 --> 01:04:07.260
For instance, Python objects point to their module,


01:04:07.260 --> 01:04:09.940
and you don't want to also include the module in the size,


01:04:09.940 --> 01:04:11.520
right, among other things.


01:04:11.520 --> 01:04:14.420
But if you want to know the size of custom object,


01:04:14.420 --> 01:04:16.320
you normally say size of the instance


01:04:16.320 --> 01:04:17.580
plus size of the dict.


01:04:17.580 --> 01:04:19.220
But now in Python 3.12,


01:04:19.220 --> 01:04:20.920
just by asking for the size of the dict,


01:04:20.920 --> 01:04:22.740
by doing my instance dot other dict,


01:04:22.740 --> 01:04:24.860
you just make it bigger.


01:04:24.860 --> 01:04:27.500
So the real size of the object was actually smaller


01:04:27.500 --> 01:04:28.820
than what you will get.


01:04:28.820 --> 01:04:30.940
- I think that sounds like a great optimization,


01:04:30.940 --> 01:04:32.900
but it does make your life harder here.


01:04:32.900 --> 01:04:34.540
The other thought that I had is--


01:04:34.540 --> 01:04:36.580
- Well, I mean, it's nothing really harder,


01:04:36.580 --> 01:04:38.340
among other things, because we know already


01:04:38.340 --> 01:04:40.700
how to print dictionaries, so that's fine.


01:04:40.700 --> 01:04:42.820
If it's a dictionary, we print dictionaries,


01:04:42.820 --> 01:04:43.940
and if it's not a dictionary,


01:04:43.940 --> 01:04:45.220
we are already in the business


01:04:45.220 --> 01:04:47.620
of inspecting internal structures.


01:04:47.620 --> 01:04:50.860
And we know absolutely how to interpret parts of hash tables.


01:04:50.860 --> 01:04:54.660
And at the end of the day, what we have here is parts of hash tables for now.


01:04:54.660 --> 01:04:58.620
The problem here is more about like, what happens if it changes in the future?


01:04:58.620 --> 01:05:01.700
Because right now, for instance, it's easy, but like, you know, as we optimize more and


01:05:01.700 --> 01:05:04.540
more in the next release, it's not going to be easy.


01:05:04.540 --> 01:05:08.380
And right now we can say, well, we support this, this, that, and this other thing.


01:05:08.380 --> 01:05:12.420
Which means that every time a new Python version is published, we need to just go to all those


01:05:12.420 --> 01:05:16.820
things and check if they were changed, and then change our code, which is quite a lot


01:05:16.820 --> 01:05:21.060
of work. But if we support more types, it means that we need to do things for more things.


01:05:21.060 --> 01:05:25.860
And sometimes it's harder, right? Especially custom objects, who knows what we find there.


01:05:25.860 --> 01:05:30.900
So we kind of like stay away from that because, you know, it's maybe a lot of work.


01:05:30.900 --> 01:05:35.140
You're already busy, like we established. All right. Let me just flip through here and


01:05:35.140 --> 01:05:39.140
see if there's anything else that we want to cover. I feel like that's pretty much it.


01:05:39.140 --> 01:05:43.220
Maybe just one more shout out to the pytest plugin and whatever else you'll think we should


01:05:43.220 --> 01:05:45.020
mention because we're running out of time.


01:05:45.020 --> 01:05:47.180
One last thing I think is interesting here,


01:05:47.180 --> 01:05:49.420
just to highlight, which is kind of cool,


01:05:49.420 --> 01:05:51.740
is that we, in both our tools,


01:05:51.740 --> 01:05:52.580
so PyStack and the bugger,


01:05:52.580 --> 01:05:54.220
and this kind of links into the conversation


01:05:54.220 --> 01:05:56.140
that we had before around the UX


01:05:56.140 --> 01:05:57.860
and how we put a lot of emphasis on UX


01:05:57.860 --> 01:05:59.460
and making these tools super easy.


01:05:59.460 --> 01:06:01.340
So for instance, as we mentioned before,


01:06:01.340 --> 01:06:02.860
we were talking about some of these features


01:06:02.860 --> 01:06:04.820
and then I say, for instance, the inline, right?


01:06:04.820 --> 01:06:07.220
We said, well, if you have the right information, we do this.


01:06:07.220 --> 01:06:10.120
But as I said before at the beginning of the podcast,


01:06:10.120 --> 01:06:12.300
I said, most of the things don't have the right information.


01:06:12.300 --> 01:06:13.580
So most people will say,


01:06:13.580 --> 01:06:15.740
well, what is this point of this, right?


01:06:15.740 --> 01:06:17.420
So, but then we said, okay,


01:06:17.420 --> 01:06:19.460
so we really want to make this thing easy.


01:06:19.460 --> 01:06:20.820
So we don't want to tell people,


01:06:20.820 --> 01:06:22.260
well, if you want to use this feature,


01:06:22.260 --> 01:06:23.420
then you need to install this thing


01:06:23.420 --> 01:06:25.220
and just find your distribution, how to,


01:06:25.220 --> 01:06:27.220
yada, yada, yada, it's kind of annoying, right?


01:06:27.220 --> 01:06:29.500
So one of the things we leverage in both our tools,


01:06:29.500 --> 01:06:30.620
in PyStack and Membrane,


01:06:30.620 --> 01:06:32.980
is this thing that Matt mentioned before,


01:06:32.980 --> 01:06:34.420
this debugging for the server.


01:06:34.420 --> 01:06:36.340
So this means that in most distributions,


01:06:36.340 --> 01:06:37.860
the modern distributions,


01:06:37.860 --> 01:06:39.260
so this means that the latest versions


01:06:39.260 --> 01:06:41.460
of Ubuntu, Debian, Fedora, Arc, Linux,


01:06:41.460 --> 01:06:43.540
it works on most of the new ones,


01:06:43.540 --> 01:06:46.700
there is a way that debugging tools can say,


01:06:46.700 --> 01:06:49.380
okay, I have here a binary, like let's say Python,


01:06:49.380 --> 01:06:51.200
and this binary doesn't have the right information,


01:06:51.200 --> 01:06:52.500
but I really need it.


01:06:52.500 --> 01:06:54.500
So can you give me the right information?


01:06:54.500 --> 01:06:56.700
And it will download it automatically for you,


01:06:56.700 --> 01:06:57.940
so you don't need to do anything.


01:06:57.940 --> 01:06:59.020
The tool will do it for you.


01:06:59.020 --> 01:07:01.780
So it will figure out what the right information it needs


01:07:01.780 --> 01:07:03.820
from the processes analyzing.


01:07:03.820 --> 01:07:05.340
It will go to the distribution.


01:07:05.340 --> 01:07:07.740
It will say, hey, can you give me the right information


01:07:07.740 --> 01:07:09.260
for this, this, this, and this?


01:07:09.260 --> 01:07:10.340
It will download it for you.


01:07:10.340 --> 01:07:12.420
It will automatically merge it to the binary,


01:07:12.420 --> 01:07:15.460
and it will use it for showing the inlines


01:07:15.460 --> 01:07:17.740
or the C code or whatever it is.


01:07:17.740 --> 01:07:19.340
This means that most of the time,


01:07:19.340 --> 01:07:20.700
what you will see is that the first time


01:07:20.700 --> 01:07:22.100
you analyze a Python process,


01:07:22.100 --> 01:07:23.620
it will take a bit more time


01:07:23.620 --> 01:07:25.020
just because you're downloading these files


01:07:25.020 --> 01:07:26.460
and these files can be a bit big.


01:07:26.460 --> 01:07:28.260
It will tell you that it's doing it, right?


01:07:28.260 --> 01:07:30.580
And then it will, these files then are cached


01:07:30.580 --> 01:07:31.860
for subsequent calls,


01:07:31.860 --> 01:07:33.980
so you don't download it every single time.


01:07:33.980 --> 01:07:35.680
But then it just works by magic.


01:07:35.680 --> 01:07:37.220
So you have this kind of process,


01:07:37.220 --> 01:07:39.460
and you have the information, and voila, it just works.


01:07:39.460 --> 01:07:40.300
You don't need to do anything.


01:07:40.300 --> 01:07:41.860
You don't need to know about the fact


01:07:41.860 --> 01:07:43.420
that you needed the right information


01:07:43.420 --> 01:07:45.620
or the fact that your Python is optimized


01:07:45.620 --> 01:07:48.260
and doesn't have anything, you just work, it just works.


01:07:48.260 --> 01:07:50.580
So you just need a new enough distribution.


01:07:50.580 --> 01:07:52.340
And even if you don't have a new enough distribution,


01:07:52.340 --> 01:07:53.700
there's a way to set up in the old ones.


01:07:53.700 --> 01:07:56.380
But anyway, if you're using one of the latest support


01:07:56.380 --> 01:07:59.160
to the Ubuntu, Debian, Arc, Fedora, Red Hat,


01:07:59.160 --> 01:08:02.620
all of these have it, then magically it will just work,


01:08:02.620 --> 01:08:05.500
which is something that we really, really are happy about


01:08:05.500 --> 01:08:07.180
because it means that you don't need to know


01:08:07.180 --> 01:08:09.180
about all of these things, you will just get it.


01:08:09.180 --> 01:08:11.020
- That's really fantastic and go out and grab it


01:08:11.020 --> 01:08:13.140
and just get it for you without you worrying about it.


01:08:13.140 --> 01:08:14.060
- It feels magical.


01:08:14.060 --> 01:08:16.860
Like the first time I saw it, I said, I need this.


01:08:16.860 --> 01:08:18.580
Like this is the future.


01:08:18.580 --> 01:08:19.420
Like this is the future.


01:08:19.420 --> 01:08:21.180
Because if you have to do this manually,


01:08:21.180 --> 01:08:22.500
it just makes you miserable.


01:08:22.500 --> 01:08:23.540
And I know how to do it.


01:08:23.540 --> 01:08:24.740
I know how you need to do it.


01:08:24.740 --> 01:08:26.100
And it still makes me miserable.


01:08:26.100 --> 01:08:28.140
So I don't want to do it.


01:08:28.140 --> 01:08:29.380
I just want the tool to figure it out.


01:08:29.380 --> 01:08:31.060
And this both tools do it.


01:08:31.060 --> 01:08:32.180
So that's kind of cool.


01:08:32.180 --> 01:08:33.660
- Yeah, that's fantastic.


01:08:33.660 --> 01:08:35.580
All right, you guys, I think we're out of time here,


01:08:35.580 --> 01:08:37.160
but you know, final thoughts.


01:08:37.160 --> 01:08:39.860
People are excited about PyStack.


01:08:39.860 --> 01:08:41.060
Matt, what would you tell them?


01:08:41.060 --> 01:08:42.700
– Try it out. – Check it out. How would they use it?


01:08:42.700 --> 01:08:44.300
Yeah, try it out, download it.


01:08:44.300 --> 01:08:46.360
It's as easy as pip install PyStack.


01:08:46.360 --> 01:08:48.700
Find something that isn't working the way you expect it to,


01:08:48.700 --> 01:08:50.760
point PyStack at it and see if you can figure it out.


01:08:50.760 --> 01:08:52.260
And of course, we're open to contributions.


01:08:52.260 --> 01:08:54.560
So if you find especially issues,


01:08:54.560 --> 01:08:56.460
if you find something that's broken, let us know.


01:08:56.460 --> 01:08:59.860
If you find some platform it doesn't work on, let us know.


01:08:59.860 --> 01:09:03.500
But yeah, it is my single go-to debugging tool


01:09:03.500 --> 01:09:04.760
whenever something gets stuck


01:09:04.760 --> 01:09:06.560
or doesn't do what I'm expecting it to do.


01:09:06.560 --> 01:09:08.660
When I run a Python command at a command prompt


01:09:08.660 --> 01:09:10.100
and it just doesn't return.


01:09:10.100 --> 01:09:11.500
I reach for this all the time.


01:09:11.500 --> 01:09:13.660
I'm convinced it's a very useful tool for people.


01:09:13.660 --> 01:09:14.500
- Yeah, it looks amazing.


01:09:14.500 --> 01:09:15.620
Pablo, final thoughts.


01:09:15.620 --> 01:09:17.660
- Yeah, the only thing I will add to what Matt said


01:09:17.660 --> 01:09:18.940
is that one of the things,


01:09:18.940 --> 01:09:21.340
and yeah, don't do only this thing for PyStack


01:09:21.340 --> 01:09:24.500
and our tools, do it for every tool that you use.


01:09:24.500 --> 01:09:26.740
Is that giving success a story,


01:09:26.740 --> 01:09:27.900
so when you use the tool


01:09:27.900 --> 01:09:29.740
in that particular challenging situation


01:09:29.740 --> 01:09:30.580
and it really worked,


01:09:30.580 --> 01:09:32.900
you just say, "Wow, it just works."


01:09:32.900 --> 01:09:35.140
Just go to the repo, again, not only us,


01:09:35.140 --> 01:09:38.100
but any tool that you see that actually does this,


01:09:38.100 --> 01:09:40.300
and tell the maintainers what you were trying to do


01:09:40.300 --> 01:09:41.500
and that you were really happy.


01:09:41.500 --> 01:09:44.140
Among other things, this really helps maintainers


01:09:44.140 --> 01:09:45.700
because at the end of the day, you think about it,


01:09:45.700 --> 01:09:46.860
we are putting all this work


01:09:46.860 --> 01:09:49.260
and then we just get the case that it doesn't work,


01:09:49.260 --> 01:09:50.720
so it's a bit discouraging.


01:09:50.720 --> 01:09:52.820
So it will keep us happy and that's kind of important


01:09:52.820 --> 01:09:55.100
in open source since these things are free.


01:09:55.100 --> 01:09:57.520
And the other thing is that it allows us to know


01:09:57.520 --> 01:09:58.860
how people are using the tool.


01:09:58.860 --> 01:10:00.440
So when we discuss new features


01:10:00.440 --> 01:10:03.600
and like how we evolve the tool, how to do that.


01:10:03.600 --> 01:10:04.620
So for instance, for memory,


01:10:04.620 --> 01:10:06.420
we have the success stories page


01:10:06.420 --> 01:10:08.720
where you have-- we are going to have the same as in Biostack.


01:10:08.720 --> 01:10:11.260
So if you just happen to use it and you like it


01:10:11.260 --> 01:10:13.620
or you use it successfully to fix something,


01:10:13.620 --> 01:10:16.120
just tell us. We are super happy to learn from you


01:10:16.120 --> 01:10:18.860
and to know why it was useful to you


01:10:18.860 --> 01:10:21.060
and what kind of features you used from the tool


01:10:21.060 --> 01:10:22.300
so we can keep improving.


01:10:22.300 --> 01:10:24.900
- Excellent. Yeah, I think that's a really great idea.


01:10:24.900 --> 01:10:27.000
I encourage people to do that as well.


01:10:27.000 --> 01:10:28.640
Pablo, Matt, thanks for being on the show.


01:10:28.640 --> 01:10:29.540
- Always a pleasure, Michael.


01:10:29.540 --> 01:10:30.500
- Thanks for having us. - Yeah.


01:10:30.500 --> 01:10:32.200
- All right. - Bye, guys.


01:10:32.200 --> 01:10:35.480
This has been another episode of Talk Python to Me.


01:10:35.480 --> 01:10:36.920
Thank you to our sponsors.


01:10:36.920 --> 01:10:38.280
Be sure to check out what they're offering.


01:10:38.280 --> 01:10:40.360
It really helps support the show.


01:10:40.360 --> 01:10:41.960
Take some stress out of your life.


01:10:41.960 --> 01:10:44.160
Get notified immediately about errors


01:10:44.160 --> 01:10:46.120
and performance issues in your web


01:10:46.120 --> 01:10:48.040
or mobile applications with Sentry.


01:10:48.040 --> 01:10:52.920
Just visit talkpython.fm/sentry and get started for free.


01:10:52.920 --> 01:10:54.560
And be sure to use the promo code,


01:10:54.560 --> 01:10:56.840
talkpython, all one word.


01:10:56.840 --> 01:10:58.800
Listen to an episode of Compiler,


01:10:58.800 --> 01:11:00.920
an original podcast from Red Hat.


01:11:00.920 --> 01:11:03.520
Compiler unravels industry topics, trends,


01:11:03.520 --> 01:11:05.960
and things you've always wanted to know about tech


01:11:05.960 --> 01:11:08.400
through interviews with the people who know it best.


01:11:08.400 --> 01:11:12.800
Subscribe today by following talkpython.fm/compiler.


01:11:12.800 --> 01:11:14.120
Want to level up your Python?


01:11:14.120 --> 01:11:15.880
We have one of the largest catalogs


01:11:15.880 --> 01:11:18.240
of Python video courses over at Talk Python.


01:11:18.240 --> 01:11:20.280
Our content ranges from true beginners


01:11:20.280 --> 01:11:23.280
to deeply advanced topics like memory and async.


01:11:23.280 --> 01:11:25.940
And best of all, there's not a subscription in sight.


01:11:25.940 --> 01:11:28.960
Check it out for yourself at training.talkpython.fm.


01:11:28.960 --> 01:11:30.600
Be sure to subscribe to the show,


01:11:30.600 --> 01:11:33.600
Open your favorite podcast app and search for Python.


01:11:33.600 --> 01:11:34.960
We should be right at the top.


01:11:34.960 --> 01:11:37.840
You can also find the iTunes feed at /itunes,


01:11:37.840 --> 01:11:40.040
the Google Play feed at /play,


01:11:40.040 --> 01:11:44.040
and the Direct RSS feed at /rss on talkpython.fm.


01:11:44.040 --> 01:11:47.560
We're live streaming most of our recordings these days.


01:11:47.560 --> 01:11:48.720
If you want to be part of the show


01:11:48.720 --> 01:11:51.000
and have your comments featured on the air,


01:11:51.000 --> 01:11:52.840
be sure to subscribe to our YouTube channel


01:11:52.840 --> 01:11:55.840
at talkpython.fm/youtube.


01:11:55.840 --> 01:11:57.260
This is your host, Michael Kennedy.


01:11:57.260 --> 01:11:58.440
Thanks so much for listening.


01:11:58.440 --> 01:11:59.660
I really appreciate it.


01:11:59.660 --> 01:12:01.660
Now get out there and write some Python code.


01:12:01.660 --> 01:12:05.020
[MUSIC PLAYING]


01:12:05.020 --> 01:12:19.020
[Music]


01:12:19.020 --> 01:12:21.600
(upbeat music)


01:12:21.600 --> 01:12:31.600
[BLANK_AUDIO]

