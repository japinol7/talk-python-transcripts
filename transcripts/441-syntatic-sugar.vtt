WEBVTT

00:00:00.240 --> 00:00:02.800
You've probably heard the term syntactic sugar.


00:00:02.800 --> 00:00:06.640
That is syntax within a programming language that is designed to make


00:00:06.640 --> 00:00:08.920
things easier to read or to express.


00:00:08.920 --> 00:00:12.000
It makes the language sweeter for humans to use.


00:00:12.000 --> 00:00:17.100
It turns out Brett Cannon has spent two years diving into and writing about


00:00:17.100 --> 00:00:22.320
Python's sweet language features and how they really work down inside CPython.


00:00:22.320 --> 00:00:25.400
He joins me on the show today to dive into a few of the more


00:00:25.400 --> 00:00:27.020
relevant posts he's written about.


00:00:27.580 --> 00:00:32.860
This is Talk Python to Me, episode 441, recorded November 1st, 2023.


00:00:32.860 --> 00:00:50.460
Welcome to Talk Python to Me, a weekly podcast on Python.


00:00:50.460 --> 00:00:52.140
This is your host, Michael Kennedy.


00:00:52.140 --> 00:00:55.260
Follow me on Mastodon, where I'm @mkennedy and follow the


00:00:55.260 --> 00:00:57.140
podcast using @talkpython.


00:00:57.380 --> 00:00:59.540
Both on mastodon.org.


00:00:59.540 --> 00:01:02.580
Keep up with the show and listen to over seven years of past


00:01:02.580 --> 00:01:04.620
episodes at talkpython.fm.


00:01:04.620 --> 00:01:08.420
We've started streaming most of our episodes live on YouTube.


00:01:08.420 --> 00:01:13.180
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified


00:01:13.180 --> 00:01:15.980
about upcoming shows and be part of that episode.


00:01:15.980 --> 00:01:21.420
This episode is sponsored by us over at Talk Python Training.


00:01:21.420 --> 00:01:26.140
Did you know that we have over 250 hours of Python courses?


00:01:26.140 --> 00:01:27.160
Yeah, that's right.


00:01:27.160 --> 00:01:29.860
Check them out at talkpython.fm/courses.


00:01:29.860 --> 00:01:34.660
Brett, welcome back to Talk Python to Me.


00:01:34.660 --> 00:01:35.780
You've been here a time or two.


00:01:35.780 --> 00:01:37.180
Always great to have you here.


00:01:37.180 --> 00:01:38.940
Well, thanks for having me yet again, Michael.


00:01:38.940 --> 00:01:40.900
I'm glad I've not worn out my welcome quite yet.


00:01:40.900 --> 00:01:43.700
You always have so much cool stuff going on and so many


00:01:43.700 --> 00:01:45.060
interesting perspectives.


00:01:45.060 --> 00:01:45.640
So.


00:01:45.640 --> 00:01:49.180
Some would call them interesting, whether that's a positive or negative


00:01:49.180 --> 00:01:51.140
is still open to interpretation.


00:01:51.140 --> 00:01:55.220
May you program in interesting times as the old ancient proverb goes.


00:01:56.500 --> 00:01:59.200
So been here a bunch of times, but real quick, just tell people about


00:01:59.200 --> 00:02:01.320
bit about yourself before we jump in.


00:02:01.320 --> 00:02:02.920
Just in case they haven't, they don't know you.


00:02:02.920 --> 00:02:03.280
Yeah.


00:02:03.280 --> 00:02:04.880
Uh, name's Brett Cannon.


00:02:04.880 --> 00:02:08.760
I live in Vancouver on the unceded territories of the Squamish, Tsleil-Waututh


00:02:08.760 --> 00:02:10.400
and West Green First Nations.


00:02:10.400 --> 00:02:14.880
I am currently the dev manager for the Python extension in VS Code.


00:02:14.880 --> 00:02:20.960
I am serving my fifth and as of now final term on the Python steering council.


00:02:20.960 --> 00:02:24.440
I'm stepping down just because when we first created the steering council, I


00:02:24.440 --> 00:02:27.500
said five years seemed like a good term limit, we actually don't have term


00:02:27.500 --> 00:02:29.300
limits, but figured I'd stick to my word.


00:02:29.300 --> 00:02:32.940
And I'm also the social core developer.


00:02:32.940 --> 00:02:35.140
I've been doing it for just over 20 years.


00:02:35.140 --> 00:02:39.060
Lucky for me, I got it my first commit bit right after the, sorry, my first


00:02:39.060 --> 00:02:40.700
commit bit after the first PyCon.


00:02:40.700 --> 00:02:43.660
So I get to use the PyCon anniversaries as a way to keep track of that.


00:02:43.660 --> 00:02:44.420
So that's convenient.


00:02:44.420 --> 00:02:46.260
That's kind of the biggies.


00:02:46.260 --> 00:02:46.940
I have a cat.


00:02:46.940 --> 00:02:47.260
Yeah.


00:02:47.260 --> 00:02:48.420
And that's usually the other thing people like.


00:02:48.420 --> 00:02:49.660
Something about VS Code.


00:02:49.660 --> 00:02:50.540
I've heard that word.


00:02:50.540 --> 00:02:51.380
It's an editor, right?


00:02:51.380 --> 00:02:52.060
Yeah, I know.


00:02:52.060 --> 00:02:55.420
Someday you'll say you use it and I'll be very happy that day.


00:02:55.420 --> 00:02:57.100
I had it open today.


00:02:57.100 --> 00:02:57.880
Oh, all right.


00:02:57.880 --> 00:02:59.200
Well, there I'm happy today then.


00:02:59.200 --> 00:03:00.040
Yes, indeed.


00:03:00.040 --> 00:03:01.280
No, awesome.


00:03:01.280 --> 00:03:03.080
So many cool things you got going on.


00:03:03.080 --> 00:03:10.120
And despite all of that background in steering council core dev here, this


00:03:10.120 --> 00:03:14.520
time you're here to give us like diet advice, eating advice, like something


00:03:14.520 --> 00:03:15.920
about sugar, what is it?


00:03:15.920 --> 00:03:16.680
Yeah.


00:03:16.680 --> 00:03:18.360
Just like story behind all this.


00:03:18.940 --> 00:03:23.500
My wife was taking the certificate in data science course at the university of


00:03:23.500 --> 00:03:26.620
British Columbia, which is actually our Alma mater and where we met.


00:03:26.620 --> 00:03:33.940
And she was doing her homework in a JupyterLab notebook through the browser


00:03:33.940 --> 00:03:38.260
via JupyterHub and she stopped doing the homework to go, I can't remember if it


00:03:38.260 --> 00:03:40.520
was lunch or dinner, but basically stepped away for like an hour or so.


00:03:40.520 --> 00:03:44.500
And then she came back and the run buttons on the cells weren't working anymore.


00:03:44.500 --> 00:03:45.700
I was like, well, what's going on?


00:03:45.700 --> 00:03:48.780
And I looked and it's like, oh, well you got disconnected from the server.


00:03:48.780 --> 00:03:51.220
And she said, well, isn't that happening in the browser?


00:03:51.220 --> 00:03:54.140
Like, no, Python doesn't run in the browser right now.


00:03:54.140 --> 00:03:55.140
It's not a, it's not a thing.


00:03:55.140 --> 00:03:56.020
Oh, okay.


00:03:56.020 --> 00:04:00.380
And then I think about a day or two later after she thought about it, we were in the


00:04:00.380 --> 00:04:04.060
car and I still remember the exact location in Vancouver where this occurred.


00:04:04.060 --> 00:04:07.320
My wife said, you know, you should probably fix that problem of


00:04:07.320 --> 00:04:08.540
Python not working in the browser.


00:04:08.540 --> 00:04:12.300
And I explained like what WebAssembly was and how big of a thing that would be


00:04:12.300 --> 00:04:13.680
to make that all happen and all that.


00:04:13.680 --> 00:04:17.940
And she literally took about a beat to wait and said, no, you should go fix that.


00:04:18.580 --> 00:04:23.340
Part of that led me down the road of trying to figure out what the minimum


00:04:23.340 --> 00:04:24.940
viable Python was, right?


00:04:24.940 --> 00:04:28.820
Like what is the minimal amount of Python I would have to implement in the browser


00:04:28.820 --> 00:04:32.420
or in, or in WebAssembly in this case to make Python work.


00:04:32.420 --> 00:04:36.580
And I had realized that, you know, a decent amount of Python is actually


00:04:36.580 --> 00:04:40.500
what's called syntactic sugar, which is really just syntax that you could


00:04:40.500 --> 00:04:45.500
actually devolve and unravel into other syntax of a language and have


00:04:45.500 --> 00:04:47.100
it do the exact same thing.


00:04:47.100 --> 00:04:47.460
Right.


00:04:47.460 --> 00:04:49.780
It's just basically syntax as a shortcut.


00:04:49.780 --> 00:04:55.620
And so I ended up going on this very long journey unexpectedly long of


00:04:55.620 --> 00:04:58.900
trying to go through all of Python syntax and trying to figure out which parts of


00:04:58.900 --> 00:05:03.620
the syntax was like crucial and you couldn't actually re implement it in pure


00:05:03.620 --> 00:05:08.380
Python itself and which parts you could actually just make it work with Python


00:05:08.380 --> 00:05:12.340
code itself with the idea that at the end it would have basically a list of the bits


00:05:12.340 --> 00:05:16.840
of Python that an interpreter would have to implement and the other bits of syntax


00:05:16.840 --> 00:05:20.080
where you could run some tool over it ahead of time, it would just translate


00:05:20.080 --> 00:05:21.700
from Python to different Python code.


00:05:21.700 --> 00:05:25.140
And then that way I would just know what the exact target of would have to be.


00:05:25.140 --> 00:05:26.560
Might not run very fast.


00:05:26.560 --> 00:05:31.420
Don't get me wrong, but it would at least be very clear definition of kind of what


00:05:31.420 --> 00:05:33.900
you have to have to really call something Python.


00:05:33.900 --> 00:05:36.220
It's everything else you have to just work around.


00:05:36.220 --> 00:05:36.580
Right.


00:05:36.580 --> 00:05:36.740
Yeah.


00:05:36.740 --> 00:05:41.820
So the standard Python syntax we expect still works, but how much do you have to


00:05:41.820 --> 00:05:43.140
work behind the scenes to make that happen?


00:05:43.140 --> 00:05:47.720
So examples that come to mind for me are context managers, the width block.


00:05:47.720 --> 00:05:48.400
Awesome.


00:05:48.400 --> 00:05:53.360
I love them, but we have try finally, and you could simulate a context manager


00:05:53.360 --> 00:05:58.200
effectively with maybe a try finally, maybe an accepts in there as well, but


00:05:58.200 --> 00:06:02.700
you don't actually need with in the language to accomplish what it does.


00:06:02.700 --> 00:06:02.960
Right?


00:06:02.960 --> 00:06:03.260
Yeah.


00:06:03.260 --> 00:06:05.400
Decorators are also another really good example, right?


00:06:05.400 --> 00:06:09.640
Like where the concepts for that syntax predates it.


00:06:09.840 --> 00:06:15.180
And it happened to just be something where Python core development team looked at


00:06:15.180 --> 00:06:19.380
where people were in terms of development and what they needed from Python and


00:06:19.380 --> 00:06:23.740
realize, you know what, that common pattern that people are doing would actually be,


00:06:23.740 --> 00:06:27.060
but would be very well served via piece of syntax.


00:06:27.060 --> 00:06:28.140
So why don't we just do that?


00:06:28.140 --> 00:06:30.620
Why don't we introduce that piece of syntax, make these steps.


00:06:30.620 --> 00:06:33.940
And as you said, with context managers were a perfect example, right?


00:06:33.940 --> 00:06:38.620
Where before, if you wanted to do the right thing, when you opened a file, is


00:06:38.620 --> 00:06:43.220
you call, call the open function for your file, assign it to a variable, do your


00:06:43.220 --> 00:06:46.180
try block of everything you want to do with the file.


00:06:46.180 --> 00:06:50.820
And then in the finally part of the try finally close that file, which I mean, if


00:06:50.820 --> 00:06:55.580
you just think about it compared to a with statement is four lines, assuming


00:06:55.580 --> 00:06:59.820
you're doing reasonable formatting for the assignment, the try, the finally,


00:06:59.820 --> 00:07:04.020
then the close call versus the single with open to get the exact same effect.


00:07:04.020 --> 00:07:07.620
And then you've also got the possibility that the context manager, the thing


00:07:07.620 --> 00:07:11.020
that's used in the with block can do something different if there's an


00:07:11.020 --> 00:07:12.180
exception, right?


00:07:12.180 --> 00:07:15.020
Like if there's an exception, it could say, if it's a database transaction, it


00:07:15.020 --> 00:07:17.140
could roll back the transaction automatically.


00:07:17.140 --> 00:07:19.620
Rather, if there's no exception, it could commit it automatically.


00:07:19.620 --> 00:07:21.060
But there's no real magic there.


00:07:21.060 --> 00:07:23.740
If you think about it in the end, you could have written that all up by hand.


00:07:23.740 --> 00:07:27.260
It just would have been cumbersome, but that makes the with statement very much a


00:07:27.260 --> 00:07:31.160
piece of syntactic sugar, where you could totally read it out, get the exact same


00:07:31.160 --> 00:07:32.100
semantic outcome.


00:07:32.100 --> 00:07:33.580
It might be a little slower.


00:07:33.580 --> 00:07:35.580
Probably similar performance as well.


00:07:35.580 --> 00:07:37.500
And maybe, yeah, similar.


00:07:37.580 --> 00:07:39.020
It really depends on the syntax, right?


00:07:39.020 --> 00:07:43.180
Like how complicated it is, how much of it's going to call into, at least in C


00:07:43.180 --> 00:07:47.180
Python's case, into the C code and stay in the C code versus not like with


00:07:47.180 --> 00:07:50.820
context managers probably won't just because the point is you're going to call


00:07:50.820 --> 00:07:53.380
that dunder enter method or that dunder exit method.


00:07:53.380 --> 00:07:54.580
So you're calling Python code.


00:07:54.580 --> 00:07:56.540
So no real, probably big shift.


00:07:56.540 --> 00:08:00.660
But for stuff that we'll probably cover in this podcast, there are other bits that


00:08:00.660 --> 00:08:03.020
go into the C code and stay in the C code.


00:08:03.020 --> 00:08:05.500
And when that happens, stuff can go really, really fast.


00:08:05.540 --> 00:08:08.700
Yeah, especially with all the work, the faster CPython teams done around stuff


00:08:08.700 --> 00:08:09.300
and all that.


00:08:09.300 --> 00:08:13.740
So the point is you can just start to just kind of leap into C code, stay there and


00:08:13.740 --> 00:08:14.900
get stuff done way faster.


00:08:14.900 --> 00:08:18.700
Comparative to writing out by hand where you're staying in the Python world, it


00:08:18.700 --> 00:08:19.660
can just take a bit longer.


00:08:19.660 --> 00:08:19.980
Yeah.


00:08:19.980 --> 00:08:23.220
So the word sugar, I think it's a good one here.


00:08:23.220 --> 00:08:27.380
I love like these ideas, like code smells, code sugar, all the things.


00:08:27.380 --> 00:08:32.940
It makes it sound a little frivolous, maybe like little, ah, it's, it's nice to


00:08:32.940 --> 00:08:34.020
have it sweetens it up.


00:08:34.020 --> 00:08:34.660
They don't really need it.


00:08:34.980 --> 00:08:38.900
But I do think having these different constructs, like when you see a with


00:08:38.900 --> 00:08:41.700
block, it instantly conveys meaning.


00:08:41.700 --> 00:08:43.260
It means we're going to create a thing.


00:08:43.260 --> 00:08:44.580
We have a cleanup section.


00:08:44.580 --> 00:08:45.660
We don't have to deal with it.


00:08:45.660 --> 00:08:50.060
As opposed to if you see a try, except finally you have to read it and process


00:08:50.060 --> 00:08:53.260
it and see, okay, does it actually do the things that would be accomplished?


00:08:53.260 --> 00:08:58.180
I think these, these sugars let you also think not just write less code, but think


00:08:58.180 --> 00:09:00.180
in different levels of abstraction.


00:09:00.180 --> 00:09:00.700
Yeah.


00:09:00.700 --> 00:09:04.780
I mean, as you said, the use of the word sugar is meant to mean something


00:09:04.780 --> 00:09:05.580
sweet, something nice.


00:09:05.580 --> 00:09:06.420
It's a treat.


00:09:06.420 --> 00:09:07.340
It's a bonus.


00:09:07.340 --> 00:09:11.740
So from the perspective of if you didn't have it, you could still accomplish it.


00:09:11.740 --> 00:09:16.620
But that can potentially in a way, as you, as you've suggested, not quite


00:09:16.620 --> 00:09:19.140
denote the benefit of it, right?


00:09:19.140 --> 00:09:23.020
Like if we think of sugar in terms of not something good for your diet.


00:09:23.020 --> 00:09:23.220
Yeah.


00:09:23.220 --> 00:09:24.980
What, what is your perspective on sugar?


00:09:24.980 --> 00:09:25.140
Right.


00:09:25.140 --> 00:09:27.340
Are you a fan of desserts or are you trying to cut it out?


00:09:27.340 --> 00:09:27.620
Yeah.


00:09:27.700 --> 00:09:32.420
But yeah, I mean, the hope is whenever we add syntax to Python, it's


00:09:32.420 --> 00:09:34.060
for everyone's general benefit, right?


00:09:34.060 --> 00:09:35.620
This is why we don't do it very often.


00:09:35.620 --> 00:09:39.020
And we do, when we do do it, it's a very thoughtful discussion, very long


00:09:39.020 --> 00:09:41.740
discussion, sometimes contentious discussion.


00:09:41.740 --> 00:09:45.020
Walrus operator is the famous one for that.


00:09:45.020 --> 00:09:47.180
I don't understand the contention, the Walrus operator.


00:09:47.180 --> 00:09:50.660
It's such a small change to the language.


00:09:50.660 --> 00:09:52.980
There's so many other things that are bigger changes that could have been


00:09:52.980 --> 00:09:56.260
battles, but I guess it just came to a head at that point or something.


00:09:56.260 --> 00:09:56.580
Right.


00:09:56.620 --> 00:09:59.060
For those of you who don't know the Walrus operators, the thing that


00:09:59.060 --> 00:10:02.380
pushed Guido kind of over the edge to finally step down as being


00:10:02.380 --> 00:10:04.020
the bit of a dictator for life.


00:10:04.020 --> 00:10:08.980
And it was just due to the veracity of the opposition to it and just


00:10:08.980 --> 00:10:11.740
how basically angry it made people.


00:10:11.740 --> 00:10:13.180
And you're right.


00:10:13.180 --> 00:10:13.900
It's very small.


00:10:13.900 --> 00:10:16.420
And to be honest, I've used it and I like it.


00:10:16.420 --> 00:10:17.260
I get use out of it.


00:10:17.260 --> 00:10:21.860
It means it, I use it for its purpose, which was to add some basic syntax


00:10:21.860 --> 00:10:25.300
for those, those situations where you always have that assignment and then


00:10:25.300 --> 00:10:29.420
you do something like an F or something, and then you're going to do something


00:10:29.420 --> 00:10:32.180
that was like, just be able to inline certain things to just do the right thing.


00:10:32.180 --> 00:10:35.220
It's not a huge thing, but it's a nice thing.


00:10:35.220 --> 00:10:39.500
And in that case, I don't know, honestly, a lot of people got really


00:10:39.500 --> 00:10:45.100
concerned that they didn't see the usefulness enough that they thought it


00:10:45.100 --> 00:10:49.380
was going to be a slippery slope or people are always very concerned about


00:10:49.380 --> 00:10:53.340
Python getting too big and that's no longer fitting in their brain.


00:10:53.340 --> 00:10:53.660
Yeah.


00:10:53.740 --> 00:10:57.020
Maybe it was kind of the last straw sort of thing, rather than like, maybe


00:10:57.020 --> 00:10:58.940
stuff came before and they're like, all right, that's it either.


00:10:58.940 --> 00:11:02.300
And now the walrus, the walrus, like, you know, I don't know.


00:11:02.300 --> 00:11:03.300
I don't know.


00:11:03.300 --> 00:11:06.140
I mean, I don't think people realize that we actually cut syntax out when we


00:11:06.140 --> 00:11:07.940
moved from Python two to Python three.


00:11:07.940 --> 00:11:08.340
Yeah.


00:11:08.340 --> 00:11:09.660
That was all kind of brewing.


00:11:09.660 --> 00:11:09.860
Yeah.


00:11:09.860 --> 00:11:11.140
Like the back ticks went away.


00:11:11.140 --> 00:11:14.260
Like no one knows about the back ticks anymore, but we still have syntax for


00:11:14.260 --> 00:11:18.700
using back ticks and that's now that's gone now, so it's not like it's always


00:11:18.700 --> 00:11:22.100
been a add, add, add, but I think it's just one of these things where it's just


00:11:22.100 --> 00:11:25.180
people were very concerned that Python would get too big, too complicated, and


00:11:25.180 --> 00:11:27.060
it wouldn't be fully understandable.


00:11:27.060 --> 00:11:31.620
I will say, whenever we do this, we very much consider how easy it would be to


00:11:31.620 --> 00:11:35.220
understand if you saw it for the first time and never received any instruction


00:11:35.220 --> 00:11:35.780
about it, right?


00:11:35.780 --> 00:11:39.500
Like I would argue that walrus operator is a bit obvious if you look at the code


00:11:39.500 --> 00:11:41.300
around it of what it does.


00:11:41.300 --> 00:11:45.380
And so you can probably figure out what it does without being told ahead of time


00:11:45.380 --> 00:11:48.740
versus other syntax and other languages where you go, I have no clue what this


00:11:48.740 --> 00:11:49.020
does.


00:11:49.020 --> 00:11:49.660
Right.


00:11:49.660 --> 00:11:50.260
Exactly.


00:11:50.260 --> 00:11:50.500
Right.


00:11:50.500 --> 00:11:55.580
Like why does plus plus and C do different things if it's in the front or the


00:11:55.580 --> 00:11:56.780
back and what's the difference?


00:11:56.780 --> 00:12:01.060
Like, unless you know, prefix versus suffix increment and the difference in


00:12:01.060 --> 00:12:04.980
terms of referencing the pointer and all this crazy stuff, like you're not going


00:12:04.980 --> 00:12:07.580
to say pick up on the difference unless you run your code versus something where


00:12:07.580 --> 00:12:09.900
you can just look at it and just learn on the spot.


00:12:09.900 --> 00:12:14.620
Well, I want to give you all a bit of a compliment, I guess, or encouragement.


00:12:14.620 --> 00:12:17.980
I think the Python language is not changing too fast.


00:12:18.020 --> 00:12:21.140
I think it's the stability over time is really good.


00:12:21.140 --> 00:12:23.060
You compare that to other languages.


00:12:23.060 --> 00:12:26.740
I mean, here's one that's kind of close to home for you since you're at Microsoft,


00:12:26.740 --> 00:12:27.380
like C#.


00:12:27.380 --> 00:12:30.500
I feel like that language, pretty nice, at least in the early days.


00:12:30.500 --> 00:12:33.940
And now it's, there's a whole team who are employed.


00:12:33.940 --> 00:12:35.140
You don't have to make any comment.


00:12:35.140 --> 00:12:39.100
I know you work there, but there's a whole team who's employed to, to like


00:12:39.100 --> 00:12:41.100
shepherd that language.


00:12:41.100 --> 00:12:44.580
And I feel like there's a feeling they always need to have some new language


00:12:44.580 --> 00:12:47.700
features because it's their job to have language features.


00:12:47.980 --> 00:12:51.460
There's just like a constant kind of turn, like for properties, like we have


00:12:51.460 --> 00:12:54.540
properties, they have properties, but I think there's four to five different ways


00:12:54.540 --> 00:12:57.260
that properties in C# that have evolved over time.


00:12:57.260 --> 00:13:00.420
And you're just like, yeah, it's a little better, but it's why do we have so many


00:13:00.420 --> 00:13:02.020
ways if you're going to be that right.


00:13:02.020 --> 00:13:07.660
And so when I at least look at Python compared to like my background in C plus


00:13:07.660 --> 00:13:11.580
plus or in C# or JavaScript, I feel like it's comfortable.


00:13:11.580 --> 00:13:15.500
It's not stale, but it's not, we don't have five ways to do properties.


00:13:16.900 --> 00:13:17.740
That's a good thing.


00:13:17.740 --> 00:13:21.380
Even if there's a better way to do it, it might not be worth having two to three


00:13:21.380 --> 00:13:23.700
ways just for that, for a slight advantage.


00:13:23.700 --> 00:13:24.980
Well, thank you for the kind words.


00:13:24.980 --> 00:13:25.380
Yeah.


00:13:25.380 --> 00:13:29.900
I mean, we do have the Zen of Python does kind of outline the general guidelines we


00:13:29.900 --> 00:13:33.540
try to follow when doing, making these discussions decisions for those who've


00:13:33.540 --> 00:13:37.060
never read the Zen of Python, look, just run, import this from the rep bowl and


00:13:37.060 --> 00:13:38.180
you'll, you'll find it.


00:13:38.180 --> 00:13:40.700
And yeah, it's just the way it's designed, right?


00:13:40.700 --> 00:13:45.260
We don't, hopefully there's one in hopefully only one obvious way to do


00:13:45.260 --> 00:13:48.980
anything, and so it's just something we've kind of leaned into now, granted


00:13:48.980 --> 00:13:53.140
things shift, like I'm sure someone will point out the myriad of ways you can


00:13:53.140 --> 00:13:56.340
format a string now, but a lot of that's backwards compatibility and just


00:13:56.340 --> 00:13:59.580
realizing, you know what, we just have to accept the fact that the first way we


00:13:59.580 --> 00:14:02.820
got it is no longer the best way we can think of.


00:14:02.820 --> 00:14:06.620
And it's enough of a jump from using string interpolation with the percent


00:14:06.620 --> 00:14:11.340
sign to using f-strings that it was worth adding a second way.


00:14:11.340 --> 00:14:14.420
Now maybe someday we'll take out string interpolation.


00:14:14.420 --> 00:14:17.540
I doubt it because it just works and it's just sitting there and it's not


00:14:17.540 --> 00:14:21.460
worth breaking really old code, but I mean, it's just the way we approach


00:14:21.460 --> 00:14:22.780
things and luckily most people like it.


00:14:22.780 --> 00:14:24.860
And I think that's kind of why some people always freak out is.


00:14:24.860 --> 00:14:28.700
The words are afraid somehow we're going to go downhill from here and it's just


00:14:28.700 --> 00:14:31.500
the start of things or somehow Python is going to be harder to learn.


00:14:31.500 --> 00:14:35.180
Well, we very much try to make sure Python is a gradual curve of learning,


00:14:35.180 --> 00:14:35.380
right?


00:14:35.380 --> 00:14:35.540
Yeah.


00:14:35.540 --> 00:14:37.540
The basics are very straightforward and good.


00:14:37.540 --> 00:14:40.380
And as you get into more advanced things like the match statement, right?


00:14:40.380 --> 00:14:43.420
Like you'll be able to see it and understand it and it'll make sense, but


00:14:43.620 --> 00:14:46.980
not something you'll necessarily learn the first month or two, but it's there


00:14:46.980 --> 00:14:48.020
for when you do need it, right?


00:14:48.020 --> 00:14:52.860
Like we very much try to make sure that everything makes sense on a curve for


00:14:52.860 --> 00:14:56.140
from beginner to advanced and try to make sure the language is useful to everyone


00:14:56.140 --> 00:14:57.860
from both a beginner to advanced user.


00:14:57.860 --> 00:15:00.380
It's tricky, but like to think we're doing a decent job.


00:15:00.380 --> 00:15:01.060
Yeah.


00:15:01.060 --> 00:15:05.580
One of Python's really, one of its powers is that you can be super effective with


00:15:05.580 --> 00:15:08.740
it, with a really partial understanding of what it is, right?


00:15:08.740 --> 00:15:12.460
You don't have to understand namespaces, classes, async, et cetera, et cetera.


00:15:12.460 --> 00:15:15.460
You just like, well, I think I can write these four lines in a, without even a


00:15:15.460 --> 00:15:18.660
function and I'll get a cool graph that'll show my, my work or whatever.


00:15:18.660 --> 00:15:18.780
Right.


00:15:18.780 --> 00:15:19.020
Yep.


00:15:19.020 --> 00:15:19.620
Exactly.


00:15:19.620 --> 00:15:19.860
Yep.


00:15:19.860 --> 00:15:23.020
And I think I have a pretty partial understanding of the match statement.


00:15:23.020 --> 00:15:27.340
I know it can get pretty advanced in like how it captures and changes values, but I


00:15:27.340 --> 00:15:29.380
wrote one yesterday with a partial understanding.


00:15:29.380 --> 00:15:29.820
It went great.


00:15:29.820 --> 00:15:30.180
Nice.


00:15:30.180 --> 00:15:31.020
Yeah, indeed.


00:15:31.020 --> 00:15:31.660
All right.


00:15:31.660 --> 00:15:37.180
Before we move on though, got to go back to the, the, your opening, because you said,


00:15:37.180 --> 00:15:41.980
I created this to understand, like if I were to solve that problem, you know, I


00:15:41.980 --> 00:15:44.860
had about like, you got to fix that thing about the browser.


00:15:44.860 --> 00:15:48.020
And I know there's some folks in Texas who have thoughts on this as well


00:15:48.020 --> 00:15:53.420
and the PyScript team, but is this project you're actively working on or just,


00:15:53.420 --> 00:15:58.500
uh, let me gather up, do some research and deep thinking about what is actually


00:15:58.500 --> 00:16:01.700
in the language that would have to carry over or where's this coming from, I guess.


00:16:01.700 --> 00:16:04.580
No, it's not an active project of mine at the moment.


00:16:04.580 --> 00:16:10.140
It ended up being mostly just an exercise and just snowballed into a thing where I


00:16:10.140 --> 00:16:11.780
just didn't want to stop until I completed it.


00:16:11.820 --> 00:16:12.140
Yeah.


00:16:12.140 --> 00:16:18.140
How do you feel about the, the MicroPython PyScript angle of approaching this?


00:16:18.140 --> 00:16:18.580
Yeah.


00:16:18.580 --> 00:16:21.980
I mean, I think it's great that, I mean, that was the other hopeful benefit of all


00:16:21.980 --> 00:16:26.700
of this is trying to nail down the definition of what Python is.


00:16:26.700 --> 00:16:27.020
Yeah.


00:16:27.020 --> 00:16:31.380
Cause I've heard those arguments made against MicroPython that it's not quite


00:16:31.380 --> 00:16:34.620
Python cause it doesn't quite run all the syntax or it doesn't have the


00:16:34.620 --> 00:16:36.020
entire standard library.


00:16:36.020 --> 00:16:40.740
I've gotten into arguments with people online where they got very upset when I


00:16:40.740 --> 00:16:44.140
suggested that the REPL was an optional part of Python and actually not a


00:16:44.140 --> 00:16:45.020
requirement.


00:16:45.020 --> 00:16:49.820
And I just viewed it as a learning experience for me, hopefully a learning


00:16:49.820 --> 00:16:51.100
experience for others as well.


00:16:51.100 --> 00:16:55.420
And then after that was just trying to hopefully clarify like, like, look, this


00:16:55.420 --> 00:16:57.620
is truly what you have to have to really beat Python.


00:16:57.620 --> 00:17:00.980
You literally cannot implement the rest of the language without this, but


00:17:00.980 --> 00:17:02.780
everything else, you could totally just do it yourself.


00:17:02.780 --> 00:17:05.140
You could totally just write your tool and make it all work.


00:17:05.140 --> 00:17:08.100
And as long as this existed, you could totally get a buy with it.


00:17:08.100 --> 00:17:10.220
And so that's kind of where I ended up.


00:17:10.260 --> 00:17:14.540
I luckily the tooling around WebAssembly got far enough along.


00:17:14.540 --> 00:17:16.500
Pyodites continue to do well in the browser.


00:17:16.500 --> 00:17:20.380
I've been working on the WebAssembly, the system interface, Wazzy side of


00:17:20.380 --> 00:17:22.300
things, and that's been going pretty well.


00:17:22.300 --> 00:17:24.980
So that's at least taking care of itself.


00:17:24.980 --> 00:17:31.020
So I've ultimately not tackled the huge problem of trying to re-implement Python


00:17:31.020 --> 00:17:35.580
from scratch, probably in Rust, just in a minimal fashion to try to make it work


00:17:35.580 --> 00:17:36.380
better in the browser.


00:17:36.620 --> 00:17:39.020
That's probably a project for when I retire.


00:17:39.020 --> 00:17:42.260
And I suspect that's at least a decade out, if not more.


00:17:42.260 --> 00:17:44.900
So that's probably going to be put on the back burner for a while.


00:17:44.900 --> 00:17:45.260
Right.


00:17:45.260 --> 00:17:45.540
Yeah.


00:17:45.540 --> 00:17:49.260
We can all install B Python and run Brett Python built in Rust.


00:17:49.260 --> 00:17:49.820
There you go.


00:17:49.820 --> 00:17:57.300
It, Rust does seem to be having quite the influence, an outsized influence for how


00:17:57.300 --> 00:18:01.540
popular Rust is in terms of the number of developers, but it seems to be really


00:18:01.540 --> 00:18:05.340
leaving its mark on Python and other areas as well these days.


00:18:05.340 --> 00:18:05.620
So.


00:18:05.620 --> 00:18:06.140
Yeah.


00:18:06.140 --> 00:18:11.140
Well, I mean, I will fully admit I have bias cause I am a fan and I do like using


00:18:11.140 --> 00:18:14.300
the language, but it's one of those things where if you've been living in the


00:18:14.300 --> 00:18:18.020
CNC++ world and it never was that satisfying to you, but you had to be there


00:18:18.020 --> 00:18:22.660
for whatever reason, and then you discover Rust and it does things that saves you


00:18:22.660 --> 00:18:24.740
from very chronic set of problems.


00:18:24.740 --> 00:18:25.020
Yeah.


00:18:25.020 --> 00:18:25.860
Including yourself.


00:18:25.860 --> 00:18:26.300
Yeah.


00:18:26.300 --> 00:18:29.780
You would hope that you, people would notice and latch onto it.


00:18:29.780 --> 00:18:32.340
And I mean, I think that's basically what's happened is people have just


00:18:32.340 --> 00:18:37.820
discovered that, oh yeah, this is useful and good and just there's enough CNC++


00:18:37.820 --> 00:18:42.340
code in the Python community due to CPython C API that it, I think they're


00:18:42.340 --> 00:18:44.140
just a nice cross-section, right?


00:18:44.140 --> 00:18:46.860
I think it's just one of these things where people have just gone like, well,


00:18:46.860 --> 00:18:50.100
I've got to be, I got to do the system level programming anyway, so I might as


00:18:50.100 --> 00:18:53.140
well use something that's seems like a better, more modern language.


00:18:53.140 --> 00:18:53.340
Yeah.


00:18:53.340 --> 00:18:53.500
Yeah.


00:18:53.500 --> 00:18:53.740
Yeah.


00:18:53.740 --> 00:18:54.180
Yeah.


00:18:54.180 --> 00:18:54.740
More modern.


00:18:54.740 --> 00:18:56.740
And so I think that's kind of what's happened here.


00:18:56.740 --> 00:18:56.940
Yeah.


00:18:56.940 --> 00:18:57.500
That makes sense.


00:18:57.500 --> 00:18:58.060
All right.


00:18:58.060 --> 00:18:59.460
Let's talk about the sugar.


00:18:59.460 --> 00:18:59.780
Okay.


00:18:59.820 --> 00:19:02.820
So I think we covered pretty much what syntactic sugar is.


00:19:02.820 --> 00:19:06.660
And you started this whole thing out saying the goal of this is really to


00:19:06.660 --> 00:19:09.580
kind of nail down that minimum Python.


00:19:09.580 --> 00:19:11.540
And I agree that the REPL is optional.


00:19:11.540 --> 00:19:16.340
I like the REPL, but just, just so I can also get mail about it.


00:19:16.340 --> 00:19:17.900
I like the language.


00:19:17.900 --> 00:19:21.060
Like you can't take away these features once you add them.


00:19:21.060 --> 00:19:21.300
Right.


00:19:21.300 --> 00:19:25.500
And so it's like, what could you survive with as a minimum?


00:19:25.500 --> 00:19:28.380
And then you can kind of like, what are the, what's the extras?


00:19:28.380 --> 00:19:29.700
What could you build up from there?


00:19:29.740 --> 00:19:30.620
Yes, exactly.


00:19:30.620 --> 00:19:34.420
And the final destination may be being, you know, CPython proper.


00:19:34.420 --> 00:19:34.900
Yeah.


00:19:34.900 --> 00:19:40.580
So you've got a whole bunch of different aspects of Python that you are


00:19:40.580 --> 00:19:43.020
unraveling in this syntactic sugar.


00:19:43.020 --> 00:19:46.660
And basically to highlight what's actually happening, how much of this is,


00:19:46.660 --> 00:19:48.460
is going on as you've already laid out.


00:19:48.460 --> 00:19:53.100
So I want to point out that I'll link to how many articles you've got here, but


00:19:53.100 --> 00:19:55.100
two years, like 20, I think.


00:19:55.100 --> 00:19:55.580
Yeah.


00:19:55.580 --> 00:19:57.820
Like looking like close to 30, maybe.


00:19:57.820 --> 00:19:58.100
I don't know.


00:19:58.100 --> 00:19:59.100
Just eyeball on it.


00:19:59.100 --> 00:19:59.860
There's a lot there.


00:19:59.860 --> 00:20:04.660
So I think I've picked us, you know, half of those hours, some, some reasonable


00:20:04.660 --> 00:20:08.140
subset that we can talk about and there's some code and stuff in here.


00:20:08.140 --> 00:20:12.100
So we'll kind of have like, my thought was we could just talk about kind of


00:20:12.100 --> 00:20:13.500
like, what is the essence of this?


00:20:13.500 --> 00:20:16.660
Like what's really happening when you do attribute access, what's really


00:20:16.660 --> 00:20:21.140
happening when you write the word pass or use a, a with block and we've


00:20:21.140 --> 00:20:22.300
talked about a little bit.


00:20:22.300 --> 00:20:26.620
So the first one here is unraveling attribute access in Python.


00:20:26.900 --> 00:20:30.220
You want to tell us a bit about what actually happens if you just say, you


00:20:30.220 --> 00:20:35.380
know, like object dot attribute, it seems so simple, Brett, there's just one dot.


00:20:35.380 --> 00:20:36.380
What's the big deal?


00:20:36.380 --> 00:20:36.740
Yeah.


00:20:36.740 --> 00:20:38.740
Why doesn't this just, what's there to talk about?


00:20:38.740 --> 00:20:43.180
I mean, when I just do something dot something magically, I get back what I


00:20:43.180 --> 00:20:46.580
expected, but there's actually a lot going on there, right.


00:20:46.580 --> 00:20:50.380
And it, it comes down to multiple layers, but it's all ties around


00:20:50.380 --> 00:20:51.740
Python's object model, right?


00:20:51.740 --> 00:20:56.740
How do all, cause I always find this weird to say, but Python's more object


00:20:56.740 --> 00:20:58.580
oriented, my opinion in Java, right?


00:20:58.580 --> 00:21:03.060
Java has these primitive types, like in quotes that have to get boxed and


00:21:03.060 --> 00:21:06.900
unboxed to fake to make them look like an object to Java itself.


00:21:06.900 --> 00:21:07.940
Python doesn't have that.


00:21:07.940 --> 00:21:08.980
Everything is an object.


00:21:08.980 --> 00:21:11.260
A function is an object in integers and object like


00:21:11.260 --> 00:21:12.220
true is an object.


00:21:12.220 --> 00:21:13.460
Seven is an object.


00:21:13.460 --> 00:21:14.260
Exactly.


00:21:14.260 --> 00:21:16.180
There's nothing you can name in Python.


00:21:16.180 --> 00:21:17.580
That's not somehow an object.


00:21:17.580 --> 00:21:21.260
This idea of attributes and all this permeates all the way down into the


00:21:21.260 --> 00:21:24.820
object model, which once again, defines kind of everything in a way.


00:21:24.940 --> 00:21:27.540
So the key thing here is there's kind of two parts to it.


00:21:27.540 --> 00:21:30.660
It's how do you look up based on inheritance?


00:21:30.660 --> 00:21:36.300
What thing is going to service the call asking what is this attribute value?


00:21:36.300 --> 00:21:39.740
Basically what object is bound to this name for the attribute.


00:21:39.740 --> 00:21:43.580
And after that is what methods are going to get called to make that happen?


00:21:43.580 --> 00:21:47.780
Cause effectively almost everything in Python at the end of the day leads to


00:21:47.780 --> 00:21:49.500
a method call or a function call.


00:21:49.500 --> 00:21:49.740
Yeah.


00:21:49.740 --> 00:21:53.540
First of all, it leads to a lot of times to an op code, which


00:21:53.540 --> 00:21:54.900
leads to a method call, right?


00:21:55.100 --> 00:21:57.060
A Python byte code thing.


00:21:57.060 --> 00:22:01.500
And I think it's maybe also worth pointing out, like have you point out to everyone


00:22:01.500 --> 00:22:06.780
listening is Python compiles to this intermediate language like Java and .NET


00:22:06.780 --> 00:22:08.300
compiled to intermediate languages.


00:22:08.300 --> 00:22:11.220
It's just what happens then, right?


00:22:11.220 --> 00:22:14.100
Like in those other ones, they, they jet compile to machine instructions.


00:22:14.100 --> 00:22:17.340
Here it goes through like the big C eval loop and delegates


00:22:17.340 --> 00:22:19.180
to some internal C operations.


00:22:19.180 --> 00:22:22.140
And a lot of those, these unravelings, like kind of look at what


00:22:22.140 --> 00:22:23.500
happens at that step, right?


00:22:23.500 --> 00:22:24.100
Yeah.


00:22:24.100 --> 00:22:27.620
So CPython itself is an interpreter, right?


00:22:27.620 --> 00:22:32.220
So what happens is when you load up your Python code is Python parses it.


00:22:32.220 --> 00:22:34.940
What's called an abstract syntax tree or AST.


00:22:34.940 --> 00:22:38.620
It then takes that AST does some stuff with it, and then it


00:22:38.620 --> 00:22:41.260
compiles it down to Python byte code.


00:22:41.260 --> 00:22:45.820
I actually gave a talk on this at PyCon Canada way back when, for those who are


00:22:45.820 --> 00:22:49.980
interested, that basically goes from the steps of literally source code all the


00:22:49.980 --> 00:22:53.900
way to execution if you want more detail, but effectively, yeah, we


00:22:53.900 --> 00:22:59.540
compile it down to byte code of our own design to then execute in more or less


00:22:59.540 --> 00:23:01.780
what's a big for loop in C.


00:23:01.780 --> 00:23:03.060
That is a really big for loop.


00:23:03.060 --> 00:23:03.900
Very big for loop.


00:23:03.900 --> 00:23:08.020
And it's gotten a bit fancier thanks to the faster CPython team, right?


00:23:08.020 --> 00:23:12.540
Like there's now kind of like lower level op codes that are very type specific,


00:23:12.540 --> 00:23:16.860
and we actually auto-generate the loop now thanks to them so that it's easier


00:23:16.860 --> 00:23:18.780
to maintain and make tweaks to.


00:23:18.780 --> 00:23:22.300
But essentially it's literally just a set of instructions that are extreme,


00:23:22.340 --> 00:23:27.300
that kind of encompass key bits of semantics in Python.


00:23:27.300 --> 00:23:32.980
So for instance, for attribute access, there's literally a op code called


00:23:32.980 --> 00:23:37.060
load adder where on the execution stack, you basically push the object you care


00:23:37.060 --> 00:23:40.700
about, the name of the thing you want, and then you just call load adder on it


00:23:40.700 --> 00:23:42.740
and it'll just look it up.


00:23:42.740 --> 00:23:44.740
Actually, technically, I guess it doesn't push the name on it.


00:23:44.740 --> 00:23:47.060
That's technically stored in the function.


00:23:47.060 --> 00:23:51.180
There's little details on kind of hand waving over, literally hand waving.


00:23:51.180 --> 00:23:54.980
If you're watching the live stream, but effectively you push the object you


00:23:54.980 --> 00:23:58.620
want, you call load adder, give it an argument of what it should, what attribute


00:23:58.620 --> 00:24:01.740
it wants, and then load adder op code behind the scenes is the thing that does


00:24:01.740 --> 00:24:04.140
all the magic of calling everything you'd expect, et cetera, et cetera.


00:24:04.140 --> 00:24:04.460
Yeah.


00:24:04.460 --> 00:24:05.100
Excellent.


00:24:05.100 --> 00:24:10.300
And to view that a lot of times what you'll do is you'll just use the dis module.


00:24:10.300 --> 00:24:15.260
So people haven't used dis, you can just dis.dis, a lot of disrespect on this


00:24:15.260 --> 00:24:18.620
function, and then it tells you, it tells you what the op codes are that it's made


00:24:18.620 --> 00:24:19.140
of, or yeah.


00:24:19.140 --> 00:24:19.780
Yeah, exactly.


00:24:19.780 --> 00:24:21.700
It'll, I mean, dis is short for disassemble.


00:24:21.700 --> 00:24:25.180
So literally you, you can pass it a function and it will effectively


00:24:25.180 --> 00:24:29.900
disassemble what the function does into the byte code, which is just sort of as


00:24:29.900 --> 00:24:35.300
an attribute of bytes on the function object and print it out nicely because


00:24:35.300 --> 00:24:39.700
it, the dis module knows how to map the bytes to what the op code's name is and


00:24:39.700 --> 00:24:42.820
just gives it a nice way to look at and actually read and understand it.


00:24:42.820 --> 00:24:43.020
Yeah.


00:24:43.020 --> 00:24:43.540
Okay.


00:24:43.540 --> 00:24:47.940
And this example, you said, I look, here's the case statement in that tremendous


00:24:48.180 --> 00:24:51.620
for loop switch thing that does the execution.


00:24:51.620 --> 00:24:53.580
What do we do if we slow C load adder?


00:24:53.580 --> 00:24:58.420
And ultimately it comes down to this high object underscore get adder.


00:24:58.420 --> 00:25:00.260
So it seems so simple.


00:25:00.260 --> 00:25:03.020
You just object dot attribute object dot field, whatever.


00:25:03.020 --> 00:25:07.020
But it turns out there's just so many variations and so much going on down


00:25:07.020 --> 00:25:10.460
here, and I don't necessarily want you to go through all the details cause it's


00:25:10.460 --> 00:25:14.820
pretty, some of it's pretty intense C and like a lot of it, you know, optimizations


00:25:14.820 --> 00:25:19.060
and stuff, but like just give people a sense of what actually happens down, down


00:25:19.060 --> 00:25:21.620
in the guts when you try to do that.


00:25:21.620 --> 00:25:26.620
Well, so the, so in the case of attribute access, right, that it effectively ends


00:25:26.620 --> 00:25:29.300
up calling the guilt get adder built-in function.


00:25:29.300 --> 00:25:29.980
Right.


00:25:29.980 --> 00:25:34.740
And in that case, it needs to check how many arguments it gets to start, right?


00:25:34.740 --> 00:25:37.060
Did you give it two arguments or did you give it three arguments?


00:25:37.060 --> 00:25:40.820
So you return a default value if the attribute doesn't exist.


00:25:40.820 --> 00:25:44.420
And then at the C level, we have to check whether or not what you gave it, right?


00:25:44.420 --> 00:25:49.220
Because there's like a Python level, the C code, all types to what's called the


00:25:49.220 --> 00:25:53.900
two PI object, which is basically a massive struct in C that represents


00:25:53.900 --> 00:25:55.780
any and all Python objects.


00:25:55.780 --> 00:26:02.020
So even at the C level, we don't know if you gave us a string or an integer or


00:26:02.020 --> 00:26:05.820
what did you give us for the name of the attribute that you want?


00:26:05.820 --> 00:26:07.140
So we got to do that.


00:26:07.140 --> 00:26:07.700
Right.


00:26:07.700 --> 00:26:12.740
And so there's just basic, like just safety checks to go like, Nope.


00:26:12.900 --> 00:26:17.340
Like when you, if you call get adder with you wanting the attribute 42, which is a


00:26:17.340 --> 00:26:19.100
number, it's going to throw a type error.


00:26:19.100 --> 00:26:22.700
Well, that code's got to exist somewhere and this is where it exists.


00:26:22.700 --> 00:26:23.460
Yeah.


00:26:23.460 --> 00:26:23.740
Yeah.


00:26:23.740 --> 00:26:24.060
Right.


00:26:24.060 --> 00:26:28.500
And then effectively just bubbles all down to the C API where a lot of this stuff gets


00:26:28.500 --> 00:26:29.580
exposed in its own way.


00:26:29.580 --> 00:26:33.220
And specifically in this case, it ends up calling PI objects, get adder.


00:26:33.220 --> 00:26:33.500
Yeah.


00:26:33.500 --> 00:26:37.620
And I think another thing that's pretty interesting here is it's not always just a


00:26:37.620 --> 00:26:38.460
value, right?


00:26:38.460 --> 00:26:41.380
That object dot adder, that adder could be a property.


00:26:41.660 --> 00:26:46.180
That adder could be a descriptor, which I guess is a generalization of a property.


00:26:46.180 --> 00:26:49.180
It could be on the class type, but not on the instance type.


00:26:49.180 --> 00:26:52.740
So you got to find that it could be on the instant type overriding, but only there.


00:26:52.740 --> 00:26:52.980
Right.


00:26:52.980 --> 00:26:54.380
Like it could not exist.


00:26:54.380 --> 00:26:57.300
All of these scenarios that you got to go through.


00:26:57.300 --> 00:27:01.420
And so it really, you know, it really emphasizes how much is actually going on


00:27:01.420 --> 00:27:05.740
in the runtime while this single simple line seems to be running.


00:27:05.740 --> 00:27:06.020
Right.


00:27:06.020 --> 00:27:06.540
Yeah.


00:27:06.540 --> 00:27:11.140
I mean, in the simple case, hitting the dots, not complicated, like in


00:27:11.140 --> 00:27:15.460
general, what you end up doing is you have your object, you hit dot.


00:27:15.460 --> 00:27:19.500
And what it does is it looks in the Dunder decked attribute of the object.


00:27:19.500 --> 00:27:22.860
And there's a key matching that to rename and just gets the thing in the


00:27:22.860 --> 00:27:23.820
dictionary and that's it.


00:27:23.820 --> 00:27:24.140
You're done.


00:27:24.140 --> 00:27:29.100
But as you alluded to, how the heck do you even get to that basic case or, or


00:27:29.100 --> 00:27:32.220
those more complicated cases, as you said, descriptors, right.


00:27:32.220 --> 00:27:37.380
Which are how we actually implement properties or if it's on the class


00:27:37.380 --> 00:27:43.180
versus the instance and if there's inheritance or multiple, multiple


00:27:43.180 --> 00:27:45.900
inheritance or Dunder get at, or was defined, right?


00:27:45.900 --> 00:27:50.100
Like basically almost all of this ends up flowing through the get outer built


00:27:50.100 --> 00:27:53.620
in, which effectively ends up calling the appropriate Dunder get attribute


00:27:53.620 --> 00:27:55.260
method off of an object.


00:27:55.260 --> 00:27:58.740
And that this is one of those barrier level kind of things, right?


00:27:58.740 --> 00:28:01.500
Where you have to implement this to make Python work.


00:28:01.500 --> 00:28:03.900
You have to basically implement the, the get outer built in.


00:28:03.900 --> 00:28:06.900
And it has to understand how objects are structured underneath the hood


00:28:07.100 --> 00:28:10.940
to know how basically methods and stuff are attached to an object.


00:28:10.940 --> 00:28:12.340
You really can't fake that.


00:28:12.340 --> 00:28:16.420
There's no way to not kind of have that as a low level detail


00:28:16.420 --> 00:28:17.900
that you can just unravel.


00:28:17.900 --> 00:28:19.500
It has to be implemented by the interpreter.


00:28:19.500 --> 00:28:24.700
And in this case, effectively the way Python does things is it knows the order.


00:28:24.700 --> 00:28:27.860
You can always actually call the MRO method on any object in order to


00:28:27.860 --> 00:28:29.740
return you the method resolution order.


00:28:29.740 --> 00:28:34.780
And effectively what Python is doing is if it checks on something to see if it


00:28:34.780 --> 00:28:38.500
has it or not, it will effectively end up calling the Dunder get attribute


00:28:38.500 --> 00:28:41.220
object of method, sorry, on object.


00:28:41.220 --> 00:28:42.740
That's usually where it bottoms out.


00:28:42.740 --> 00:28:46.700
And unless you happen to have a Dunder get outer, if that fails, but


00:28:46.700 --> 00:28:50.140
that's only the failure case, but really in the end, almost everything


00:28:50.140 --> 00:28:52.740
passes through object dot Dunder get attribute.


00:28:52.740 --> 00:28:54.500
And that's really where all this ends up going.


00:28:54.500 --> 00:28:56.700
But as you said, there's a lot of little twists and turns.


00:28:56.700 --> 00:28:56.980
Yeah.


00:28:56.980 --> 00:29:01.860
A lot of these internals, you'll, you'll see the method resolution order calls


00:29:01.860 --> 00:29:05.380
and it's all about, well, there's a lot of classes and a lot of objects.


00:29:05.380 --> 00:29:08.380
They can override things and they can override operators.


00:29:08.380 --> 00:29:11.620
And so it's, there's a lot of navigation to just figure it out.


00:29:11.620 --> 00:29:16.780
Not just calling these get outer type of things, but what level does that


00:29:16.780 --> 00:29:20.140
even supposed to happen on given what I'm working with, right?


00:29:20.140 --> 00:29:21.220
Yeah, exactly.


00:29:21.220 --> 00:29:23.860
And I think this is a good example.


00:29:23.860 --> 00:29:26.860
And the reason I started with is it's so fundamental, right?


00:29:26.860 --> 00:29:30.060
Like how do you unravel something if you don't know how to even


00:29:30.060 --> 00:29:31.300
get an attribute off of something?


00:29:31.300 --> 00:29:33.660
So this is why this was the very first post in this series.


00:29:33.660 --> 00:29:37.820
And partly why I went into such detail on how to figure all this out, right?


00:29:37.820 --> 00:29:40.500
Like kind of one, this is almost a template for anyone else who


00:29:40.500 --> 00:29:41.860
wanted to go exploring on their own.


00:29:41.860 --> 00:29:45.100
But I think it's also a good example of how much complexity and


00:29:45.100 --> 00:29:51.020
flexibility Python hides from users in order to make the simple work, but


00:29:51.020 --> 00:29:53.940
give you the flexibility to make the complicated possible, right?


00:29:53.940 --> 00:29:54.140
Yeah.


00:29:54.140 --> 00:29:59.380
Like for the vast majority of any of us for our code, it's not just as what


00:29:59.380 --> 00:30:00.260
you would think it would do.


00:30:00.260 --> 00:30:01.220
And it's pretty straightforward.


00:30:01.420 --> 00:30:05.380
But as soon as you get into the fancy world of descriptors or


00:30:05.380 --> 00:30:06.620
dendrogrammable attributes.


00:30:06.620 --> 00:30:07.140
Yeah, SQLAlchemy.


00:30:07.140 --> 00:30:10.700
I can both have a value or I can do a database query with the same thing.


00:30:10.700 --> 00:30:11.500
How is that possible?


00:30:11.500 --> 00:30:11.820
Right?


00:30:11.820 --> 00:30:12.220
Yeah.


00:30:12.220 --> 00:30:13.340
You want that magic?


00:30:13.340 --> 00:30:14.860
Language has to support it somehow.


00:30:14.860 --> 00:30:20.020
And it requires a lot of finesse and thinking through and a lot of


00:30:20.020 --> 00:30:23.780
mechanisms that generally get hidden from you, but someone's got to


00:30:23.780 --> 00:30:24.820
write that code somewhere.


00:30:24.820 --> 00:30:30.260
And in this case, it's CPython and this kind of outlines how that all happens.


00:30:30.460 --> 00:30:32.460
And it's surprisingly complicated.


00:30:32.460 --> 00:30:33.820
It's not horrible.


00:30:33.820 --> 00:30:35.500
That was my main takeaway too.


00:30:35.500 --> 00:30:36.100
Yeah.


00:30:36.100 --> 00:30:37.620
I mean, you can totally read it and follow it.


00:30:37.620 --> 00:30:39.580
I don't want to scare anyone saying it's so complex.


00:30:39.580 --> 00:30:40.260
You can't follow it.


00:30:40.260 --> 00:30:45.180
It's just, it's not just a simple like two if statements and you're done.


00:30:45.180 --> 00:30:49.620
It's no, there's subtlety to it to make sure the common, the common


00:30:49.620 --> 00:30:51.540
semantics makes sense to people.


00:30:51.540 --> 00:30:54.500
It's not going to trip people up because it's doing something weird.


00:30:54.500 --> 00:30:57.060
There's a lot of thought that goes into these semantics to make sure it


00:30:57.060 --> 00:30:59.180
makes sense for the common case.


00:31:00.180 --> 00:31:03.140
This portion of talk Python to me is brought to you by us.


00:31:03.140 --> 00:31:07.420
Have you heard that Python is not good for concurrent programming problems?


00:31:07.420 --> 00:31:11.260
Whoever told you that is living in the past because it's prime time


00:31:11.260 --> 00:31:13.060
for Python's asynchronous features.


00:31:13.060 --> 00:31:17.020
With the widespread adoption of async methods and the async and await


00:31:17.020 --> 00:31:21.140
keywords, Python's ecosystem has a ton of new and exciting frameworks


00:31:21.140 --> 00:31:22.740
based on async and await.


00:31:22.740 --> 00:31:26.060
That's why we created a course for anyone who wants to learn all


00:31:26.060 --> 00:31:27.860
of Python's async capabilities.


00:31:28.220 --> 00:31:30.260
Async techniques and examples in Python.


00:31:30.260 --> 00:31:34.940
Just visit talkpython.fm/async and watch the intro video to


00:31:34.940 --> 00:31:36.060
see if this course is for you.


00:31:36.060 --> 00:31:38.660
It's only $49 and you own it forever.


00:31:38.660 --> 00:31:39.700
No subscriptions.


00:31:39.700 --> 00:31:42.340
And there are discounts for teams as well.


00:31:42.340 --> 00:31:47.260
Another takeaway I got from looking at this is wow.


00:31:47.260 --> 00:31:50.700
It's nice that dictionaries are fast and how fast are they to make this


00:31:50.700 --> 00:31:53.700
possible to lean on them so, so much to make this happen.


00:31:53.700 --> 00:31:54.020
Yeah.


00:31:54.020 --> 00:31:57.660
I mean, I will say when Guido chose to use dictionaries as the name of


00:31:57.660 --> 00:32:01.500
dictionaries as the namespace, it was kind of a unique decision at the time.


00:32:01.500 --> 00:32:07.180
It might still be, honestly, but it did simplify some things conceptually


00:32:07.180 --> 00:32:13.780
and also made it so that any wins in how dictionaries work is just a massive


00:32:13.780 --> 00:32:15.140
win universally across the language.


00:32:15.140 --> 00:32:15.500
Right?


00:32:15.500 --> 00:32:20.820
Like if you make dictionaries work in any way better, you not only make it


00:32:20.820 --> 00:32:24.740
work when you just, you personally use it as a data structure, as a container,


00:32:24.940 --> 00:32:28.140
but also literally every attribute access will get faster.


00:32:28.140 --> 00:32:28.660
Right?


00:32:28.660 --> 00:32:33.100
Like there's a reason why it's so fine tuned and why we don't really touch it


00:32:33.100 --> 00:32:37.740
very much because it's been tweaked over the decades by a lot of people to be


00:32:37.740 --> 00:32:41.020
extremely fast and for good reason.


00:32:41.020 --> 00:32:41.300
Yep.


00:32:41.300 --> 00:32:41.900
Indeed.


00:32:41.900 --> 00:32:46.460
One final thought on this, you know, you think of optimizing both the memory and


00:32:46.460 --> 00:32:49.900
also the performance a little bit by doing things like slots on your classes


00:32:49.900 --> 00:32:51.500
to maybe like short circuit some of this.


00:32:51.940 --> 00:32:55.820
It feels like somewhere in this world lives like some kind of massive


00:32:55.820 --> 00:32:59.780
optimization that maybe that if you said I'm going to, for this class, I'm


00:32:59.780 --> 00:33:01.380
going to give up some flexibility.


00:33:01.380 --> 00:33:05.100
Is there some way attribute reads and writes could get lots faster?


00:33:05.100 --> 00:33:05.700
I don't know.


00:33:05.700 --> 00:33:09.460
What are you, I'm sure this has gone around and around because it's such a hot,


00:33:09.460 --> 00:33:13.260
it's just involved in almost every line of Python code and stuff like this.


00:33:13.260 --> 00:33:13.580
Right?


00:33:13.580 --> 00:33:14.140
Oh yeah.


00:33:14.140 --> 00:33:18.620
I mean, and this plays into what the faster CPython team has been doing, right?


00:33:18.620 --> 00:33:23.540
Like, how do you make things faster by looking at what the patterns are?


00:33:23.540 --> 00:33:26.020
And if you can just kind of skip stuff, right?


00:33:26.020 --> 00:33:27.740
Like how do you short circuit this thing?


00:33:27.740 --> 00:33:30.900
Can you go like, well, I just know this objects always look this way.


00:33:30.900 --> 00:33:35.100
Like this was some of the stuff that the self programming language team at UC


00:33:35.100 --> 00:33:40.260
Santa Barbara did, I think in the seventies, maybe eighties of just like, well, if we


00:33:40.260 --> 00:33:43.060
know the layout of the object is going to be consistent.


00:33:43.060 --> 00:33:43.420
Yeah.


00:33:43.420 --> 00:33:45.780
Can we go seven bytes in and get four bytes?


00:33:45.780 --> 00:33:46.900
That kind of thing, right?


00:33:46.900 --> 00:33:47.700
Exactly.


00:33:47.860 --> 00:33:52.100
And you start to be able to calculate their shortcuts, you know, like, Hey, did


00:33:52.100 --> 00:33:54.900
anything change from the last time I made this assumption?


00:33:54.900 --> 00:33:55.180
No.


00:33:55.180 --> 00:33:55.460
Okay.


00:33:55.460 --> 00:33:56.660
Well then I can use my assumption.


00:33:56.660 --> 00:33:57.460
That's way fast.


00:33:57.460 --> 00:33:57.940
Right.


00:33:57.940 --> 00:33:59.100
Nobody's mocked it.


00:33:59.100 --> 00:34:01.020
Nobody's dynamically messed with it.


00:34:01.020 --> 00:34:05.980
Like maybe it is just a plain thing until somebody puts it into an edge case.


00:34:05.980 --> 00:34:07.060
Is there a short circuit?


00:34:07.060 --> 00:34:07.540
Right.


00:34:07.540 --> 00:34:08.020
Yeah.


00:34:08.020 --> 00:34:11.820
And I mean, I don't want to go off on a tangent, but.


00:34:11.820 --> 00:34:14.580
Well, I'm one of 17 topics here, Brett.


00:34:14.580 --> 00:34:15.220
Like, no problem.


00:34:15.220 --> 00:34:15.940
We got lots of time.


00:34:16.020 --> 00:34:21.140
I have thought about like, after doing this, what is there something


00:34:21.140 --> 00:34:22.660
syntactic here to add, right?


00:34:22.660 --> 00:34:28.500
Is there a way to kind of come up with a effectively a class definition?


00:34:28.500 --> 00:34:33.100
That's way simpler for the really common cases that could be optimized


00:34:33.100 --> 00:34:39.820
extremely fast because you give away some flexibility and then the


00:34:39.820 --> 00:34:41.300
interpreter can make assumptions.


00:34:41.300 --> 00:34:44.620
Pypy can make assumptions, et cetera, et cetera.


00:34:44.620 --> 00:34:48.300
And would there be enough wins on that to warrant doing it right?


00:34:48.300 --> 00:34:53.020
Like, could we take the concept of kind of a data class that was just data


00:34:53.020 --> 00:34:57.340
roughly or something along those lines and just what could we get out of it?


00:34:57.340 --> 00:34:59.780
And what kind of perf wins could we get out of it?


00:34:59.780 --> 00:35:00.620
And would it be worth it?


00:35:00.620 --> 00:35:04.220
Would it be worth adding syntax to the language for that case?


00:35:04.220 --> 00:35:09.020
If you look at Mojo, for instance, they have a struct and that struct works in a


00:35:09.020 --> 00:35:13.060
very specific way for performance, because when you say like this thing can't have


00:35:13.060 --> 00:35:15.820
new attributes, which you can do with slots.


00:35:15.820 --> 00:35:18.540
And for those of you who don't know what slots are, if you define a


00:35:18.540 --> 00:35:21.740
thunder slots attribute on your class, you're effectively telling Python,


00:35:21.740 --> 00:35:23.300
don't create a dictionary for me.


00:35:23.300 --> 00:35:27.260
Just create effectively a list underneath it's technically a C array.


00:35:27.260 --> 00:35:31.460
And when I need to access something, just get it off this array.


00:35:31.460 --> 00:35:32.540
So there's no dictionary.


00:35:32.540 --> 00:35:34.500
You can skip all that dictionary overhead.


00:35:34.500 --> 00:35:38.060
Plus you shrink the memory because now only amount of memory you need is that


00:35:38.060 --> 00:35:43.380
array for pointers to the PI objects and not a dictionary, which grows and shrinks.


00:35:43.380 --> 00:35:44.980
And who knows what size is going to be.


00:35:44.980 --> 00:35:49.060
If we had that built in syntactically, would that be beneficial to people or not?


00:35:49.060 --> 00:35:53.420
And I have a prototype in Python code of what I'm thinking of.


00:35:53.420 --> 00:35:57.740
I did a blog post on this earlier this year to try to feel out people in the


00:35:57.740 --> 00:36:00.900
community and what they thought in terms of restrictions and would


00:36:00.900 --> 00:36:02.380
that be too much or too little?


00:36:02.380 --> 00:36:04.420
I subsequently prototyped what I wanted.


00:36:04.660 --> 00:36:08.660
And there'll be a followup blog post about this is where it sits now.


00:36:08.660 --> 00:36:09.460
What do people think?


00:36:09.460 --> 00:36:13.580
And do people think this is worth trying to get syntax for just don't worry about


00:36:13.580 --> 00:36:16.260
it's too close to data classes or what?


00:36:16.260 --> 00:36:16.700
Yeah.


00:36:16.700 --> 00:36:20.740
Maybe it could be a keyword to the data class decorator that just


00:36:20.740 --> 00:36:21.820
makes it behave differently.


00:36:21.820 --> 00:36:22.380
Who knows?


00:36:22.380 --> 00:36:22.660
Yeah.


00:36:22.660 --> 00:36:25.540
But so unfortunately the tricky bit with that is it's still flowing


00:36:25.540 --> 00:36:26.340
through Python code, right?


00:36:26.340 --> 00:36:28.740
Data classes is still just a module in the standard library.


00:36:28.740 --> 00:36:32.660
So you can't, it's really hard to optimize that stuff without syntax to


00:36:32.660 --> 00:36:35.940
specifically say, Hey, this will be different.


00:36:35.940 --> 00:36:39.420
You get to treat it differently and we can literally lock it down by


00:36:39.420 --> 00:36:42.620
literally creating a different type of object at the C level that just


00:36:42.620 --> 00:36:43.740
literally doesn't give you access.


00:36:43.740 --> 00:36:43.900
Right?


00:36:43.900 --> 00:36:45.540
Like tuples are a good example.


00:36:45.540 --> 00:36:50.020
Tuples at the C level very much just don't implement the stuff that you mutate it.


00:36:50.020 --> 00:36:50.220
Right.


00:36:50.220 --> 00:36:52.020
What happens if we want to do that for classes?


00:36:52.020 --> 00:36:54.020
Like how do you do frozen data classes?


00:36:54.020 --> 00:36:55.700
It's a ton of properties.


00:36:55.700 --> 00:36:58.060
But what happens if we had a way to just say, yep, nope.


00:36:58.060 --> 00:36:59.580
We're just literally not giving you access.


00:36:59.580 --> 00:37:01.380
Would that, how much faster could that be?


00:37:01.380 --> 00:37:02.620
I, I don't know.


00:37:02.740 --> 00:37:04.940
But I suspect it would be decently faster.


00:37:04.940 --> 00:37:05.220
Yeah.


00:37:05.220 --> 00:37:07.340
Computers are surprisingly fast.


00:37:07.340 --> 00:37:10.460
Exchangers are surprisingly fast, but there's a lot of stuff here that could


00:37:10.460 --> 00:37:15.420
be skipped and I think might, might be, to me, I had the same thought at least.


00:37:15.420 --> 00:37:18.340
Probably not with the level of sophistication you did, but like, wow,


00:37:18.340 --> 00:37:22.660
there's some way to sort of do a more of a, a C style, just like we know the


00:37:22.660 --> 00:37:26.580
structure and the offsets like for a restricted set, because that restricted


00:37:26.580 --> 00:37:28.940
set is mostly what people do actually do in Python.


00:37:28.940 --> 00:37:33.460
They don't go crazy dynamic with stuff coming and going like sometimes, but not


00:37:33.460 --> 00:37:33.860
usually.


00:37:33.860 --> 00:37:34.220
Yeah.


00:37:34.220 --> 00:37:37.900
I mean, you can go read my original blog posts and if you follow me on master, you


00:37:37.900 --> 00:37:42.740
can see the follow up conversations, but like the original thing, if you've been a


00:37:42.740 --> 00:37:47.780
long time Java user, you'll, you'll know the acronym POJO, plain old Java object.


00:37:47.780 --> 00:37:49.980
It was effectively the equivalent for Python.


00:37:49.980 --> 00:37:51.420
Some people love that idea.


00:37:51.420 --> 00:37:53.580
Some people like, I really need methods.


00:37:53.580 --> 00:37:56.340
You, I can't not have methods kind of thing.


00:37:56.340 --> 00:37:58.820
It really depends on what people are after.


00:37:58.980 --> 00:38:03.140
And what, what they think makes sense, but there will be a follow up blog post.


00:38:03.140 --> 00:38:06.900
So if you follow my blog, you'll eventually see what this hopefully all leads to, which


00:38:06.900 --> 00:38:10.900
may be nowhere beyond what I put up on PyPI, but who knows, maybe, maybe it'll


00:38:10.900 --> 00:38:11.980
become Zendak someday.


00:38:11.980 --> 00:38:14.460
It really depends on how the community reacts to it.


00:38:14.460 --> 00:38:14.700
Cool.


00:38:14.700 --> 00:38:17.020
Well, I didn't know you were looking into that.


00:38:17.020 --> 00:38:17.860
So very interesting.


00:38:17.860 --> 00:38:18.740
Next one.


00:38:18.740 --> 00:38:23.260
Let's move on to something that also seems pretty straightforward is A minus B.


00:38:23.260 --> 00:38:26.860
Yeah, right.


00:38:26.860 --> 00:38:27.620
Yeah, exactly.


00:38:27.620 --> 00:38:28.780
You think it makes, yeah.


00:38:28.780 --> 00:38:31.020
How hard can A minus B be right?


00:38:31.020 --> 00:38:35.340
Like two objects just subtracting from one another, right?


00:38:35.340 --> 00:38:36.460
We all know how this works.


00:38:36.460 --> 00:38:39.300
There's, I mean, there's an op code just called binary subtract.


00:38:39.300 --> 00:38:41.980
Just like there's a binary add a binary multiply.


00:38:41.980 --> 00:38:48.060
You put the numbers on the register, you do the instruction set on the CPU and you're good to go.


00:38:48.060 --> 00:38:48.460
Yeah.


00:38:48.460 --> 00:38:50.020
Hey, I know what five minus three is.


00:38:50.020 --> 00:38:51.860
How much work can it be to make that work in Python?


00:38:51.860 --> 00:38:52.980
Oh yeah.


00:38:52.980 --> 00:38:57.100
The numbers happen to be arbitrarily large and sometimes they're not numbers.


00:38:57.100 --> 00:38:59.780
Sometimes they're matrices or strings or oh boy.


00:38:59.780 --> 00:39:00.100
Okay.


00:39:00.100 --> 00:39:00.700
Exactly.


00:39:00.700 --> 00:39:02.820
And subtraction is not communicative.


00:39:02.820 --> 00:39:04.340
So, or matters here.


00:39:04.340 --> 00:39:07.140
So yeah, it gets surprisingly complicated very quickly.


00:39:07.140 --> 00:39:07.420
Yeah.


00:39:07.420 --> 00:39:10.020
So yeah, from, from a conceptual level.


00:39:10.020 --> 00:39:10.260
Yeah.


00:39:10.260 --> 00:39:14.820
It seems simple, but when you figure out what that op code actually does, it becomes way fancier.


00:39:14.820 --> 00:39:15.100
Yeah.


00:39:15.100 --> 00:39:23.900
And so as you dig into this, you start to realize like, okay, so this is actually controlled by the Dunder sub operator on the type.


00:39:23.900 --> 00:39:24.460
Right.


00:39:24.460 --> 00:39:25.860
And then how do you get that method?


00:39:25.860 --> 00:39:29.140
Well, this is the method resolution order on that type.


00:39:29.140 --> 00:39:32.740
So you got to start navigating that and that gets pretty interesting.


00:39:32.740 --> 00:39:33.020
Right?


00:39:33.020 --> 00:39:33.460
Yeah.


00:39:33.460 --> 00:39:35.140
Well, and let's be clear here.


00:39:35.140 --> 00:39:38.980
You're a bit foreshadowing because you said, oh, you called the Dunder sub.


00:39:38.980 --> 00:39:39.460
Yeah.


00:39:39.460 --> 00:39:41.860
Just start if that works.


00:39:41.860 --> 00:39:42.700
Right.


00:39:42.700 --> 00:39:49.300
Like for a lot of these things, there's lots of fallback to once again, give you that flexibility to make things work as necessary.


00:39:49.500 --> 00:39:57.780
So for a lot of things in Python, you can return the not implemented Singleton, which you may have, some people may have noticed and wonder what the hell is this thing for.


00:39:57.780 --> 00:40:03.660
And it's a Singleton signal to Python that, Hey, there's not, it's not that an error happened.


00:40:03.660 --> 00:40:05.620
It's just, I just don't know how to handle this.


00:40:05.620 --> 00:40:06.180
Right.


00:40:06.180 --> 00:40:17.180
So for instance, if let's say you have left-hand side minus right-hand side, the first step is you check to see if the left-hand side has a Dunder sub method.


00:40:17.380 --> 00:40:23.220
If it does, you can call that with left-hand side dot Dunder sub and pass in right-hand side.


00:40:23.220 --> 00:40:28.140
Well, that method has the option to do something in return to value.


00:40:28.140 --> 00:40:35.340
And that's what left-hand side, right-hand side becomes, or it can return not implemented and say, just tell Python, Nope, I don't know how to do this.


00:40:35.340 --> 00:40:36.620
Probably should ask someone else.


00:40:36.620 --> 00:40:36.900
Right.


00:40:36.900 --> 00:40:45.060
And then this adds an extra little wrinkle now, because suddenly when you do that, that says, okay, well, you know what, let's give the right-hand side to try.


00:40:45.100 --> 00:40:48.700
Maybe the right-hand side knows how to do left-hand side minus right-hand side.


00:40:48.700 --> 00:40:51.740
It might not be the front thing, but it might just magically know.


00:40:51.740 --> 00:40:52.060
Right.


00:40:52.060 --> 00:41:00.500
So in this case, for instance, you could have something of your fancy object minus four, which would be your Dunder sub method.


00:41:00.500 --> 00:41:02.740
And so, you know how to handle integers and it works.


00:41:02.740 --> 00:41:05.740
What happens if it's four minus your object?


00:41:05.740 --> 00:41:06.140
Yeah.


00:41:06.140 --> 00:41:07.300
Four doesn't know what to do.


00:41:07.300 --> 00:41:07.700
Yeah.


00:41:07.700 --> 00:41:09.140
Four has never seen your thing before.


00:41:09.140 --> 00:41:10.300
I don't know what the heck to do here.


00:41:10.580 --> 00:41:14.500
So in that case, four would return not implemented thing.


00:41:14.500 --> 00:41:15.740
I don't know what to do here.


00:41:15.740 --> 00:41:16.700
Good luck to you.


00:41:16.700 --> 00:41:17.700
Maybe you'll figure it out.


00:41:17.700 --> 00:41:22.300
And in this case, your object Dunder, our sub would get called with four.


00:41:22.300 --> 00:41:28.900
And then maybe you'll be able to say like, Hey, I might not be on the left-hand side, but I know how to handle myself on the right-hand side and I can make this work.


00:41:28.900 --> 00:41:36.660
So we try to make sure that even if some other objects don't know how to work with you, as if you're involved, there's at least the opportunity for you to make it work.


00:41:36.660 --> 00:41:37.020
Yeah.


00:41:37.020 --> 00:41:38.060
That's pretty interesting.


00:41:38.060 --> 00:41:38.500
Yes.


00:41:38.500 --> 00:41:45.060
An example could be like the number four, a constant minus a vector that's meant to be like a mathematical vector.


00:41:45.060 --> 00:41:47.620
And it's like, okay, we just subtract that from every dimension.


00:41:47.620 --> 00:41:47.940
Right.


00:41:47.940 --> 00:41:51.060
And that would be totally reasonable, but the four has no idea how to do that.


00:41:51.060 --> 00:41:51.420
Yes.


00:41:51.420 --> 00:41:51.700
Yeah.


00:41:51.700 --> 00:41:52.980
And this is still the simple case.


00:41:52.980 --> 00:41:53.380
Yeah.


00:41:53.380 --> 00:42:07.980
So if I'll need a ref, I need a slight refresher on this one, but effectively there's scenarios here where you call the right-hand side first.


00:42:08.260 --> 00:42:15.540
If it's the left-hand side, one can say, I don't know what to do with this object, I think in return and not implemented from the subtract.


00:42:15.540 --> 00:42:15.860
Right.


00:42:15.860 --> 00:42:16.540
Something like that.


00:42:16.540 --> 00:42:16.900
Right.


00:42:16.900 --> 00:42:28.300
There's also a subtle optimization in these binary operators where if it is a direct subclass of the other object, you get first dibs.


00:42:28.300 --> 00:42:29.580
Oh, right, right, right.


00:42:29.580 --> 00:42:30.780
So that's the thing.


00:42:30.780 --> 00:42:30.940
Yeah.


00:42:30.940 --> 00:42:36.700
There's a lot of spam and bacon and vegetable spam and stuff that you did in here that people can check out.


00:42:36.700 --> 00:42:37.820
It gets surprisingly complicated.


00:42:37.820 --> 00:42:42.700
But the thing here, basically, this is the C of a left-hand side and a right-hand side, right?


00:42:42.700 --> 00:42:46.740
Once again, left-hand side, right-hand side, left-hand side might be an integer.


00:42:46.740 --> 00:42:51.180
Your right-hand side though, might be a subclass of integer, like fancy integer.


00:42:51.180 --> 00:42:51.620
Okay.


00:42:51.620 --> 00:42:57.780
Now, if you do int minus fancy int, it will understand how to do it because you're a subclass.


00:42:57.780 --> 00:43:01.820
So it's just going to do it and it'll just do the math and return you whatever it is.


00:43:01.820 --> 00:43:07.580
So like if you did five minus fancy three, five is going to return the integer two.


00:43:07.780 --> 00:43:09.980
But maybe that's not what you want with your fancy int.


00:43:09.980 --> 00:43:12.500
Maybe you always, maybe you'd rather get fancy int two.


00:43:12.500 --> 00:43:17.620
So how does Python make sure that you get that opportunity if you happen to be on the right-hand side instead of the left-hand side?


00:43:17.620 --> 00:43:17.980
Yeah.


00:43:17.980 --> 00:43:20.820
Well, in that case, Python checks first.


00:43:20.820 --> 00:43:21.620
Okay.


00:43:21.620 --> 00:43:24.100
I have a left-hand side and right-hand side for subtraction.


00:43:24.100 --> 00:43:28.180
Is the right-hand side a direct subclass of the left-hand side?


00:43:28.180 --> 00:43:29.620
If that's true, then you know what?


00:43:29.620 --> 00:43:37.460
I'm going to give the right-hand side a chance first so that they can return their subclass and not have the left-hand side kind of just blindly not


00:43:37.460 --> 00:43:40.380
realize that it's a different type and return something else.


00:43:40.380 --> 00:43:52.820
So that when it's, as I said, five minus fancy three, we actually get fancy three the first chance instead of five so that you have the chance to return fancy two like you wanted and not have five self-return.


00:43:52.820 --> 00:43:53.460
Boring two.


00:43:53.460 --> 00:43:53.820
Yeah.


00:43:53.820 --> 00:44:00.900
So I think one example that comes to mind that I think might be relevant would be working with units.


00:44:01.180 --> 00:44:09.500
So we've got cool libraries like Pint and others where you can say, this is not just the number five, but this is five kilograms.


00:44:09.500 --> 00:44:14.860
And if I subtract, you know, a hundred milligrams from it, it's not negative 95.


00:44:14.860 --> 00:44:18.180
It's, you know, four point whatever, nine, five or whatever it turns out to be.


00:44:18.180 --> 00:44:25.980
And so in this case, if you took a regular number and one of these numbers with units, you could get a number with units back potentially.


00:44:25.980 --> 00:44:26.420
Yeah.


00:44:26.420 --> 00:44:27.620
No, that's a very good example.


00:44:27.620 --> 00:44:27.900
Right.


00:44:27.900 --> 00:44:28.140
Yeah.


00:44:28.140 --> 00:44:44.620
This is where those, once again, very simple syntax that in the common case and in your general use day to day makes total sense and happens has some really important, but subtle, if you don't know about them, semantics to make sure that those reasonable expectations are met.


00:44:44.620 --> 00:44:44.900
Right.


00:44:44.900 --> 00:44:51.340
Like I totally didn't even think about this when I was doing, when I was writing this blog post that like, oh yeah, God, that's a good point.


00:44:51.340 --> 00:44:59.180
Like I do want to make sure that I get my special version of everything when I happen to be on the right hand side, just cause I happen to be written on the right hand side.


00:44:59.180 --> 00:45:01.580
But plus is a really good example in this one, right?


00:45:01.580 --> 00:45:05.180
Like you could have written a plus B or B plus a makes zero difference.


00:45:05.180 --> 00:45:13.860
I mean, that operator is supposed to be communicative, so it can be totally just dumb luck based on how I just happened to be thinking that day, what I put on the left side and what I put on the right side.


00:45:13.860 --> 00:45:15.740
And that would suddenly make a difference.


00:45:15.740 --> 00:45:24.060
And in this case, it just helps make sure that what you would think is the priority order of who you'd want to handle this for you gets that priority.


00:45:24.060 --> 00:45:27.940
But once again, it's a thing you just never think about day to day.


00:45:27.940 --> 00:45:33.020
But in actuality, when you think about the really key ways that Python operates, makes a surprising difference.


00:45:33.020 --> 00:45:39.100
Yeah, that seemingly leakiness of the language of like, well, sometimes it gives you the right answer, some it doesn't, depending on how you add.


00:45:39.100 --> 00:45:40.220
People wouldn't love that.


00:45:40.300 --> 00:45:48.660
Yeah. And then the last bit of subtlety on that one is this only happens if, by the way, dunder sub and dunder sub are different.


00:45:48.660 --> 00:45:53.260
So that's another check we do, because at the C level, they're actually equivalent.


00:45:53.260 --> 00:45:56.500
Like there is no left side versus right side thing here.


00:45:56.500 --> 00:46:07.380
So we actually check to make sure we don't waste our time asking you, hey, can you do this and get back not not implemented and then calling it a reverse and getting the exact same result because underneath it all is the exact same method.


00:46:07.380 --> 00:46:07.660
Right.


00:46:07.700 --> 00:46:13.180
So it's one of those fun things of once again, lots of little things here to try to optimize, as you said, as best we can.


00:46:13.180 --> 00:46:15.340
Where and in this case is one of those.


00:46:15.340 --> 00:46:19.500
Well, if we know you're not going to work this way with the exact same method, we just swap the order of the stuff.


00:46:19.500 --> 00:46:20.660
Why are we going to ask you again?


00:46:20.660 --> 00:46:22.100
So we just skip that.


00:46:22.100 --> 00:46:23.580
So it's a minor thing.


00:46:23.580 --> 00:46:26.700
But yeah, semantics are there to try to help help with the performance.


00:46:26.700 --> 00:46:33.580
I think people as people go through your series here, I think they're going to get a deep appreciation for edge cases.


00:46:33.580 --> 00:46:33.780
Yeah.


00:46:33.780 --> 00:46:34.300
Subtlety.


00:46:34.300 --> 00:46:35.020
Yeah.


00:46:35.020 --> 00:46:35.500
Yeah.


00:46:35.500 --> 00:46:36.900
I mean, the last few days.


00:46:36.980 --> 00:46:37.980
I learned a lot.


00:46:37.980 --> 00:46:46.700
I mean, it was one of the reasons I finished it is I finished the series as well, even though I partway through and like, yeah, you know what, I'm not going to implement Python from scratch.


00:46:46.700 --> 00:46:50.100
But I was learning enough and it was fun.


00:46:50.100 --> 00:46:52.220
Like, I got to dive a bit deep.


00:46:52.220 --> 00:46:59.820
I got to ask the Python core team is like from people primarily Guido, who obviously were there when these decisions were like, why this way?


00:46:59.980 --> 00:47:06.980
Like, why do we choose this and just trying to understand somewhat historically, how did these things happen?


00:47:06.980 --> 00:47:07.180
Right?


00:47:07.180 --> 00:47:11.540
Like, I think a lot of people don't realize how old Python is, right?


00:47:11.540 --> 00:47:14.140
Like February of 1991 is when Python came out.


00:47:14.140 --> 00:47:16.260
It predates Linux going public.


00:47:16.260 --> 00:47:18.100
Like people really forget that fact.


00:47:18.100 --> 00:47:20.940
It's been around for over 32 years.


00:47:20.940 --> 00:47:21.260
Yeah.


00:47:21.260 --> 00:47:23.140
Decisions were made a long time ago.


00:47:23.140 --> 00:47:26.860
And I know everyone got all upset over the two to three transition.


00:47:26.860 --> 00:47:29.500
And some people still get upset whenever we push new changes or whatever.


00:47:29.500 --> 00:47:33.020
But do realize, yeah, I can't believe you just canceled three seven.


00:47:33.020 --> 00:47:33.980
I like that version.


00:47:33.980 --> 00:47:39.340
But the key thing here is the core concepts still work.


00:47:39.340 --> 00:47:43.340
Subtraction still works right from the way it worked back then.


00:47:43.340 --> 00:47:45.020
There's not been a massive upheaval here.


00:47:45.020 --> 00:47:48.740
It's just a lot of us end up using stuff that's kind of fancy.


00:47:48.740 --> 00:47:51.260
And sometimes the fancy stuff gets a little tweaks and stuff.


00:47:51.260 --> 00:47:54.420
But the really core low level stuff really hasn't shifted very much.


00:47:54.420 --> 00:47:59.380
So if at all, depending on your people's sense of the timing, like the release of


00:47:59.380 --> 00:48:02.620
Python predates by a couple of years, the release of the web, right.


00:48:02.620 --> 00:48:03.980
The web was 93, I think.


00:48:03.980 --> 00:48:05.500
And so, yeah.


00:48:05.500 --> 00:48:05.820
Yeah.


00:48:05.820 --> 00:48:10.020
One of the early browsers was actually, Guido was writing in Python and TK.


00:48:10.020 --> 00:48:10.540
Incredible.


00:48:10.540 --> 00:48:10.820
Great.


00:48:10.820 --> 00:48:15.500
So we talked about simple things like thing dot value, A minus B.


00:48:15.500 --> 00:48:18.460
The next simple one is the import statement because imports are simple.


00:48:18.460 --> 00:48:24.100
Honestly, I think imports are, they, if you come from a compiled language, they're


00:48:24.100 --> 00:48:26.700
really, you've really got to change your mindset.


00:48:26.700 --> 00:48:27.140
Right.


00:48:27.140 --> 00:48:30.700
And so I think this one actually is maybe the opposite end of that spectrum a little.


00:48:30.700 --> 00:48:31.220
Oh yes.


00:48:31.220 --> 00:48:35.900
I will fully out my co some of my coworkers who are because VS Code is


00:48:35.900 --> 00:48:38.100
written in TypeScript as an electron app.


00:48:38.100 --> 00:48:41.340
And so they live in TypeScript all day long.


00:48:41.340 --> 00:48:45.340
The fact that Python's imports work the way they are in terms of flexibility and


00:48:45.340 --> 00:48:48.620
just the way it works and you're not just specifying file paths to everything, just.


00:48:48.620 --> 00:48:52.140
Really throws them for a loop and they go like, why is it so complicated?


00:48:52.140 --> 00:48:56.260
Once again, the flexibility that Python gives you where the base case, normal


00:48:56.260 --> 00:49:01.300
case of if you just do things the way just kind of just it's Python code and


00:49:01.300 --> 00:49:06.420
directory kind of thing just works versus I can also import something from a URL.


00:49:06.420 --> 00:49:08.140
If I want, that's totally optional.


00:49:08.140 --> 00:49:11.620
You know, I could keep all my core code in a SQLite database and


00:49:11.620 --> 00:49:13.620
import from there, totally possible.


00:49:13.620 --> 00:49:14.140
Right.


00:49:14.140 --> 00:49:17.900
So it's one of these things, once again, where if you're coming from a Python


00:49:17.900 --> 00:49:21.940
mindset of just what makes sense, it all just works.


00:49:21.940 --> 00:49:24.900
I realized when you come in with an outside perspective, it can look kind of


00:49:25.180 --> 00:49:29.220
crazy, but you also have to understand that a lot of the designs were made a


00:49:29.220 --> 00:49:33.660
decades ago and B, there's a lot of flexibility there that you may or may not


00:49:33.660 --> 00:49:36.420
be taking advantage of, but there are others who are.


00:49:36.420 --> 00:49:38.220
And so that's kind of why it exists that way.


00:49:38.220 --> 00:49:38.940
Yeah, indeed.


00:49:38.940 --> 00:49:40.660
And yes, this posts.


00:49:40.660 --> 00:49:41.140
Yeah.


00:49:41.140 --> 00:49:45.740
I, so for those of you who don't know, I actually am responsible for


00:49:45.740 --> 00:49:49.300
import lib and re-implementing Python's import system in Python itself.


00:49:49.300 --> 00:49:53.900
And so I know these details a little too well.


00:49:53.900 --> 00:49:54.740
Yeah.


00:49:54.820 --> 00:49:56.860
So still have nightmares about some of them.


00:49:56.860 --> 00:50:03.100
No, luckily, it luckily import lib in terms of actual import itself.


00:50:03.100 --> 00:50:07.100
Like this I'm ignoring import lib.resources or import lib.metadata.


00:50:07.100 --> 00:50:09.740
Jason Coons mainly manages those modules.


00:50:09.740 --> 00:50:12.940
It's been stable enough for long enough now that there's no


00:50:12.940 --> 00:50:14.420
real crazy surprises anymore.


00:50:14.420 --> 00:50:18.940
Honestly, the biggest headache is people doing imports in their threads.


00:50:18.940 --> 00:50:22.100
So my word of advice to everyone, don't do imports and threads.


00:50:22.140 --> 00:50:24.980
If you're going to do imports, do them on your main thread up front,


00:50:24.980 --> 00:50:26.420
then spawn your threads.


00:50:26.420 --> 00:50:29.820
Don't do imports as a side effect of anything either.


00:50:29.820 --> 00:50:31.260
It's circular imports.


00:50:31.260 --> 00:50:32.220
Same thing.


00:50:32.220 --> 00:50:34.220
It's just, just, just don't.


00:50:34.220 --> 00:50:37.660
Your life will be so much easier, but that's honestly where any of the bug


00:50:37.660 --> 00:50:41.020
reports that ever come in come from is due to either circular imports and


00:50:41.020 --> 00:50:45.740
people wanting why or weird race conditions with threads on imports and


00:50:45.740 --> 00:50:49.620
just trying to get the locking down such that things lead to the right outcome.


00:50:49.860 --> 00:50:54.980
Actually 3.12 almost got held up a little bit due to a slight memory leak


00:50:54.980 --> 00:50:59.180
from the newest version of tracking imports via threads.


00:50:59.180 --> 00:51:00.500
There was a slight leak of it.


00:51:00.500 --> 00:51:03.620
Basically an empty dictionary every time you did an important thread and


00:51:03.620 --> 00:51:04.540
we didn't want to have that leak.


00:51:04.540 --> 00:51:08.020
So we cleaned it up, but yeah, it was a lot of subtlety.


00:51:08.020 --> 00:51:09.300
Oh, we got lots of memory, bro.


00:51:09.300 --> 00:51:10.860
We don't need to worry about those things anymore.


00:51:10.860 --> 00:51:11.820
No, just kidding.


00:51:11.820 --> 00:51:12.060
Yeah.


00:51:12.060 --> 00:51:17.620
There's no reason everyone gets excited every time Apple launches a new M chip.


00:51:17.620 --> 00:51:17.980
Right.


00:51:18.020 --> 00:51:21.740
We've had enough processing power since we got someone on the moon with how many,


00:51:21.740 --> 00:51:22.740
how many Hertz.


00:51:22.740 --> 00:51:23.820
Exactly.


00:51:23.820 --> 00:51:25.580
No one needs more than seven Hertz.


00:51:25.580 --> 00:51:27.020
You know, the favorite, famous saying.


00:51:27.020 --> 00:51:27.460
No, just kidding.


00:51:27.460 --> 00:51:31.980
You know, one of the real big differences I think here is that like import runs


00:51:31.980 --> 00:51:32.620
code, right?


00:51:32.620 --> 00:51:37.700
Like rather than tells the compiler, these things are in scope if you want them, but


00:51:37.700 --> 00:51:39.540
no, it's like running code.


00:51:39.540 --> 00:51:45.220
And if people are wondering where that weird dunder name equals dunder main.


00:51:45.700 --> 00:51:49.540
So you don't run too much code during imports and those sorts of things.


00:51:49.540 --> 00:51:49.820
Right.


00:51:49.820 --> 00:51:50.460
Yeah, actually.


00:51:50.460 --> 00:51:55.260
And this is an interesting case where it's very much syntactic sugar, but it's


00:51:55.260 --> 00:51:58.100
also very much syntactic sugar actually for the bytecode.


00:51:58.100 --> 00:51:58.460
Yeah.


00:51:58.460 --> 00:52:02.420
So the thing here is when you do import spam, right.


00:52:02.420 --> 00:52:06.860
Or whatever module you want to import, it effectively ends up being a call to the


00:52:06.860 --> 00:52:10.500
dunder import built-in function where it passes in spam as the name, and then it


00:52:10.500 --> 00:52:15.500
passes on all the globals and the locals for where it gets called for name


00:52:15.500 --> 00:52:18.780
resolution and stuff like this is where you do relative imports with dot, you


00:52:18.780 --> 00:52:20.460
know, like dot, dot something.


00:52:20.460 --> 00:52:21.180
Yeah, exactly.


00:52:21.180 --> 00:52:23.740
When I first saw it, like, why are all these arguments going to import?


00:52:23.740 --> 00:52:28.300
You just need to know where a, a.py or the package a lives and you're good to go


00:52:28.300 --> 00:52:33.020
until you say, you know, dot, dot this or from dot.


00:52:33.020 --> 00:52:33.300
Yeah.


00:52:33.300 --> 00:52:35.620
From dot, dot a import B kind of stuff.


00:52:35.620 --> 00:52:38.900
Like there's a surprising amount of information you need to pass in to do


00:52:38.900 --> 00:52:42.420
those kinds of resolutions and such from imports, right?


00:52:42.420 --> 00:52:44.860
All that kind of thing to make sure that those things all exist.


00:52:44.860 --> 00:52:48.860
Cause what you're effectively doing in a, from import is if you list multiple ones,


00:52:48.860 --> 00:52:52.300
you're basically importing the module that those things are in and making sure


00:52:52.300 --> 00:52:55.780
that after we get set on the thing you're wanting so that you can then grab it


00:52:55.780 --> 00:52:57.300
later and all sorts of stuff.


00:52:57.300 --> 00:53:02.140
But the other key thing is, is the dunder import function is structured to kind of


00:53:02.140 --> 00:53:03.940
make the upcode easier, right?


00:53:03.940 --> 00:53:07.500
Cause it's very structured to just push things onto the stack.


00:53:07.500 --> 00:53:11.300
The Python's executing and then make the call to dunder import where it just like,


00:53:11.300 --> 00:53:12.340
yeah, everything's already there.


00:53:12.340 --> 00:53:12.580
Right.


00:53:12.580 --> 00:53:14.740
But it's also why it's so funky.


00:53:14.740 --> 00:53:17.220
You should never call it directly in your own code, right?


00:53:17.220 --> 00:53:18.660
Like dunder imports very much.


00:53:18.660 --> 00:53:21.580
It's borderline implementation detail on this kind of thing.


00:53:21.580 --> 00:53:24.980
This is why you should use import lib dot import module, right?


00:53:24.980 --> 00:53:29.260
That function exists specifically and I designed it specifically for those cases


00:53:29.260 --> 00:53:33.620
where you need to do dynamic imports and you want a very clean, simple API because


00:53:33.860 --> 00:53:39.180
like the return type for dunder import very much is designed for the upcode so


00:53:39.180 --> 00:53:43.740
that whether you're doing an import something or from something, import other


00:53:43.740 --> 00:53:44.540
thing, right?


00:53:44.540 --> 00:53:48.700
Like the return value makes sense or that for the bytecode level does not


00:53:48.700 --> 00:53:49.860
make sense for human beings.


00:53:49.860 --> 00:53:50.340
Right.


00:53:50.340 --> 00:53:52.780
So once again, do not call dunder import directly.


00:53:52.780 --> 00:53:55.980
You should always be calling import lib dot import module.


00:53:55.980 --> 00:53:58.060
If you need something dynamically to import.


00:53:58.060 --> 00:53:59.420
Or just use the word import.


00:53:59.420 --> 00:53:59.700
Yeah.


00:53:59.700 --> 00:54:00.700
Or just import.


00:54:00.700 --> 00:54:01.340
Yeah.


00:54:01.340 --> 00:54:02.020
Just import.


00:54:02.020 --> 00:54:02.780
Yeah.


00:54:03.020 --> 00:54:05.740
In your right up here, you have all the different variations.


00:54:05.740 --> 00:54:10.220
Like what does it mean to say from thing, import something as, or just import


00:54:10.220 --> 00:54:12.220
something or relative imports.


00:54:12.220 --> 00:54:16.660
So people can see all, all the different, again, back to that flexibility that you


00:54:16.660 --> 00:54:17.180
talked about.


00:54:17.180 --> 00:54:17.860
Exactly.


00:54:17.860 --> 00:54:21.740
So it's definitely one of these things though, where in the end it effectively


00:54:21.740 --> 00:54:23.580
just boils down to a function call, right?


00:54:23.580 --> 00:54:28.340
Like that's a piece of syntax of import really is just a function call with an


00:54:28.340 --> 00:54:29.660
assignment in the end.


00:54:29.660 --> 00:54:29.860
Yeah.


00:54:29.860 --> 00:54:31.180
And it's really all it is.


00:54:31.340 --> 00:54:35.420
It's the unraveling it, all the trickery is really behind the dunder import


00:54:35.420 --> 00:54:39.780
function, but the actual syntax is not, it's not crazy actually, but it literally


00:54:39.780 --> 00:54:40.700
is a function call.


00:54:40.700 --> 00:54:42.780
You can fully re-implement import.


00:54:42.780 --> 00:54:43.180
Yeah.


00:54:43.180 --> 00:54:45.420
But just calling dunder import and just doing the proper assignment.


00:54:45.420 --> 00:54:45.740
Nice.


00:54:45.740 --> 00:54:48.060
Some confirmation of your advice out there.


00:54:48.060 --> 00:54:50.780
And Nathan says, my data science professor always says the same thing.


00:54:50.780 --> 00:54:56.700
Import first, which is good, but also is there a way to remove syntactical sugar


00:54:56.700 --> 00:55:00.060
on an example, but not fully through just disassembly.


00:55:00.060 --> 00:55:04.580
I can actually write a tool that will take Python syntax and unravel it.


00:55:04.580 --> 00:55:07.540
I actually started it, but it was just too much of a headache because there's so


00:55:07.540 --> 00:55:10.300
many variations and edge cases and all that stuff to handle.


00:55:10.300 --> 00:55:14.300
And there was no package out there that, that was going to, that quite did what I


00:55:14.300 --> 00:55:16.420
needed to do to make my life easier.


00:55:16.420 --> 00:55:17.780
And I had other things too.


00:55:17.780 --> 00:55:17.940
Yeah.


00:55:17.940 --> 00:55:20.660
What's the canonical destination, what's the destination, right?


00:55:20.660 --> 00:55:25.860
Like if I undo a, a with statement on a lock, like how far do I want to go back?


00:55:25.860 --> 00:55:26.380
You know?


00:55:26.380 --> 00:55:26.860
Yeah.


00:55:26.860 --> 00:55:31.900
Well, and I can understand people wanting to do it to maybe learn, but I mean, it's


00:55:31.900 --> 00:55:35.940
going to be a learning thing, not really a performance thing or


00:55:35.940 --> 00:55:37.140
It might be slower, right?


00:55:37.140 --> 00:55:39.420
Because some of this stuff is happening at the C level.


00:55:39.420 --> 00:55:40.340
No, yeah, exactly.


00:55:40.340 --> 00:55:45.380
Like, like if you go back to our A plus B example, it actually definitely will be


00:55:45.380 --> 00:55:51.140
slower as things progress, as things happen in Python, because once again, with


00:55:51.140 --> 00:55:55.660
the, the speed performance improvements that have been going in, like, like the,


00:55:55.700 --> 00:55:59.140
the byte code is able to go like, all right, is this an int and an int?


00:55:59.140 --> 00:55:59.660
Okay.


00:55:59.660 --> 00:56:02.100
Well then we're, we know exactly how to do integer math.


00:56:02.100 --> 00:56:02.700
Let's just do it.


00:56:02.700 --> 00:56:03.140
Right.


00:56:03.140 --> 00:56:06.260
And then it can add cards in and go like, okay, quick check.


00:56:06.260 --> 00:56:06.980
A B yes.


00:56:06.980 --> 00:56:07.260
Okay.


00:56:07.260 --> 00:56:11.340
Do the binary int add thing, right.


00:56:11.340 --> 00:56:14.460
Where it just very, very obviously does that.


00:56:14.460 --> 00:56:17.620
But if you unravel it, you can't do that because now you're just doing method calls.


00:56:17.620 --> 00:56:18.100
Right.


00:56:18.100 --> 00:56:20.500
You can't hide those details anymore and put all that stuff.


00:56:20.500 --> 00:56:20.980
Exactly.


00:56:20.980 --> 00:56:24.420
But yeah, but to answer the question, you totally could write a tool to do this.


00:56:24.700 --> 00:56:27.980
And I kind of started one and it just wasn't fun.


00:56:27.980 --> 00:56:32.060
So I just stopped because I just had a lot of, you know, sometimes you see this


00:56:32.060 --> 00:56:35.540
in the editor as well, when like editors will give you previews.


00:56:35.540 --> 00:56:41.060
So for example, if you use optional of a thing or thing, pipe, none, and then


00:56:41.060 --> 00:56:44.380
you hover over it in the editor, it'll say, even if you used optional, it'll


00:56:44.380 --> 00:56:47.700
say thing, pipe, none, because it, it's like, those mean the same thing.


00:56:47.700 --> 00:56:49.580
I'm going to just represent them in one way.


00:56:49.580 --> 00:56:51.020
And yeah, yeah.


00:56:51.020 --> 00:56:51.700
Interesting.


00:56:51.700 --> 00:56:52.140
Okay.


00:56:52.140 --> 00:56:54.380
We have a bunch more things covered, but we don't have really any time.


00:56:54.380 --> 00:56:57.580
Like my goal with this, having you on here to talk about this stuff, it's


00:56:57.580 --> 00:57:00.300
really kind of like the highlight, the whole series and people should go.


00:57:00.300 --> 00:57:05.140
And we've been kind of hand-waving cause reading C code on air is not ideal.


00:57:05.140 --> 00:57:09.420
No, I think it'd be a whole an idea, but really to highlight your whole series


00:57:09.420 --> 00:57:13.100
and people can just dive into this pretty deep and, and I think they'll


00:57:13.100 --> 00:57:16.740
have a much better appreciation for when you write this one line.


00:57:16.740 --> 00:57:17.980
Oh my goodness.


00:57:17.980 --> 00:57:19.100
This is actually what's happening.


00:57:19.100 --> 00:57:21.380
And how I actually found a bug in Python.


00:57:21.380 --> 00:57:22.060
Thanks to it.


00:57:22.060 --> 00:57:22.380
Okay.


00:57:22.380 --> 00:57:23.300
Tell us quick about that.


00:57:23.340 --> 00:57:29.060
Yeah, it's covered in the in-place binary operator, augmented assignment post.


00:57:29.060 --> 00:57:34.580
So, you know how you can do a plus equals B and it's like doing a equals a plus B.


00:57:34.580 --> 00:57:34.820
Yeah.


00:57:34.820 --> 00:57:35.420
Yeah.


00:57:35.420 --> 00:57:36.980
So it turned out it was broken for pal.


00:57:36.980 --> 00:57:41.380
So when you know, when you could do a star, star B that's a to the B power.


00:57:41.380 --> 00:57:42.020
Yeah.


00:57:42.020 --> 00:57:45.300
It turned out the semantics were busted for star, star equals.


00:57:45.300 --> 00:57:45.980
Wow.


00:57:45.980 --> 00:57:46.340
Okay.


00:57:46.340 --> 00:57:49.940
And no one had ever noticed because obviously people do not write custom


00:57:49.940 --> 00:57:54.580
implementations of thunder pal because effectively what turned out was, and


00:57:54.580 --> 00:57:57.460
someone actually discovered it and reported it, I just didn't know about it.


00:57:57.460 --> 00:58:03.420
That basically when you did that, so the in-place augmented assignment, there's


00:58:03.420 --> 00:58:04.460
I versions of everything.


00:58:04.460 --> 00:58:06.380
I'm like, I add a dunder.


00:58:06.380 --> 00:58:07.380
I add dunder.


00:58:07.380 --> 00:58:08.700
I mall dunder.


00:58:08.700 --> 00:58:09.260
I pal.


00:58:09.260 --> 00:58:09.620
Right.


00:58:09.620 --> 00:58:12.740
Turns out for all of them, they did the right thing except for power


00:58:12.740 --> 00:58:14.580
where it would check for I pal.


00:58:14.580 --> 00:58:19.140
And I mean, in all these scenarios, because a plus equals B is the same


00:58:19.140 --> 00:58:20.300
as a equals a plus B.


00:58:20.300 --> 00:58:25.660
If the I version returns, not implemented, it falls back to just doing the binary


00:58:25.660 --> 00:58:27.260
operator and then doing the assignment.


00:58:27.260 --> 00:58:27.740
Right.


00:58:27.740 --> 00:58:33.180
So like if I plus, so I plus equals B unravels to a.i pap.


00:58:33.180 --> 00:58:34.820
I hate dot dunder.


00:58:34.820 --> 00:58:36.780
I pal with B as an argument.


00:58:36.780 --> 00:58:41.980
If that returns on implemented, then it devolves into a plus B a equals the


00:58:41.980 --> 00:58:42.820
result of that, right?


00:58:42.820 --> 00:58:46.860
In the power case, if you return, not implemented on thunder, I pal, it


00:58:46.860 --> 00:58:47.820
didn't fall back to pal.


00:58:47.980 --> 00:58:48.500
Okay.


00:58:48.500 --> 00:58:49.540
He just crashed.


00:58:49.540 --> 00:58:50.660
He said, I don't know what to do here.


00:58:50.660 --> 00:58:51.620
It was just an exception.


00:58:51.620 --> 00:58:52.060
It was like, yep.


00:58:52.060 --> 00:58:52.420
Nope.


00:58:52.420 --> 00:58:54.100
I suppose that's better than the wrong answer.


00:58:54.100 --> 00:58:56.620
Like actually the square of nine is 18.


00:58:56.620 --> 00:58:57.300
Carry on.


00:58:57.300 --> 00:59:02.140
It threw me for a loop because I wrote code to verify all my unraveling and


00:59:02.140 --> 00:59:05.940
how did the augmented assignment for power just kept not working.


00:59:05.940 --> 00:59:07.460
And it's like, what the heck's going on?


00:59:07.460 --> 00:59:08.940
And then I had to dig into the C code.


00:59:08.940 --> 00:59:10.460
And I was like, what am I doing wrong here?


00:59:10.460 --> 00:59:11.100
Yeah.


00:59:11.100 --> 00:59:11.860
Wait a second.


00:59:11.860 --> 00:59:14.580
That code unravels calling this C code, calling this C code.


00:59:14.860 --> 00:59:18.900
And it didn't check that return value on calling it under I pal.


00:59:18.900 --> 00:59:20.380
It's like, well, did a return not implemented?


00:59:20.380 --> 00:59:22.580
And if it did, then we've got to try the other version.


00:59:22.580 --> 00:59:23.180
It just didn't.


00:59:23.180 --> 00:59:26.340
It's just like, Oh, no, it's just the value just got returned.


00:59:26.340 --> 00:59:27.620
It just didn't even check.


00:59:27.620 --> 00:59:31.380
I think we figured out it happened when the third argument to pal got added.


00:59:31.380 --> 00:59:36.060
And it was just someone overlooked it, but I see it been sitting there for years.


00:59:36.060 --> 00:59:37.780
Like I think it was a decade.


00:59:37.780 --> 00:59:38.100
Yeah.


00:59:38.100 --> 00:59:39.260
You're looking through these things.


00:59:39.260 --> 00:59:41.180
You can tell that they're pretty subtle.


00:59:41.180 --> 00:59:43.420
There's a lot going on in the different special cases.


00:59:43.420 --> 00:59:46.300
So I can see it wouldn't hit you in the face that you necessarily


00:59:46.300 --> 00:59:47.220
miss something right away.


00:59:47.220 --> 00:59:47.820
Exactly.


00:59:47.820 --> 00:59:48.500
Yeah.


00:59:48.500 --> 00:59:48.980
Yeah.


00:59:48.980 --> 00:59:50.380
I don't fault anyone at all.


00:59:50.380 --> 00:59:53.260
It was, I think we were just missing a test case somewhere to make sure that


00:59:53.260 --> 00:59:57.100
that happened because, and once again, I don't think people define their own


00:59:57.100 --> 00:59:59.340
custom pal operator for their types.


00:59:59.340 --> 01:00:03.900
There's a whole bunch of mathematicians going, don't we do, we do or


01:00:03.900 --> 01:00:04.980
physicists or something.


01:00:04.980 --> 01:00:05.260
Yep.


01:00:05.260 --> 01:00:05.700
All right.


01:00:05.700 --> 01:00:08.060
We're pretty much out of time to go any deeper on this.


01:00:08.060 --> 01:00:09.300
And I think that that's right.


01:00:09.300 --> 01:00:12.100
I think people got a really good sense of what's happening.


01:00:12.100 --> 01:00:15.380
You know, like what you mean with your series here and hopefully


01:00:15.380 --> 01:00:16.380
they're inspired to go check it out.


01:00:16.380 --> 01:00:19.860
But I do, while I have this import stuff on the screen and you've done


01:00:19.860 --> 01:00:24.780
so much work with import lib, will there ever be a time where like hot


01:00:24.780 --> 01:00:29.140
reload type of stuff is a thing, you know, like I edit this file in this


01:00:29.140 --> 01:00:33.740
web app and it's got this project it's been running and I just, just maybe


01:00:33.740 --> 01:00:38.260
could we have a file watcher trigger this module to re-import not necessarily


01:00:38.260 --> 01:00:40.060
saying it's a good idea, but have you thought of that?


01:00:40.060 --> 01:00:41.060
Have you thought of that?


01:00:41.060 --> 01:00:43.740
You know, you want automatic import lib dot reload?


01:00:43.740 --> 01:00:44.260
Yes.


01:00:44.260 --> 01:00:47.820
Or, you know, even like the, the lib reload stuff, a lot of times like you


01:00:47.820 --> 01:00:50.940
can do it, but it's kind of discouraged because I think largely because of


01:00:50.940 --> 01:00:52.940
the side effects, what can happen there?


01:00:52.940 --> 01:00:53.500
No.


01:00:53.500 --> 01:00:58.140
So to be very specific, if you call a module, if you call import lib dot


01:00:58.140 --> 01:01:02.100
reload on a module, it effectively reruns import on that module.


01:01:02.100 --> 01:01:07.260
The problem is, is all the references you have to objects don't change.


01:01:07.260 --> 01:01:08.020
Yeah, exactly.


01:01:08.020 --> 01:01:12.740
So if you got something out of that module, like let's say there was a


01:01:12.740 --> 01:01:15.700
global dictionary that you stored a reference to a way that you expect.


01:01:15.700 --> 01:01:16.020
Right.


01:01:16.020 --> 01:01:17.820
Or a function or a class.


01:01:17.820 --> 01:01:18.180
Maybe.


01:01:18.180 --> 01:01:18.740
Exactly.


01:01:18.740 --> 01:01:19.140
Yeah.


01:01:19.140 --> 01:01:20.460
And then you call reload.


01:01:20.460 --> 01:01:24.140
Everyone else in the future is going to get the new module and they'll get the


01:01:24.140 --> 01:01:27.340
new version of all the things that were in that module, but all that stuff, you


01:01:27.340 --> 01:01:28.460
still have reference to do that.


01:01:28.460 --> 01:01:30.860
And it's magically taken away or garbage collected.


01:01:30.860 --> 01:01:33.220
And we can't really swap it underneath you either.


01:01:33.220 --> 01:01:34.860
Cause the whole type could have changed.


01:01:34.860 --> 01:01:35.220
Right.


01:01:35.220 --> 01:01:35.460
Right.


01:01:35.460 --> 01:01:40.060
So, I mean, if you really wanted to set up your own import system that does


01:01:40.060 --> 01:01:43.180
file monitoring and omnic calls import lib dot reload, you could totally do that


01:01:43.180 --> 01:01:43.500
today.


01:01:43.500 --> 01:01:44.980
There's, there's nothing stopping you.


01:01:44.980 --> 01:01:48.180
But you have to just be very aware that.


01:01:48.180 --> 01:01:50.580
Only sometimes will it have a good effect.


01:01:50.580 --> 01:01:51.260
Yeah.


01:01:51.260 --> 01:01:52.500
It'll have an effect.


01:01:52.500 --> 01:01:52.740
Yeah.


01:01:52.740 --> 01:01:55.380
It's just whether it's going to do what you expect.


01:01:55.380 --> 01:02:00.100
And that's, and that's why import lib dot reload is discouraged because people


01:02:00.100 --> 01:02:03.740
often don't quite understand the side effects and the things you have to watch


01:02:03.740 --> 01:02:06.500
out for to understand that it's going to do what you expect.


01:02:06.500 --> 01:02:11.100
And especially when you import do from imports, right.


01:02:11.100 --> 01:02:14.020
Cause then you're getting the direct objects off the module instead of the


01:02:14.020 --> 01:02:14.820
module itself.


01:02:14.820 --> 01:02:20.100
Cause like if it doesn't in place re-import, so like if you did import spam


01:02:20.100 --> 01:02:24.220
and you reloaded spam, the attributes off of spam will now be the new stuff.


01:02:24.220 --> 01:02:27.140
Cause we actually, we actually changed that dictionary in place, but if you did


01:02:27.140 --> 01:02:30.740
from spam import function, function is not going to change.


01:02:31.020 --> 01:02:33.940
There's another reason why I always tell everybody don't import the objects


01:02:33.940 --> 01:02:35.660
from a module import to the module.


01:02:35.660 --> 01:02:36.260
I find it.


01:02:36.260 --> 01:02:36.500
Yeah.


01:02:36.500 --> 01:02:38.860
I personally find it more readable cause I can look at the code no


01:02:38.860 --> 01:02:39.740
matter where I am in the file.


01:02:39.740 --> 01:02:41.700
I know where that function came from.


01:02:41.700 --> 01:02:42.580
It's not from this module.


01:02:42.580 --> 01:02:43.140
It's from somewhere else.


01:02:43.140 --> 01:02:43.900
I am always with you.


01:02:43.900 --> 01:02:46.900
I'm almost never from thing import other thing.


01:02:46.900 --> 01:02:47.260
Yeah.


01:02:47.260 --> 01:02:50.540
Unless it's a deep module in a package, in which case that makes sense.


01:02:50.540 --> 01:02:53.140
Cause you'll still do module dot thing.


01:02:53.140 --> 01:02:53.540
Right.


01:02:53.540 --> 01:02:53.740
Right.


01:02:53.740 --> 01:02:56.620
I was like, well, even though I have that, if it's like four levels deep, I'll do


01:02:56.620 --> 01:03:00.940
the first three and then from the first three import the last, last step of


01:03:00.940 --> 01:03:04.980
the module, so you can say like data layer dot, you know, exactly update


01:03:04.980 --> 01:03:06.740
rather than just update, like, well, what does update mean?


01:03:06.740 --> 01:03:07.260
I don't know.


01:03:07.260 --> 01:03:07.860
Exactly.


01:03:07.860 --> 01:03:08.220
Yeah.


01:03:08.220 --> 01:03:12.140
I mean, the canonical examples, random, you see the function random in your code.


01:03:12.140 --> 01:03:13.340
Whose random is that?


01:03:13.340 --> 01:03:14.860
Is that from the random module?


01:03:14.860 --> 01:03:15.980
Is that from NumPy?


01:03:15.980 --> 01:03:17.500
Did you implement random?


01:03:17.500 --> 01:03:18.860
Whose random is that?


01:03:18.860 --> 01:03:19.340
Yeah.


01:03:19.340 --> 01:03:19.900
You just know.


01:03:19.900 --> 01:03:21.820
But if you saw np.random, you'd know.


01:03:21.820 --> 01:03:22.420
Exactly.


01:03:22.420 --> 01:03:22.780
Yeah.


01:03:22.780 --> 01:03:23.780
If you knew what np was.


01:03:23.780 --> 01:03:24.020
Yeah.


01:03:24.020 --> 01:03:25.340
If you did, of course.


01:03:25.340 --> 01:03:26.300
Right.


01:03:26.300 --> 01:03:30.060
I guess, give you a chance to kind of summarize final, final


01:03:30.060 --> 01:03:33.820
thoughts here on your syntactic sugar series and, you know, tell


01:03:33.820 --> 01:03:35.060
people how to get it and stuff.


01:03:35.060 --> 01:03:36.020
You can go to my blog.


01:03:36.020 --> 01:03:37.340
It's on snarky.ca.


01:03:37.340 --> 01:03:39.340
It has the tags and syntactic sugar.


01:03:39.340 --> 01:03:41.300
I'm sure Michael included in the show notes.


01:03:41.300 --> 01:03:46.820
Don't feel the need to read all of it, but do look at least the first one or


01:03:46.820 --> 01:03:50.700
two, because I do go into more detail on how you can kind of go exploring on


01:03:50.700 --> 01:03:53.820
your own in way more detail in those posts than I do towards the end.


01:03:53.820 --> 01:03:54.780
Cause I'll be honest.


01:03:54.780 --> 01:03:58.980
I lost a bit of steam and going diving into all the deep layers.


01:03:59.220 --> 01:04:01.420
I wanted to get the blog post series done after two years.


01:04:01.420 --> 01:04:02.060
So it was one of those.


01:04:02.060 --> 01:04:02.740
Okay.


01:04:02.740 --> 01:04:03.620
Go look at the earlier ones.


01:04:03.620 --> 01:04:07.060
They'll explain how to, how to figure out how to go from syntax to the byte


01:04:07.060 --> 01:04:10.940
code, to the C code, and then know where to look in the C code, which by the way,


01:04:10.940 --> 01:04:12.580
you don't have to understand the C code.


01:04:12.580 --> 01:04:16.700
It's not a, it's not crazy C code, but it's also not necessarily critical.


01:04:16.700 --> 01:04:19.740
I do try to write down the Python equivalents for everything.


01:04:19.740 --> 01:04:23.460
So it's there if you do understand C, but don't feel intimidated if you don't.


01:04:23.460 --> 01:04:25.860
And hopefully you just find it interesting, right?


01:04:25.860 --> 01:04:27.820
Like you've always wondered how the heck does this work?


01:04:27.940 --> 01:04:32.620
If it's in that, if it's in the blog post, you'll build a, have a better


01:04:32.620 --> 01:04:33.900
understanding, hopefully of how things work.


01:04:33.900 --> 01:04:37.740
Cause as I said, I honestly even learned some details that I forgot or never even


01:04:37.740 --> 01:04:42.380
knew about some of the semantics behind Python and how, like how things actually


01:04:42.380 --> 01:04:45.020
work underneath the hood and it just gave me a better understanding to understand.


01:04:45.020 --> 01:04:49.140
When things do and don't happen the way I expect and just honestly appreciate


01:04:49.140 --> 01:04:53.300
all the work everyone's put into language over the decades to make it all seemingly


01:04:53.300 --> 01:04:55.780
seem simple and yet it's surprisingly complex.


01:04:55.780 --> 01:04:55.940
Yeah.


01:04:55.940 --> 01:04:58.420
I don't think you need to read them all either as somebody who read most


01:04:58.420 --> 01:04:59.460
of them the last couple of days.


01:04:59.460 --> 01:05:00.580
No, you don't.


01:05:00.580 --> 01:05:01.420
That I do.


01:05:01.420 --> 01:05:04.620
If you're a completionist, go for it, but you definitely do not need to.


01:05:04.620 --> 01:05:08.220
But I do think going through it, you know, pick out the ones, there's a


01:05:08.220 --> 01:05:09.260
whole bunch of different topics.


01:05:09.260 --> 01:05:11.740
Pick out the ones that are, you're like, Oh, I did always wonder how that one


01:05:11.740 --> 01:05:17.180
worked and pretty much with the exception of pass, I think you'll be like, Oh my


01:05:17.180 --> 01:05:19.300
gosh, I had no idea what was involved here.


01:05:19.300 --> 01:05:19.540
Yeah.


01:05:19.540 --> 01:05:23.860
Pass was very much just a, I had a checklist of every piece of syntax and every


01:05:23.860 --> 01:05:28.900
single keyword, and that was that the blog post on pass, I think is like three


01:05:28.900 --> 01:05:31.780
sentences and half of it saying this is going to be the shortest, shortest post


01:05:31.780 --> 01:05:32.580
in this whole series.


01:05:32.580 --> 01:05:33.060
Yeah.


01:05:33.060 --> 01:05:33.620
Passes.


01:05:33.620 --> 01:05:34.940
Yeah.


01:05:34.940 --> 01:05:38.500
It was contending with the dot, dot, dot, which we haven't had a chance to talk


01:05:38.500 --> 01:05:42.340
about ellipsis versus pass, but I think we're out of time, Brett.


01:05:42.340 --> 01:05:44.100
So thanks for being here.


01:05:44.100 --> 01:05:45.780
Thanks for all you do.


01:05:45.780 --> 01:05:50.780
I mean, steering council, core dev, author, VS Code, et cetera.


01:05:50.780 --> 01:05:51.820
A lot of contributions.


01:05:51.820 --> 01:05:52.260
Thanks.


01:05:52.260 --> 01:05:53.820
Thanks for having me back on yet again.


01:05:53.820 --> 01:05:55.740
And hopefully I've not worn out my welcome still.


01:05:55.740 --> 01:06:00.660
No, you're already thinking about what next WebAssembly rust thing we'll get


01:06:00.660 --> 01:06:01.220
together on.


01:06:01.220 --> 01:06:02.620
Thanks for being here.


01:06:02.620 --> 01:06:03.060
See you later.


01:06:03.060 --> 01:06:03.260
Thanks.


01:06:03.260 --> 01:06:07.220
This has been another episode of talk Python to me.


01:06:07.220 --> 01:06:09.060
Thank you to our sponsors.


01:06:09.060 --> 01:06:10.620
Be sure to check out what they're offering.


01:06:10.620 --> 01:06:12.020
It really helps support the show.


01:06:12.020 --> 01:06:14.340
Want to level up your Python.


01:06:14.340 --> 01:06:18.340
We have one of the largest catalogs of Python video courses over at talk Python.


01:06:18.340 --> 01:06:22.900
Our content ranges from true beginners to deeply advanced topics like memory and


01:06:22.940 --> 01:06:26.100
async, and best of all, there's not a subscription in sight.


01:06:26.100 --> 01:06:28.940
Check it out for yourself at training.talkpython.fm.


01:06:28.940 --> 01:06:31.100
Be sure to subscribe to the show.


01:06:31.100 --> 01:06:33.940
Open your favorite podcast app and search for Python.


01:06:33.940 --> 01:06:35.100
We should be right at the top.


01:06:35.100 --> 01:06:39.820
You can also find the iTunes feed at /itunes, the Google play feed at slash


01:06:39.820 --> 01:06:44.460
play and the direct RSS feed at /rss on talkpython.fm.


01:06:44.460 --> 01:06:45.940
We're live streaming.


01:06:45.940 --> 01:06:47.500
Most of our recordings these days.


01:06:47.500 --> 01:06:50.940
If you want to be part of the show and have your comments featured on the air,


01:06:51.060 --> 01:06:55.340
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.


01:06:55.340 --> 01:06:57.420
This is your host, Michael Kennedy.


01:06:57.420 --> 01:06:58.660
Thanks so much for listening.


01:06:58.660 --> 01:06:59.700
I really appreciate it.


01:06:59.700 --> 01:07:01.700
Now get out there and write some Python code.


01:07:02.540 --> 01:07:17.540
[Music]


01:07:17.540 --> 01:07:22.540
[Music]

