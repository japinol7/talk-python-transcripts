WEBVTT

00:00:00.001 --> 00:00:03.300
If you work in data science, you definitely know about data frame libraries.

00:00:03.300 --> 00:00:09.740
Pandas is certainly the most popular, but there are others such as QDF, Moden, Polars,

00:00:09.740 --> 00:00:14.440
Dask, and more. They're all similar, but definitely not the same APIs, and Polars is

00:00:14.440 --> 00:00:19.660
quite different. But here's the problem. If you want to write a library that is for users of more

00:00:19.660 --> 00:00:24.240
than one of these data frame frameworks, how do you do that? Or if you want to leave open the

00:00:24.240 --> 00:00:29.260
possibility of changing yours after the app is built, you got the same problem. Well, that's what

00:00:29.260 --> 00:00:36.240
Narwhals solves. We have Marco Garelli on the show to tell us all about Narwhals. This is Talk

00:00:36.240 --> 00:00:40.320
Python to Me, episode 480, recorded September 10th, 2024.

00:00:40.320 --> 00:00:43.040
Are you ready for your host, please?

00:00:43.040 --> 00:00:48.380
You're listening to Michael Kennedy on Talk Python to Me. Live from Portland, Oregon,

00:00:48.380 --> 00:00:50.380
and this segment was made with Python.

00:00:50.380 --> 00:00:58.700
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:58.700 --> 00:01:03.940
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using at Talk Python,

00:01:03.940 --> 00:01:10.000
both accounts over at Fosstodon.org, and keep up with the show and listen to over nine years of

00:01:10.000 --> 00:01:15.740
episodes at talkpython.fm. If you want to be part of our live episodes, you can find the live streams

00:01:15.740 --> 00:01:21.560
over on YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube and get notified

00:01:21.560 --> 00:01:28.060
about upcoming shows. This episode is brought to you by WorkOS. If you're building a B2B SaaS app,

00:01:28.060 --> 00:01:32.680
at some point your customers will start asking for enterprise features like SAML authentication,

00:01:32.680 --> 00:01:39.280
SKIM provisioning, audit logs, and fine-grained authorization. WorkOS helps ship enterprise features

00:01:39.280 --> 00:01:45.540
on day one without slowing down your core product development. Find out more at talkpython.fm slash

00:01:45.540 --> 00:01:51.460
workOS. Marco, welcome to Talk Python to Me. Hi, thanks for having me. Hey, it's fantastic to

00:01:51.460 --> 00:01:57.240
have you here. We talked a little bit on the socials and other places, but, you know, nice to

00:01:57.240 --> 00:02:00.940
talk to you in person and about some of your projects. Yeah, nice to finally do it. I've been

00:02:00.940 --> 00:02:05.920
listening to your shows for years, so it's a pleasure to be here. Yeah, that's really cool. It's

00:02:05.920 --> 00:02:10.980
awesome when people who are listeners for a long time get to come on the show. I love it. So,

00:02:10.980 --> 00:02:17.620
we're going to talk about narwhals and data science, data frame libraries, and basically

00:02:17.620 --> 00:02:23.160
coming up with a way to write consistent code against all these different libraries, which I think

00:02:23.160 --> 00:02:28.100
is an awesome goal, which is why I'm having you on the show, of course. Before we get to all that,

00:02:28.100 --> 00:02:33.620
as you know, let's hear a little bit about yourself. Sure. So, yeah, my name is Marco. I work at a company

00:02:33.620 --> 00:02:40.360
called QuantSight Labs, which supports several open source projects and also offers some training and

00:02:40.360 --> 00:02:47.720
consulting services. I live in Cardiff in Wales and been at QuantSight for about two years now.

00:02:47.720 --> 00:02:54.520
Originally hired as a Pandas maintainer, but then shifted considerably towards some other projects,

00:02:54.520 --> 00:03:00.840
such as Polars. And then in February of this year, I tried releasing this narwhals library as a bit of an

00:03:00.840 --> 00:03:08.600
experiment. It's growing a bit faster than expected. Yeah, it's a really interesting project. QuantSight is

00:03:08.600 --> 00:03:14.440
quite the place. You know, I didn't really know about y'all before having people on the show from

00:03:14.440 --> 00:03:19.400
there, but here's my experience. I've had, I reach out to say some of the Jupyter folks, whatever.

00:03:19.400 --> 00:03:23.160
Let's have, let's have some of the Jupyter people on. There's three or four people from QuantSight

00:03:23.160 --> 00:03:28.440
show up and then, oh, let's talk about this other project. Another person from QuantSight two weeks

00:03:28.440 --> 00:03:33.160
later, and then you're from QuantSight. And none of those connections were like, let me try to find

00:03:33.160 --> 00:03:37.080
people from QuantSight. I think you all are having a pretty big impact in the data science space.

00:03:37.080 --> 00:03:37.560
That's cool.

00:03:37.560 --> 00:03:42.440
That's true. Yeah, it is a bit amusing in the internal Slack channel. If you ask a question,

00:03:42.440 --> 00:03:46.360
how does anyone know how to do this? Someone would reply, oh yeah, let me ping this person

00:03:46.360 --> 00:03:48.760
who's a maintainer of that library. And you're like, okay, well.

00:03:48.760 --> 00:03:52.360
Exactly. I think we know how it works. Let's ask them.

00:03:53.640 --> 00:03:57.480
Yeah. It's a big world, but also a small world in interesting ways.

00:03:57.480 --> 00:03:58.040
Yeah.

00:03:58.040 --> 00:04:00.280
How do you get into programming in the first place?

00:04:00.280 --> 00:04:05.960
I think the first experience with programming I had was at university. So I studied math. I think

00:04:05.960 --> 00:04:07.080
like you as well.

00:04:07.080 --> 00:04:10.600
Yeah. Yeah. Yeah. That sounds really, yeah. Keep going. So far you're telling my story.

00:04:10.600 --> 00:04:16.280
Yeah, sure. Although my initial encounter with it, I didn't, I'm not quite particularly enjoyed it.

00:04:16.280 --> 00:04:21.960
It was just having to solve some problems in math lab. I did find it kind of satisfying that if you

00:04:21.960 --> 00:04:27.800
gave it instructions, it did exactly that. But I wouldn't say that I felt like naturally

00:04:27.800 --> 00:04:34.360
talented or anything. I then really took to programming though, after I started a maths PhD and

00:04:34.360 --> 00:04:39.000
dropped out because it wasn't really going anywhere. And once I went deeper into programming, then I

00:04:39.000 --> 00:04:44.360
realized, okay, actually I do have some affinity for this topic. I do quite enjoy it. Yeah. I think

00:04:44.360 --> 00:04:48.520
that's often the case. What was your PhD focus before you dropped out? It was meant to be,

00:04:48.520 --> 00:04:53.240
well, some applied mathematics like stochastic partial differential equations. But you know,

00:04:53.240 --> 00:04:59.480
in academia, you publish or perish. And I wasn't publishing and didn't really see that changing.

00:04:59.480 --> 00:05:01.880
So I had to make a bit of a pivot.

00:05:01.880 --> 00:05:06.920
I imagine you made a pretty good choice. Just guessing. I mean, I love math, but the options are

00:05:06.920 --> 00:05:12.360
just so much broader outside of academia. In hindsight, yeah, I kind of wish that somebody

00:05:12.360 --> 00:05:17.080
at the time had told me that I could have still had a really interesting and rewarding career outside

00:05:17.080 --> 00:05:22.520
of academia. And I shouldn't have stressed myself out so much about trying to find a PhD or about

00:05:22.520 --> 00:05:25.640
having to complete it when I had already started it.

00:05:25.640 --> 00:05:31.240
The secret, I think, about being a good programmer is it's kind of like grad school. Anyway,

00:05:31.240 --> 00:05:35.880
you're constantly studying and learning. You feel like you've figured something out. It's like,

00:05:35.880 --> 00:05:39.240
well, that's changed. Now onto the next thing. You're kind of like, well, we figured out pandas.

00:05:39.240 --> 00:05:42.360
Now we got pollers. Okay, well, we're going to start over and figure out how to use that well.

00:05:42.360 --> 00:05:47.560
Right. So that is true. You need to do a lot of learning, a lot of self-directed learning

00:05:47.560 --> 00:05:53.320
in particular. It's really stimulating, I must say. It is. It's great if you want that. If you want to

00:05:53.320 --> 00:05:57.880
just nine to five, you don't need to stress about... Well, look, I think there's actually options there.

00:05:57.880 --> 00:06:01.800
We'll get to Narwhals in a second. But I think there are options there. I think if you want to do

00:06:01.800 --> 00:06:08.440
COBOL, FORTRAN, some of these older programming languages where so much of the world depends on

00:06:08.440 --> 00:06:14.200
them, but nobody wants to do them. You could totally own that space and make really good money if you

00:06:14.200 --> 00:06:16.920
didn't want to learn anything. But where's the fun in that, right?

00:06:16.920 --> 00:06:19.160
Yeah. Yeah.

00:06:19.160 --> 00:06:22.200
It'd be nice if we could all get rid of our legacy systems, but you know,

00:06:22.200 --> 00:06:23.960
this stuff does power the world.

00:06:23.960 --> 00:06:29.080
They're there for a reason, right? That works. I would really like it if you don't touch it, please.

00:06:29.080 --> 00:06:37.160
But that's not the way it is with Narwhals. Let's start with an overview of what Narwhals is and

00:06:37.160 --> 00:06:41.080
why you created it. And then I want to talk a bit about some of the data science libraries

00:06:41.080 --> 00:06:46.280
before we get too much deeper. What is Narwhals? A Narwhal is a cool whale as far as I know. It's

00:06:46.280 --> 00:06:50.600
like the unicorn of the sea, basically. What is this library?

00:06:50.600 --> 00:06:51.800
Yeah, exactly.

00:06:51.800 --> 00:06:57.880
So it's intended as a compatibility layer between different data frame libraries. So Narwhals does

00:06:57.880 --> 00:07:05.160
not do any computation itself. It's more of just a wrapper around different data frame APIs. And I like

00:07:05.160 --> 00:07:10.760
the Polar's API. So I figured that I should keep it fairly close to the Polar's API and in particular,

00:07:10.760 --> 00:07:17.480
to Polar's expressions. As to why Narwhals? So I was just getting frustrated with the fact that

00:07:17.480 --> 00:07:24.760
let's say about a year ago, there were relatively few libraries that supported Polar's. And if libraries

00:07:24.760 --> 00:07:29.880
did support Polar's, it was often just done by converting to Pandas or converting to PyArrow.

00:07:30.520 --> 00:07:34.840
Yes, a lot of these libraries, they weren't doing anything that complicated with data frames.

00:07:34.840 --> 00:07:39.720
A lot of data frame consuming libraries, they don't really want to do that much. They want to select

00:07:39.720 --> 00:07:44.840
columns. They want to select rows. Maybe they want to do some aggregations. Like they're not doing

00:07:44.840 --> 00:07:51.560
stuff that's completely wild. And so trying to design some minimal compatibility layer, I think,

00:07:51.560 --> 00:07:57.880
is a lot easier than trying to make a full blown data frame API that end users are meant to use.

00:07:57.880 --> 00:08:03.560
So the idea with Narwhals is this is a tool for tool builders. If library maintainers want to support

00:08:03.560 --> 00:08:09.880
different data frame libraries as inputs with minimal overhead and with minimal maintenance required

00:08:09.880 --> 00:08:15.000
on their side, this is the problem we're trying to solve. It's a great problem to solve because

00:08:15.800 --> 00:08:21.880
maybe you want to have a library that works with an abstract concept of a data frame. But usually I

00:08:21.880 --> 00:08:26.360
would imagine you have to start out and say, are we going to go and support Polar's? Are we going to

00:08:26.360 --> 00:08:32.760
support Pandas? And the APIs are different, not just the APIs, but the behaviors, for example, the

00:08:32.760 --> 00:08:38.840
the lazy execution of Polar's versus the eager execution of Pandas. And so being able to just

00:08:38.840 --> 00:08:43.160
write your library so it takes you there is probably a big hassle, right? Because it's just

00:08:43.160 --> 00:08:46.440
you kind of have to have almost two versions each step, right?

00:08:46.440 --> 00:08:51.400
Yeah, exactly. Well, I actually heard from a maintainer recently who was saying that he was

00:08:51.400 --> 00:08:57.000
interested in using Narwhals even just to have Pandas as a dependency because Pandas,

00:08:57.000 --> 00:09:05.080
the API changes a bit between versions. And he was getting a bit tired of Pandas API changes and was

00:09:05.080 --> 00:09:11.800
like, okay, well, if we can just defer all of the version checks and API differences to an abstraction

00:09:11.800 --> 00:09:16.280
there that might even simplify our life, even if we're just interested in supporting Pandas.

00:09:16.280 --> 00:09:20.680
Yeah, that's cool. Yeah, actually, that's an interesting idea. It's just like, we'll have

00:09:20.680 --> 00:09:27.000
a compatibility layer just in case. And Pandas went from one to two on major version recently,

00:09:27.000 --> 00:09:30.600
which is a big deal and switched to PyArrow and all that, right?

00:09:30.600 --> 00:09:38.200
Yeah, so version two, it was sometime last year, I think, 2023. So yeah, the PyArrow,

00:09:38.200 --> 00:09:43.640
I think there were some misconceptions around that. So as we're live on air, let's take the chance to

00:09:43.640 --> 00:09:50.360
address some PyArrow misconceptions. PyArrow in Pandas currently is optional and it'll probably stay

00:09:50.360 --> 00:09:56.360
optional for quite a while. So there is some talk about in version three using PyArrow strings

00:09:56.360 --> 00:10:02.920
instead of the classical NumPy object strings. By default, if people have PyArrow installed,

00:10:02.920 --> 00:10:07.320
it's not totally decided. It's not totally set in stone whether PyArrow will be a required

00:10:07.320 --> 00:10:13.240
dependency and maybe Pandas version four will have it as a required dependency and it will be the

00:10:13.240 --> 00:10:15.960
default everywhere. But that's a few years away.

00:10:15.960 --> 00:10:22.360
Yeah, maybe. Maybe we'll get Python four as well. You never know. You know, it's interesting. I think

00:10:22.360 --> 00:10:28.760
the data science space more than many other areas has this ability to run Python in more places,

00:10:28.760 --> 00:10:35.160
right? For example, there's Pyodide, there's Jupyter Lite. There's a lot of more constrained

00:10:35.160 --> 00:10:40.120
environments that it might go in. And I don't know what the story with PyArrow and WASM and all

00:10:40.120 --> 00:10:44.760
these different things. You still get benefits there. But there's a lot to consider.

00:10:44.760 --> 00:10:50.200
Yeah, totally. And I think that's one reason why some library maintainers are really drawn to a

00:10:50.200 --> 00:10:56.040
lightweight compatibility layer like narwhals. With narwhals, you say you don't need any dependencies.

00:10:56.040 --> 00:10:59.960
You need narwhals, but that's just a bunch of Python files. Like if you wanted to, you could even

00:10:59.960 --> 00:11:05.880
just vendor narwhals. Like it's not that big of a deal, but there's no extra dependencies required.

00:11:05.880 --> 00:11:10.840
Like pandas users don't need polas installed and polas users don't need pandas installed. So if

00:11:10.840 --> 00:11:18.520
you're trying to deploy to a constrained environment where package size is limited, like if a library

00:11:18.520 --> 00:11:24.520
has narwhals as a required dependency, as opposed to any big data frame library, and then the user can

00:11:24.520 --> 00:11:29.800
just bring their own data frame, then like this, we're really minimizing the number of installation and

00:11:29.800 --> 00:11:34.600
dependency hell issues that people might run into. I think you've covered dependency hell on the show

00:11:34.600 --> 00:11:35.560
a few times before.

00:11:35.560 --> 00:11:41.000
Yeah, indeed. I think one thing that's interesting for people out there listening,

00:11:41.000 --> 00:11:45.480
we'll talk about the different libraries that it works with right now. But if you have a library

00:11:45.480 --> 00:11:50.280
out there and you're listening, there's not too much work to integrate it into or make it

00:11:50.280 --> 00:11:56.200
narwhal compatible, narwhalification of a library to let it do this interchange, right?

00:11:56.200 --> 00:12:01.160
So I think I can interpret your question in a couple of ways. So I'll just play them back and

00:12:01.160 --> 00:12:02.120
let's just see.

00:12:02.120 --> 00:12:03.080
Let's do it.

00:12:04.040 --> 00:12:06.380
if you're a library that consumes data frames.

00:12:06.380 --> 00:12:08.740
So yeah, there's some examples there on the readme

00:12:08.740 --> 00:12:12.960
of who's adopted narwhals, so like Altair is the most recent.

00:12:12.960 --> 00:12:13.800
- Right.

00:12:13.800 --> 00:12:14.660
- Probably the most famous one.

00:12:14.660 --> 00:12:17.400
- I think that's what I heard of it was when I was,

00:12:17.400 --> 00:12:19.980
some news about Altair and narwhals together

00:12:19.980 --> 00:12:21.600
is actually how I heard of narwhals.

00:12:21.600 --> 00:12:22.420
- Oh, okay, yeah.

00:12:22.420 --> 00:12:26.560
So yeah, and how complicated that is really depends

00:12:26.560 --> 00:12:29.600
on how complicated the data frame operations

00:12:29.600 --> 00:12:30.820
this library is doing.

00:12:30.820 --> 00:12:32.840
In the case of Altair, they weren't doing anything

00:12:32.840 --> 00:12:34.020
that was that crazy.

00:12:34.020 --> 00:12:37.780
They needed to inspect the data types, select some columns,

00:12:37.780 --> 00:12:41.020
convert date times to strings,

00:12:41.020 --> 00:12:44.620
get the unique categories out of categoricals.

00:12:44.620 --> 00:12:46.820
Like it wasn't that bad.

00:12:46.820 --> 00:12:50.200
So I think within a few weeks we were able to do it.

00:12:50.200 --> 00:12:52.260
Same story with scikit-lego.

00:12:52.260 --> 00:12:54.020
There's some other libraries that have reached out

00:12:54.020 --> 00:12:56.780
that have shown interest where it's going to be

00:12:56.780 --> 00:13:01.220
a bit of a heavier lift, but it's generally not as bad

00:13:01.220 --> 00:13:04.000
as I thought it was going to be when I started the project.

00:13:04.000 --> 00:13:07.760
- The other side of, yeah, the other way that I think I might have interpreted your question is

00:13:07.760 --> 00:13:11.000
how difficult is it for a new data frame library to become narwhals compatible?

00:13:11.000 --> 00:13:11.500
- Yes.

00:13:11.500 --> 00:13:14.760
- And there's a couple of ways that they can go about doing that.

00:13:14.760 --> 00:13:18.520
And the other side of the thing is that they can go about.

00:13:18.520 --> 00:13:22.280
adding their library as a backend in narwhals.

00:13:22.280 --> 00:13:27.040
- We love open source, but I don't consider myself an open source absolutist.

00:13:27.040 --> 00:13:29.280
I understand that not everything can be open sourced.

00:13:29.280 --> 00:13:34.620
And so if somebody has a closed source solution, we do have an extensibility mechanism within

00:13:34.620 --> 00:13:38.040
narwhals such that somebody just needs to implement some Dunder methods.

00:13:38.040 --> 00:13:43.040
- And then if they pass the data frame into a library that's been narwhalified, then narwhals

00:13:43.040 --> 00:13:47.040
will know how to glue things together and they'll be able to still support this closed source

00:13:47.040 --> 00:13:50.040
solution without it needing to go out into the open.

00:13:50.040 --> 00:13:51.040
- Right.

00:13:51.040 --> 00:13:56.040
It's kind of something like inheriting from a class and implementing some functions and

00:13:56.040 --> 00:13:57.040
then it, it knows, right?

00:13:57.040 --> 00:13:58.040
- Yeah, exactly.

00:13:58.040 --> 00:13:59.040
- Yeah.

00:13:59.040 --> 00:14:00.040
Yeah.

00:14:00.040 --> 00:14:01.040
Cool.

00:14:01.040 --> 00:14:04.040
So right now it has full API support for CUDAF, C U D F.

00:14:04.040 --> 00:14:07.040
I'm guessing that's CUDA data frame library.

00:14:07.040 --> 00:14:08.040
- Yeah.

00:14:08.040 --> 00:14:10.040
I'm not totally sure how we're supposed to pronounce it.

00:14:10.040 --> 00:14:11.040
I call it.

00:14:11.040 --> 00:14:12.040
- I don't know.

00:14:12.040 --> 00:14:13.040
- Yeah.

00:14:13.040 --> 00:14:14.040
That came out of the rapid steam at NVIDIA.

00:14:14.040 --> 00:14:17.040
It's like an accelerated version of pandas on, on GPU.

00:14:17.040 --> 00:14:18.040
Yeah.

00:14:18.040 --> 00:14:19.040
That's been quite a fun one.

00:14:19.040 --> 00:14:20.040
- Nice.

00:14:20.040 --> 00:14:21.040
- Yeah.

00:14:21.040 --> 00:14:22.040
That's pretty wild.

00:14:22.040 --> 00:14:23.040
- Yeah.

00:14:23.040 --> 00:14:24.040
- Then.

00:14:24.040 --> 00:14:26.040
- The API is quite similar to pandas, but it's not exactly the same.

00:14:26.040 --> 00:14:28.040
So we have to do a bit of working around.

00:14:28.040 --> 00:14:29.040
- Right, right.

00:14:29.040 --> 00:14:33.040
Because graphics cards are not just regular memory and regular programs.

00:14:33.040 --> 00:14:34.040
They're, they're weird, right?

00:14:34.040 --> 00:14:36.040
- That, yeah, that's part of it.

00:14:36.040 --> 00:14:39.040
So there's some parts of the pandas API, which they intentionally don't support.

00:14:39.040 --> 00:14:44.040
And there's another part of it is just that the pandas API is so extensive.

00:14:44.040 --> 00:14:46.040
That's, it's just a question of resources.

00:14:46.040 --> 00:14:49.040
Like it's pretty difficult to reimplement 100% of the pandas API.

00:14:49.040 --> 00:14:52.040
Um, but modern does attempt to do that.

00:14:52.040 --> 00:14:56.040
Modern does, tell itself as a drop in replacement for pandas.

00:14:56.040 --> 00:15:01.040
Uh, in practice, they do have a, I think they do have a section in their docs where they

00:15:01.040 --> 00:15:06.040
do mention some gotchas, some slight differences, but that's the idea.

00:15:06.040 --> 00:15:11.040
They've kind of got their, their, in their own intermediate representation, which they've got

00:15:11.040 --> 00:15:17.040
their algebra, which they've published a paper about, which they then map onto the pandas API.

00:15:17.040 --> 00:15:18.040
A pretty interesting project.

00:15:18.040 --> 00:15:20.040
That was a lot easier to support.

00:15:20.040 --> 00:15:23.040
Uh, the way they mimic the pandas API is a lot closer.

00:15:23.040 --> 00:15:24.040
Uh, but it's been interesting.

00:15:24.040 --> 00:15:28.040
Like with novels, we, we did find a couple of minor bugs in Modin just by running our test

00:15:28.040 --> 00:15:32.040
suite through the different libraries, which we then reported to them and they fixed very

00:15:32.040 --> 00:15:33.040
quickly.

00:15:33.040 --> 00:15:34.040
That's pretty awesome.

00:15:34.040 --> 00:15:35.040
Yeah.

00:15:36.040 --> 00:15:37.040
That's super awesome.

00:15:37.040 --> 00:15:50.040
So I was going to ask about things like Dask and, and others, which are sort of themselves

00:15:50.040 --> 00:15:52.040
extensions of Indes.

00:15:52.040 --> 00:15:57.040
But if you support Modin, you're kind of through one more layer supporting Dask and.

00:15:57.040 --> 00:15:58.040
Oh, but it's, it's better.

00:15:58.040 --> 00:16:00.040
We don't, yeah, it's better.

00:16:00.040 --> 00:16:04.040
We don't have this on the readme yet, but we do have a level of support for Dask.

00:16:04.040 --> 00:16:09.040
We've not quite, I've not quite put it on the readme yet because we're still kind of

00:16:09.040 --> 00:16:11.040
defining exactly where the boundaries are.

00:16:11.040 --> 00:16:17.040
Uh, but it's, it's going to be some kind of a partial lazy only layer of support.

00:16:17.040 --> 00:16:19.040
And it's actually quite a nice way to run Dask.

00:16:19.040 --> 00:16:23.040
Like when you're running Dask, there are some things which do trigger compute for you.

00:16:23.040 --> 00:16:26.040
There are some things which may trigger index repartitioning.

00:16:26.040 --> 00:16:28.040
I think that's what it's called.

00:16:28.040 --> 00:16:32.040
And in NowWals, we've just been extremely careful that if you're able to stick to the

00:16:32.040 --> 00:16:36.040
NowWals API, then what, what you're doing is going to be performant.

00:16:36.040 --> 00:16:37.040
Awesome.

00:16:37.040 --> 00:16:38.040
Yeah, that's super cool.

00:16:38.040 --> 00:16:44.040
So one thing I think worth maybe pointing out here is you talked about Pandas, Pandas 1, Pandas 2,

00:16:44.040 --> 00:16:46.040
and it being an extensive API.

00:16:46.040 --> 00:16:53.040
I mentioned the eager versus lazy computation, but these two, these two libraries are maybe some

00:16:53.040 --> 00:16:57.040
of the most popular ones, but they're pretty different in their philosophy.

00:16:57.040 --> 00:17:01.040
So maybe just, could you just quick compare and contrast Polars versus Pandas?

00:17:01.040 --> 00:17:02.040
Yeah, sure.

00:17:02.040 --> 00:17:04.040
Indirectly, Dask and so on.

00:17:04.040 --> 00:17:05.040
Yeah, sure.

00:17:05.040 --> 00:17:14.040
So, well, Pandas started a lot earlier, I think in 2008, maybe first released in 2009 and originally

00:17:14.040 --> 00:17:16.040
really written heavily around NumPy.

00:17:16.040 --> 00:17:21.040
you can see this in the classical Pandas NumPy data types.

00:17:21.040 --> 00:17:25.040
So the support for missing values is fairly inconsistent across types.

00:17:25.040 --> 00:17:27.040
So you brought up PyArrow before.

00:17:27.040 --> 00:17:32.040
So with the PyArrow data types, then we do get consistent missing value handling in Pandas.

00:17:32.040 --> 00:17:34.040
But for the classical NumPy ones, we don't.

00:17:34.040 --> 00:17:36.040
Polars started a lot later.

00:17:36.040 --> 00:17:42.040
There wasn't, it didn't have a lot of backwards compatibility concerns to have to worry about.

00:17:42.040 --> 00:17:45.040
So it could make a lot of good decisions upfront.

00:17:45.040 --> 00:17:47.040
It's generally a lot stricter than Pandas.

00:17:47.040 --> 00:17:55.040
And in particular, there's a lot of strictness and the kinds of ways it lets you interact with its objects.

00:17:55.040 --> 00:18:02.040
So in Pandas, the way we interact with data frames is we typically extract a series as one dimensional objects.

00:18:02.040 --> 00:18:04.040
We then manipulate those series.

00:18:04.040 --> 00:18:09.040
Maybe we put them back into the original data frame, but we're doing everything one step at a time.

00:18:09.040 --> 00:18:16.040
In Polars, the primary way that we interact with data frames is with what you've got there on the screen.

00:18:16.040 --> 00:18:19.040
A pl.col, a, b, these are called expressions.

00:18:19.040 --> 00:18:22.040
And that expression, my mental model for it is just a function.

00:18:22.040 --> 00:18:25.040
It's a function from a data frame to a series.

00:18:25.040 --> 00:18:26.040
And being a function...

00:18:26.040 --> 00:18:27.040
Almost like a generator or something, huh?

00:18:27.040 --> 00:18:28.040
Yeah, kind of, yeah.

00:18:28.040 --> 00:18:33.040
So although I think when you say generator, like in Python, a generator, it's at some point you can consume it.

00:18:33.040 --> 00:18:36.040
Like you can type next on the generator and it produces a value.

00:18:36.040 --> 00:18:38.040
But an expression doesn't produce a value.

00:18:38.040 --> 00:18:40.040
It's like if you've got lambda x, x times two.

00:18:40.040 --> 00:18:41.040
Yeah.

00:18:41.040 --> 00:18:44.040
It doesn't produce a value until you give it an input.

00:18:44.040 --> 00:18:49.040
And similarly, an expression like pl.col, a, b, by itself, it doesn't do anything.

00:18:49.040 --> 00:18:54.040
The interpretation is, given some data frame df, I'll return you the columns a and b.

00:18:54.040 --> 00:18:58.040
So it only produces those columns once you give it some input data frame.

00:18:58.040 --> 00:19:03.040
And functions, just by their very definition, are lazy, kind of.

00:19:03.040 --> 00:19:05.040
Like you don't need to evaluate them straight away.

00:19:05.040 --> 00:19:08.040
And so Polus can take a look at all of the things you want to do.

00:19:08.040 --> 00:19:11.040
It can recognize some optimization patterns.

00:19:11.040 --> 00:19:16.040
It can recognize that maybe between some of your expressions, there are some parts that are repeated.

00:19:16.040 --> 00:19:23.040
And so instead of having to recompute the same thing multiple times, it can just compute it once and then reuse that between the different expressions.

00:19:23.040 --> 00:19:32.040
Yeah, that's one of the big features of big capabilities of Polus is that it has kind of a query engine optimizer in there.

00:19:32.040 --> 00:19:36.040
Whereas pandas, because it's not lazy, it just does one thing, then the next, then the next.

00:19:36.040 --> 00:19:44.040
But maybe if you switch the order, like first filter and then compute versus compute and then filter, you might get a way better outcome, right?

00:19:44.040 --> 00:19:45.040
That's a massive one.

00:19:45.040 --> 00:19:46.040
Yeah.

00:19:46.040 --> 00:19:49.040
So when I was doing some benchmarking, we brought up QDF earlier.

00:19:49.040 --> 00:19:52.040
So that's the GPU accelerated version of pandas.

00:19:52.040 --> 00:19:57.040
And that is super fast if you're just doing single operations on a one at a time in a given order.

00:19:57.040 --> 00:20:05.040
However, there are some benchmarks where maybe you're having to join together multiple data frame, sorry, multiple data frames.

00:20:05.040 --> 00:20:06.040
And then you're only selecting certain rows.

00:20:06.040 --> 00:20:14.040
At that point, it's actually faster to just do it on a CPU using a lazy library like Polus, because Polus can do the query optimization.

00:20:14.040 --> 00:20:20.040
It can figure out that it needs to do the filter and only keep certain rows before doing five gigantic joins.

00:20:20.040 --> 00:20:25.040
Whereas QDF, it's super fast on GPU, but it is all eagerly executed.

00:20:25.040 --> 00:20:27.040
It did way more work, but it did it really fast.

00:20:27.040 --> 00:20:28.040
So it was about the same in the end.

00:20:28.040 --> 00:20:29.040
Yeah.

00:20:29.040 --> 00:20:36.040
But now in Polus, there's going to be GPU support and it's going to be query optimized GPU support.

00:20:36.040 --> 00:20:39.040
I don't know if the world is ready for this level of speed.

00:20:39.040 --> 00:20:42.040
Yeah, that's going to be interesting.

00:20:42.040 --> 00:20:46.040
This portion of Talk By The Named is brought to you by WorkOS.

00:20:46.040 --> 00:20:57.040
If you're building a B2B SaaS app, at some point, your customers will start asking for enterprise features like SAML authentication, skim provisioning, autologues, and fine grained authorization.

00:20:57.040 --> 00:21:06.040
That's where WorkOS comes in with easy to use APIs that will help you ship enterprise features on day one without slowing down your core product development.

00:21:06.040 --> 00:21:15.040
Today, some of the fastest growing startups in the world are powered by WorkOS, including ones you probably know like Perplexity, Vercel, and Webflow.

00:21:15.040 --> 00:21:24.040
WorkOS also provides a generous free tier of up to 1 million monthly active users for AuthKit, making it the perfect authentication layer for growing companies.

00:21:24.040 --> 00:21:30.040
It comes standard with useful features like RBAC, MFA, and bot protection.

00:21:30.040 --> 00:21:36.040
If you're currently looking to build SSO for your first enterprise customer, you should consider using WorkOS.

00:21:36.040 --> 00:21:40.040
Integrate in minutes and start shipping enterprise plans today.

00:21:40.040 --> 00:21:43.040
Just visit talkpython.fm/workos.

00:21:43.040 --> 00:21:45.040
The link is in your podcast player show notes.

00:21:45.040 --> 00:21:47.040
Thank you to WorkOS for supporting the show.

00:21:47.040 --> 00:21:57.040
I guess another difference is not a massive, you know, in some ways it matters, some ways it doesn't, is Pandas is based on C extensions, right?

00:21:57.040 --> 00:22:00.040
I'm guessing if I remember right.

00:22:00.040 --> 00:22:07.040
And then Perlers is Rust and even took the .rs extension for their domain, which is really embracing it.

00:22:07.040 --> 00:22:14.040
But not that it really matters, you know, what your native layer is, if you're not working in that, right?

00:22:14.040 --> 00:22:18.040
Like most Python people don't work in C or Rust, but it's still interesting.

00:22:18.040 --> 00:22:26.040
Well, I think it, yeah, it is interesting, but also it can be useful for users to know this because Perlers has a really nice plugin system.

00:22:26.040 --> 00:22:31.040
So you can extend Polars with your own little expressions, which you can write in Rust.

00:22:31.040 --> 00:22:35.040
And the amount of Rust that you need to do this is really quite minimal.

00:22:35.040 --> 00:22:42.040
Like if you try to write these Polars plugins as if you were writing Python and then just use some LLM or something to guide you.

00:22:42.040 --> 00:22:49.040
I think realistically, most data scientists can solve 98% of their inefficient data frame usage by using Polars plugins.

00:22:49.040 --> 00:22:54.040
So having a nice, safe language that you can do this, it really makes a difference.

00:22:54.040 --> 00:22:58.040
I'm going to write it in Python and then I'm going to ask some LLM.

00:22:58.040 --> 00:23:01.040
Right now I'm using LLM Studio and I think Llama 3.

00:23:01.040 --> 00:23:05.040
Anyway, ask it, say, okay, write this in Rust for me.

00:23:05.040 --> 00:23:07.040
Write it as a Polars plugin.

00:23:07.040 --> 00:23:08.040
Here we go.

00:23:08.040 --> 00:23:09.040
All right.

00:23:09.040 --> 00:23:10.040
Yeah, exactly.

00:23:10.040 --> 00:23:11.040
I mean, it's crazy.

00:23:11.040 --> 00:23:12.040
It's this new world we live in.

00:23:12.040 --> 00:23:13.040
Yeah, yeah, totally.

00:23:13.040 --> 00:23:20.040
I mean, like the amount of Rust knowledge you need to take care of some of the complicated parts in Polars is really advanced.

00:23:20.040 --> 00:23:23.040
Really need to study for that and LLM isn't going to solve it for you.

00:23:23.040 --> 00:23:31.040
But the amount of Rust that you need to just make a plugin to solve some inefficient function, I think that's doable.

00:23:31.040 --> 00:23:32.040
Right. Yeah, exactly.

00:23:32.040 --> 00:23:40.040
It's very different to say we're going to just do this loop in this function call here versus there rather than I'm going to write a whole library in Rust or C or whatever.

00:23:40.040 --> 00:23:41.040
Exactly.

00:23:41.040 --> 00:23:42.040
Yeah.

00:23:42.040 --> 00:23:45.040
So there's a pretty different API between these.

00:23:45.040 --> 00:23:50.040
And in Narwhals, it looks like you've adopted the Rust API, right?

00:23:50.040 --> 00:23:51.040
A subset of it.

00:23:51.040 --> 00:23:52.040
Is that right?

00:23:52.040 --> 00:23:53.040
The Polars one.

00:23:53.040 --> 00:23:54.040
Yes, exactly.

00:23:54.040 --> 00:23:55.040
So I kind of figured.

00:23:55.040 --> 00:23:56.040
Yeah, yeah.

00:23:56.040 --> 00:23:57.040
That's what I mean.

00:23:57.040 --> 00:23:58.040
Yeah.

00:23:58.040 --> 00:23:59.040
The Polars one.

00:23:59.040 --> 00:24:00.040
Yeah.

00:24:00.040 --> 00:24:01.040
The Pandas API.

00:24:01.040 --> 00:24:06.040
But to be honest, I found that trying to translate the Pandas API to Polars was fairly painful.

00:24:06.040 --> 00:24:12.040
Like, Pandas has a bunch of extra things like the index, the multi-index, and it does index alignment on all the operations.

00:24:12.040 --> 00:24:18.040
I just found it not a particularly pleasant experience to try to map this onto Pandas.

00:24:18.040 --> 00:24:25.040
However, when I tried to do the reverse of translating the Polars API to Pandas, it kind of just worked without that much effort.

00:24:25.040 --> 00:24:26.040
And I was like, oh, wow, this is magic.

00:24:26.040 --> 00:24:28.040
Okay, let's just take this a bit further.

00:24:28.040 --> 00:24:29.040
Publish it on GitHub.

00:24:29.040 --> 00:24:31.040
Maybe somebody would find a use case for it.

00:24:31.040 --> 00:24:32.040
I don't know.

00:24:32.040 --> 00:24:33.040
Yeah, that's great.

00:24:33.040 --> 00:24:34.040
Out in the audience.

00:24:34.040 --> 00:24:38.040
ZigZackJack asks, how is Narwhals different from IBIS?

00:24:38.040 --> 00:24:39.040
All right.

00:24:39.040 --> 00:24:41.040
The number one most common question.

00:24:41.040 --> 00:24:42.040
Love this.

00:24:42.040 --> 00:24:43.040
Is it?

00:24:43.040 --> 00:24:44.040
Okay, great.

00:24:44.040 --> 00:24:45.040
Yeah.

00:24:45.040 --> 00:24:48.040
I'll give you a little bit of context for the listeners on what is IBIS.

00:24:48.040 --> 00:24:52.040
So IBIS, yes, you can see there on the screen, they describe themselves as the portable data frame library.

00:24:52.040 --> 00:24:58.040
So IBIS is really aiming to be a data frame library, just like Pandas, just like Polars.

00:24:58.040 --> 00:25:02.040
But it's got this API, which can then dispatch to different backends.

00:25:02.040 --> 00:25:08.040
The default one is DuckDB, which is a really powerful embedded analytics database.

00:25:08.040 --> 00:25:09.040
I think you covered it on the show.

00:25:09.040 --> 00:25:13.040
In fact, I think I might have first heard about DuckDB on Python bytes.

00:25:13.040 --> 00:25:18.040
So listeners, if you want to stay up to date, subscribe to Python bytes.

00:25:18.040 --> 00:25:19.040
Thank you.

00:25:19.040 --> 00:25:20.040
Yeah.

00:25:20.040 --> 00:25:21.040
One of the shows I almost never miss.

00:25:21.040 --> 00:25:27.040
So yeah, I think the primary difference between Narwhals and IBIS is the target audience.

00:25:27.040 --> 00:25:33.040
So with IBIS, they're really trying to be this full blown data frame that people can use to do their analyses.

00:25:33.040 --> 00:25:42.040
Whereas with Narwhals, I'm openly saying to end users, like if you're an end user, if you're a data scientist, if you're an ML engineer, if you're a data analyst, don't use Narwhals.

00:25:42.040 --> 00:25:45.040
Like, it's a tool for tool builders.

00:25:45.040 --> 00:25:55.040
Like, learn Polars, learn DuckDB, learn whatever the best tool is for your particular task, and learn it well, and master that, and do your analyses.

00:25:55.040 --> 00:26:11.040
On the other hand, if you're a tool builder, and you just need to do some simple operations with data frames, and you want to empower your, if you want to enable your users to use your tool, regardless of which library they're starting with, then Narwhals can provide a nice bridge between them.

00:26:11.040 --> 00:26:12.040
Interesting.

00:26:12.040 --> 00:26:16.040
Is there any interoperability between IBIS and Narwhals?

00:26:16.040 --> 00:26:17.040
Narwhals?

00:26:17.040 --> 00:26:19.040
We do have some level of support for IBIS.

00:26:19.040 --> 00:26:30.040
And at the moment, this is just interchange level support, in the sense that if you pass a IBIS data frame, then you can inspect the schema, not do much else.

00:26:30.040 --> 00:26:33.040
But for the Altair use case, that's all they needed.

00:26:33.040 --> 00:26:39.040
Like, they just wanted to inspect the schema, make some decisions on how to encode some different columns.

00:26:39.040 --> 00:26:46.040
And then, depending on how long your data frame is, they might convert to PyArrow and dispatch to a different library called VegaFusion.

00:26:46.040 --> 00:26:49.040
Or they might just do everything within Altair.

00:26:49.040 --> 00:27:04.040
But we found that even just having this relatively minimal level of support for IBIS, Vax, DuckDB, and anything else, anything that implements the data frame interchange protocol was enough to already solve some problems for users of these libraries.

00:27:04.040 --> 00:27:05.040
Yeah.

00:27:05.040 --> 00:27:06.040
Okay.

00:27:06.040 --> 00:27:07.040
Very interesting.

00:27:07.040 --> 00:27:08.040
Let's see.

00:27:08.040 --> 00:27:10.040
We'll hit a few more of the highlights here.

00:27:10.040 --> 00:27:12.040
100% test coverage.

00:27:12.040 --> 00:27:17.040
You already mentioned that you found some bugs in which library was it?

00:27:17.040 --> 00:27:18.040
Modian.

00:27:18.040 --> 00:27:19.040
Yeah, yeah, that's right.

00:27:19.040 --> 00:27:20.040
I think all of them.

00:27:20.040 --> 00:27:26.040
I think it's helps uncover some rough edge cases in all of the libraries that we have some support for.

00:27:26.040 --> 00:27:29.040
You write a library and you're going to say, I'm going to try to behave like you do.

00:27:29.040 --> 00:27:31.040
And I'll write some tests around that.

00:27:31.040 --> 00:27:34.040
And then when you find the differences, you're like, wait a minute, right?

00:27:34.040 --> 00:27:35.040
Yeah, exactly.

00:27:35.040 --> 00:27:40.040
Also really love to see the let your IDE help you thanks to static typing.

00:27:40.040 --> 00:27:43.040
We'll definitely have to dive into that in a bit as well.

00:27:43.040 --> 00:27:44.040
That looks awesome.

00:27:44.040 --> 00:27:44.040
Cheers.

00:27:44.040 --> 00:27:46.040
Yeah, huge fan of static typing.

00:27:46.040 --> 00:27:48.040
You know, it's a bit of a controversial topic in some Python circles.

00:27:48.040 --> 00:27:54.040
Some people say that it's not really what Python is meant for and that it doesn't help you prevent bugs and all of that.

00:27:54.040 --> 00:27:56.040
And I can see where these people are coming from.

00:27:56.040 --> 00:28:06.040
But when I've got a statically typed library and my IDE is just always popping up with helpful suggestions and doc strings and all of that, then that's when I really appreciate it.

00:28:06.040 --> 00:28:07.040
Exactly.

00:28:07.040 --> 00:28:08.040
Like, forget the bugs.

00:28:08.040 --> 00:28:15.040
If I don't have to go to the documentation because I hit dot and it's immediately obvious what I'm supposed to do, that's already a win.

00:28:15.040 --> 00:28:16.040
Right.

00:28:16.040 --> 00:28:17.040
And that's typing gives you that.

00:28:17.040 --> 00:28:18.040
Plus it gives you checking.

00:28:18.040 --> 00:28:19.040
Plus it gives you lots of other things.

00:28:19.040 --> 00:28:20.040
I think it's great.

00:28:20.040 --> 00:28:25.040
And especially with your focus on tool builders, tool builders can build tools which have typing.

00:28:25.040 --> 00:28:29.040
They can build better tools using your typing, but they don't because it's optional.

00:28:29.040 --> 00:28:32.040
It's not really forced upon any of the users.

00:28:32.040 --> 00:28:44.040
The only libraries that I can think of that really force typing on their users is Pydantic and FastAPI and a couple of these that like Typer that have behavior driven on the types you put.

00:28:44.040 --> 00:28:48.040
But if you're using that library, you're choosing that as a feature, not a bug.

00:28:48.040 --> 00:28:49.040
Right.

00:28:49.040 --> 00:28:50.040
Yeah, exactly.

00:28:50.040 --> 00:28:50.040
Yeah.

00:28:50.040 --> 00:28:51.040
So awesome.

00:28:51.040 --> 00:28:52.040
Awesome.

00:28:52.040 --> 00:28:57.040
And then finally, sticking with the focus on tool builders, perfect backwards compatibility policy.

00:28:57.040 --> 00:28:58.040
What does this mean?

00:28:58.040 --> 00:29:00.040
This is a bit of an ambitious thing.

00:29:00.040 --> 00:29:04.040
So when I was learning Rust, I read about Rust editions.

00:29:04.040 --> 00:29:11.040
So the idea is that when you start a Rust project, you specify the edition of Rust that you want to use.

00:29:11.040 --> 00:29:21.040
And even as Rust gets updated, if you write some project using the 2015 edition of Rust, then it should keep working essentially forever.

00:29:21.040 --> 00:29:22.040
So they keep this edition around.

00:29:22.040 --> 00:29:28.040
And if they have to make backwards incompatible changes, there's new editions like 2018, 2021 editions.

00:29:28.040 --> 00:29:30.040
So this is kind of what we're trying to do.

00:29:30.040 --> 00:29:34.040
Like the idea, the idea was, well, we're kind of mimicking the Polar's API.

00:29:34.040 --> 00:29:40.040
I think there was a bracket I opened earlier, which I might not have finished, which was that the third choice we had was to make an entirely new API.

00:29:40.040 --> 00:29:44.040
But I thought, well, better to give, to do something that people are somewhat familiar with.

00:29:44.040 --> 00:29:46.040
Yeah, I think that's a great choice.

00:29:46.040 --> 00:29:47.040
Yeah.

00:29:47.040 --> 00:29:50.040
When you go and write the code, half of the people will already know Polar's.

00:29:50.040 --> 00:29:52.040
And so they just keep doing that.

00:29:52.040 --> 00:29:54.040
You don't have to go, well, here's a third thing you have to learn, right?

00:29:54.040 --> 00:29:55.040
Yeah.

00:29:55.040 --> 00:29:59.040
I'd like to think that now half people know Polar's.

00:29:59.040 --> 00:30:03.040
Unfortunately, I think we might not quite be there yet, but it is growing.

00:30:03.040 --> 00:30:04.040
No, I think so too.

00:30:04.040 --> 00:30:05.040
Yeah.

00:30:05.040 --> 00:30:06.040
I think we'll get there.

00:30:06.040 --> 00:30:07.040
So yeah, it's okay.

00:30:07.040 --> 00:30:13.040
We're kind of mimicking a subset of the Polar's API and we're just sticking into fundamentals.

00:30:13.040 --> 00:30:19.040
So that part should be relatively stable, but at some point, presumably Polar's is going to make a backwards incompatible change.

00:30:19.040 --> 00:30:22.040
And at that point, what do we do in Narwhals?

00:30:22.040 --> 00:30:24.040
What do we do about the top level Narwhals API?

00:30:24.040 --> 00:30:30.040
And coordinating changes between different libraries, it's going to get tricky.

00:30:30.040 --> 00:30:35.040
And the last thing that I want to do is see people put upper bound constraints on the Narwhals library.

00:30:35.040 --> 00:30:40.040
I think upper bound constraints on something like this should never really be necessary.

00:30:40.040 --> 00:30:44.040
So we've tried to replicate what Rust does with its additions.

00:30:44.040 --> 00:30:47.040
The idea is that we've got a stable V1 API.

00:30:47.040 --> 00:30:52.040
We will have a stable V2 API at some point if we need to make backwards incompatible changes.

00:30:52.040 --> 00:31:09.040
But if you write your code using the V1 stable Narwhals API, then even as new Narwhals versions come out, even as the main Narwhals namespace changes, even as we might introduce V2, then your code should in theory keep working.

00:31:09.040 --> 00:31:12.040
Like V1 should stay supported indefinitely.

00:31:12.040 --> 00:31:13.040
This is the intention.

00:31:13.040 --> 00:31:17.040
Yeah, you said see the stable API for how to opt in.

00:31:17.040 --> 00:31:21.040
So how do you, what, what, I'm just curious what the mechanism is.

00:31:21.040 --> 00:31:27.040
So for example, import Narwhals.stable.v1 as NW, which is the standard Narwhals support.

00:31:27.040 --> 00:31:28.040
Yeah, exactly.

00:31:28.040 --> 00:31:29.040
So instead of...

00:31:29.040 --> 00:31:35.040
Yeah, instead of import Narwhals as NW, you'll do import Narwhals.stable.v1 as NW.

00:31:35.040 --> 00:31:41.040
Yeah, I encourage people when they're just trying it out, prototyping, use import Narwhals as NW.

00:31:41.040 --> 00:31:47.040
If you want to make a release and future-proof yourself, then switch over to the stable.v1.

00:31:47.040 --> 00:32:01.040
This is a little similar to the API.talkpython.fm/v1/whatever versus, you know, where people encode a different version in their API endpoints, basically.

00:32:01.040 --> 00:32:02.040
Yeah, yeah.

00:32:02.040 --> 00:32:03.040
In import statements.

00:32:03.040 --> 00:32:04.040
I like it.

00:32:04.040 --> 00:32:05.040
Great.

00:32:05.040 --> 00:32:06.040
Yeah, let's see how this goes.

00:32:06.040 --> 00:32:07.040
Yeah, exactly.

00:32:07.040 --> 00:32:08.040
Now it's good.

00:32:08.040 --> 00:32:10.040
So just back to typing real quick.

00:32:10.040 --> 00:32:19.040
Pamphil Roy out there says, "A lot of open source maintainers complain about typing because if you want to make it really correct, it's painful to add."

00:32:19.040 --> 00:32:20.040
That can be true.

00:32:20.040 --> 00:32:24.040
And some, you know, the last 1% is some insane statement.

00:32:24.040 --> 00:32:26.040
But it's so helpful for end users.

00:32:26.040 --> 00:32:27.040
Yeah.

00:32:27.040 --> 00:32:28.040
True, yeah.

00:32:28.040 --> 00:32:30.040
You mentioned earlier that everyone seems to be at QuantSight.

00:32:30.040 --> 00:32:32.040
Do you know where I met Pamphil?

00:32:32.040 --> 00:32:33.040
At QuantSight?

00:32:33.040 --> 00:32:34.040
At QuantSight, yes.

00:32:34.040 --> 00:32:35.040
Amazing.

00:32:35.040 --> 00:32:36.040
See?

00:32:36.040 --> 00:32:37.040
It continues to happen.

00:32:37.040 --> 00:32:38.040
Yeah, exactly.

00:32:38.040 --> 00:32:43.040
But yeah, I think that totally sums it up for me as well.

00:32:43.040 --> 00:32:47.040
You know, it's really great to be using libraries that give you those options.

00:32:47.040 --> 00:32:56.040
You know, we do have the PYI files and we have TypeShed and all of that where people can kind of put typing on things from the outside that didn't want to support it.

00:32:56.040 --> 00:33:00.040
But if it's built in and part of the project, it's just better, you know?

00:33:00.040 --> 00:33:01.040
Yeah.

00:33:01.040 --> 00:33:02.040
If you have it from day one, it works well.

00:33:02.040 --> 00:33:08.040
I mean, trying to add types to a library that started without types like Pandas, it's fairly painful to be honest.

00:33:08.040 --> 00:33:09.040
I bet it is.

00:33:11.040 --> 00:33:12.040
Yeah, really cool.

00:33:12.040 --> 00:33:13.040
All right.

00:33:13.040 --> 00:33:16.040
Let's go and talk through, I guess, a quick shout out.

00:33:16.040 --> 00:33:21.040
Just last year I had Richie Vink, who's the creator of Polar's on Talk Python.

00:33:21.040 --> 00:33:26.040
If people want to check that out, they can certainly have a listen to that.

00:33:26.040 --> 00:33:33.040
I also just recently had Wes McKinney, the creator of Pandas on, and I'll link to those shows if people want to like dive into those.

00:33:33.040 --> 00:33:36.040
But let's talk a little bit through your documentation.

00:33:36.040 --> 00:33:37.040
It tells a really good story.

00:33:37.040 --> 00:33:43.040
I like what you put down here as, you know, it's not just here's your API and stuff, but it walks you through.

00:33:43.040 --> 00:33:50.040
So we talked about why obviously install, pip install, it's pure Python with a pure Python wheel, right?

00:33:50.040 --> 00:33:51.040
Yeah, exactly.

00:33:51.040 --> 00:33:53.040
Shouldn't be any issues with installation.

00:33:53.040 --> 00:33:54.040
Is it WASM compatible?

00:33:54.040 --> 00:33:55.040
Do you know?

00:33:55.040 --> 00:33:57.040
Like, could I use it on PyScript, Pyodide?

00:33:57.040 --> 00:33:58.040
I don't know.

00:33:58.040 --> 00:34:01.040
Are there any restrictions that they need?

00:34:01.040 --> 00:34:03.040
There's some restrictions.

00:34:03.040 --> 00:34:05.040
For example, I don't think you can do threading.

00:34:05.040 --> 00:34:14.040
I don't think you can use some of the common, which you don't have any dependencies, but some of the common third party HTTP clients, because it has to go through the browser's Ajax layer.

00:34:14.040 --> 00:34:17.040
There's some, but not terribly many restrictions.

00:34:17.040 --> 00:34:21.040
I'd imagine then that we would only be limited by whichever data frame people are passing in.

00:34:21.040 --> 00:34:22.040
Yeah.

00:34:22.040 --> 00:34:22.040
Yeah.

00:34:22.040 --> 00:34:23.040
Awesome.

00:34:23.040 --> 00:34:24.040
Okay.

00:34:24.040 --> 00:34:25.040
That's super nice.

00:34:25.040 --> 00:34:28.040
And maybe let's just talk through a quick example here.

00:34:28.040 --> 00:34:42.040
Keep it in mind that most people can't see any of the code, but let's just give them a sense still of what does it look like to write code that is interoperable with both or all these different libraries, these data frame libraries using narwhals.

00:34:42.040 --> 00:34:45.040
So maybe give us just an example.

00:34:45.040 --> 00:34:46.040
Sure.

00:34:46.040 --> 00:34:52.040
So the idea is what we can see on the screen is just a very simple example of a data frame agnostic function.

00:34:52.040 --> 00:34:57.040
We've got a function called my function, and this is something that users could maybe just use.

00:34:57.040 --> 00:35:01.040
Maybe it's something your library exposes, but the user doesn't need to know about narwhals.

00:35:01.040 --> 00:35:05.040
The narwhals only happens once you get inside the function.

00:35:05.040 --> 00:35:07.040
So the user passes in some data frame.

00:35:07.040 --> 00:35:11.040
We then call narwhals.fromNative on that data frame object.

00:35:11.040 --> 00:35:16.040
We do some operation and then we return some native object back to the user.

00:35:16.040 --> 00:35:19.040
Now the narwhals.fromNative, it's a practically free operation.

00:35:19.040 --> 00:35:21.040
It's not doing any data conversion.

00:35:21.040 --> 00:35:26.040
It's just instantiating some narwhals class that's backed by your original data frame.

00:35:26.040 --> 00:35:27.040
Right, right.

00:35:27.040 --> 00:35:38.040
And I imagine if it's Polar's data frame that gets passed in, it's probably a more direct pass through to the API than if you're doing operations on a Pandas data frame, right?

00:35:38.040 --> 00:35:42.040
Is there a difference of sort of runtime depending on the back end?

00:35:42.040 --> 00:35:45.040
The overhead is really low even for the Pandas case.

00:35:45.040 --> 00:35:55.040
In fact, sometimes things do get a little bit faster because of how careful we've been about avoiding index operations and unnecessary copies.

00:35:55.040 --> 00:36:01.040
To be honest, some of this will be alleviated in Pandas version 3 when copy on write becomes the default.

00:36:01.040 --> 00:36:03.040
Oh, that's interesting. Yeah.

00:36:03.040 --> 00:36:04.040
Yeah.

00:36:04.040 --> 00:36:08.040
In terms of the mapping on the implementation side, it's a bit easier to do the Polar's backend.

00:36:08.040 --> 00:36:17.040
But even then we do need to do some version checks like in 0.20.4, they renamed with row count to with row index, I think.

00:36:17.040 --> 00:36:20.040
And so, yeah, even there we do need some if-then statements.

00:36:20.040 --> 00:36:28.040
But like the end of the day, what the library does is there's a few extra function calls, a few checks on versions.

00:36:28.040 --> 00:36:30.040
It's not really doing that much.

00:36:30.040 --> 00:36:31.040
Yeah.

00:36:31.040 --> 00:36:35.040
Like you might experience an extra millisecond compared to running something natively at most.

00:36:35.040 --> 00:36:41.040
And usually you're using a data frame because you have some amount of data, even hundreds of rows.

00:36:41.040 --> 00:36:47.040
It's still most of the computation is going to end up there rather than if it's version this, call that, otherwise call this, right?

00:36:47.040 --> 00:36:50.040
That's not a lot of overhead, relatively speaking.

00:36:50.040 --> 00:36:51.040
I agree.

00:36:51.040 --> 00:36:52.040
Yeah.

00:36:52.040 --> 00:37:02.040
So, yeah, we see an example here of a data frame agnostic function, which just calculates some descriptive statistics from an input data frame using the expressions API, which we talked about earlier.

00:37:02.040 --> 00:37:03.040
Yeah.

00:37:03.040 --> 00:37:05.040
And here's something that I quite like about mkdocs.

00:37:05.040 --> 00:37:07.040
So you see where it says, let's try it out.

00:37:07.040 --> 00:37:13.040
We've got these different tabs and you can click on like polars, pandas, polars lazy.

00:37:13.040 --> 00:37:17.040
And then you can see in each case what it looks like from the user's point of view.

00:37:17.040 --> 00:37:20.040
And you can see, you can compare the outputs.

00:37:20.040 --> 00:37:24.040
So from the user's point of view, they're just passing their object to funk.

00:37:24.040 --> 00:37:28.040
What they're not seeing is that under the hood funk is using narwhals.

00:37:28.040 --> 00:37:31.040
But from their perspective, they put pandas in, they get pandas out.

00:37:31.040 --> 00:37:33.040
They put polars in, they get polars out.

00:37:33.040 --> 00:37:34.040
That's awesome.

00:37:34.040 --> 00:37:37.040
So we talked about the typing.

00:37:37.040 --> 00:37:41.040
And in this one, we have a DF typed as a frame T.

00:37:41.040 --> 00:37:45.040
Is that some sort of generic and it does it have restrictions on it?

00:37:45.040 --> 00:37:46.040
What is this frame T?

00:37:46.040 --> 00:37:49.040
I didn't dive into the source and check it out before.

00:37:49.040 --> 00:37:50.040
Sure.

00:37:50.040 --> 00:37:51.040
Yeah, it's a type.

00:37:51.040 --> 00:37:57.040
So it's just the idea that you start with a data frame of some kind and you get back some data frame of the same kind.

00:37:57.040 --> 00:38:02.040
Start with polars, get back polars, start with pandas, get back pandas and so on.

00:38:02.040 --> 00:38:08.040
And yeah, this version of the function is using the decorator nw.narwhalify.

00:38:08.040 --> 00:38:10.040
Narwhalify, it's a fantastic verb.

00:38:10.040 --> 00:38:17.040
So yeah, so there's two ways in which you can implement your function.

00:38:17.040 --> 00:38:26.040
You can do it the explicit way where that's in the quick start and the docs where you write your function that takes some frame, some native frame.

00:38:26.040 --> 00:38:30.040
And then you convert that to this narwhals one.

00:38:30.040 --> 00:38:32.040
You say from native, then you do your work.

00:38:32.040 --> 00:38:35.040
And then depending on, you could convert it back.

00:38:35.040 --> 00:38:38.040
Or in this case, it returns a list of strings in that example.

00:38:38.040 --> 00:38:47.040
Or you can skip the first and the last step and just put this decorator on it and it'll convert it to or wait, convert it from and then convert it to on the way in and out, right?

00:38:47.040 --> 00:38:48.040
Yeah, exactly.

00:38:48.040 --> 00:38:57.040
So if you're really strict about type annotations, then using from native and to native gives you a little bit of extra information.

00:38:57.040 --> 00:38:59.040
But I think narwhalify looks a little bit neater.

00:38:59.040 --> 00:39:00.040
Yeah, that's true.

00:39:00.040 --> 00:39:09.040
So for example, in the first one, you could say that this is actually a pandas data frame because you're writing the code or something like that.

00:39:09.040 --> 00:39:10.040
I don't know.

00:39:10.040 --> 00:39:13.040
So by into frame, this is the type on this first example.

00:39:13.040 --> 00:39:20.040
Yeah, by into frame, we mean something that can be converted into a narwhals data frame or lazy frame.

00:39:20.040 --> 00:39:22.040
How do you implement that in the type system?

00:39:22.040 --> 00:39:25.040
Is it a protocol or what is this?

00:39:25.040 --> 00:39:27.040
Yeah, we've got a protocol.

00:39:27.040 --> 00:39:31.040
So I just found some methods that these libraries have in common.

00:39:31.040 --> 00:39:32.040
Exactly.

00:39:32.040 --> 00:39:34.040
Yeah, if you can find that.

00:39:34.040 --> 00:39:35.040
That's what I was thinking.

00:39:35.040 --> 00:39:36.040
Yeah.

00:39:36.040 --> 00:39:42.040
Yeah, but if it has enough of the functions of pandas or pollers, you're like, all right, this is probably good.

00:39:42.040 --> 00:39:43.040
All right.

00:39:43.040 --> 00:39:44.040
And you can say it's one of these.

00:39:44.040 --> 00:39:45.040
That's pretty cool.

00:39:45.040 --> 00:39:46.040
Yeah, exactly.

00:39:46.040 --> 00:39:51.040
I mean, if any of this is confusing to listeners, we do have a page there in the documentation that's all about typing.

00:39:51.040 --> 00:39:54.040
So you can read through that at their own leisure.

00:39:54.040 --> 00:39:55.040
Yeah, for sure.

00:39:55.040 --> 00:39:56.040
All right.

00:39:56.040 --> 00:39:57.040
Let's see.

00:39:57.040 --> 00:40:00.040
I do like the mkdocs where you can have these different examples.

00:40:00.040 --> 00:40:08.040
One thing I noticed is you've got the pollers eager evaluation and you've got the pollers lazy evaluation.

00:40:08.040 --> 00:40:19.040
And when you have the pollers lazy, this function decorated with the decorator, the Nawalify decorator, it itself returns something that is lazy and you've got to call collect on.

00:40:19.040 --> 00:40:19.040
Right.

00:40:19.040 --> 00:40:21.040
So it kind of preserves the laziness, I guess.

00:40:21.040 --> 00:40:22.040
Is that right?

00:40:22.040 --> 00:40:23.040
Yes, exactly.

00:40:23.040 --> 00:40:30.040
This was something that was quite important to me, like not be something that's that only works well with eager execution.

00:40:30.040 --> 00:40:36.040
I want to have some level of support such that lazy in mean lazy out.

00:40:36.040 --> 00:40:37.040
Yeah.

00:40:37.040 --> 00:40:38.040
Eager in, eager out.

00:40:38.040 --> 00:40:39.040
Lazy in, lazy out.

00:40:39.040 --> 00:40:40.040
Okay.

00:40:40.040 --> 00:40:41.040
Exactly.

00:40:41.040 --> 00:40:42.040
Yeah.

00:40:42.040 --> 00:40:45.040
So the way you do that in pollers, you create a lazy frame versus data frame.

00:40:45.040 --> 00:40:46.040
Right.

00:40:46.040 --> 00:40:51.040
But then you've got to call collect on it, kind of like a weight in it and bit more async, which is cool.

00:40:51.040 --> 00:40:52.040
Yeah.

00:40:52.040 --> 00:40:55.040
Or don't call collect or just wait until you really need to call collect.

00:40:55.040 --> 00:40:56.040
Right.

00:40:56.040 --> 00:40:58.040
Or pass it on to the next one and on to the next.

00:40:58.040 --> 00:40:59.040
Yeah, exactly.

00:40:59.040 --> 00:41:00.040
Exactly.

00:41:00.040 --> 00:41:08.040
So one of the things that you talk about here is the pandas index, which is one of the key differences between pollers and pandas.

00:41:08.040 --> 00:41:12.040
And you've classified pandas people into two categories.

00:41:12.040 --> 00:41:17.040
Those who love the index and those who try to get rid of it and ignore it.

00:41:17.040 --> 00:41:18.040
Yeah, exactly.

00:41:18.040 --> 00:41:23.040
So if James Powell is listening, I think we can put him in the first category.

00:41:23.040 --> 00:41:30.040
I think most, realistically, most pandas users that I've seen call dot reset index drop equals true every other line of code.

00:41:30.040 --> 00:41:35.040
They just find that the index gets in the way more than helps them most of the time.

00:41:35.040 --> 00:41:38.040
And with novels, we're trying to accommodate both.

00:41:38.040 --> 00:41:41.040
So we don't do automated index alignment.

00:41:41.040 --> 00:41:43.040
So this isn't something that you have to worry about.

00:41:43.040 --> 00:41:56.040
But if you are really bothered about index alignment, say, due to backwards compatibility concerns, then we do have some functions which allow you to do that, which would be no operations for other libraries.

00:41:56.040 --> 00:41:57.040
So that's a good thing.

00:41:57.040 --> 00:41:59.040
So this is the same thing that we're going to do with pandas.

00:41:59.040 --> 00:42:01.040
So I would say, oh, I'm going to do this.

00:42:01.040 --> 00:42:02.040
I would say that.

00:42:02.040 --> 00:42:03.040
But I would say that's a good thing.

00:42:03.040 --> 00:42:04.040
I would say that's a good thing.

00:42:04.040 --> 00:42:09.040
So this is an example in scikit-lego of where they were relying on pandas index alignment.

00:42:09.040 --> 00:42:12.040
And if you're trying to do these libraries, the data will just be passed through the idea.

00:42:12.040 --> 00:42:13.040
Right.

00:42:13.040 --> 00:42:14.040
So you said they're pandas-like.

00:42:14.040 --> 00:42:18.040
And pandas-like is actually a type in your type system, right?

00:42:18.040 --> 00:42:19.040
Did I see that?

00:42:19.040 --> 00:42:20.040
We've got, yeah, yeah.

00:42:20.040 --> 00:42:24.040
So we've got isPanda'slike dataframe function to tell.

00:42:24.040 --> 00:42:28.040
So by pandas-like, we mean pandasqdf modin.

00:42:28.040 --> 00:42:32.040
So the libraries that have an index and follow those kinds of rules.

00:42:32.040 --> 00:42:33.040
Yeah, yeah, that's really cool.

00:42:33.040 --> 00:42:39.040
Yeah, because at the end of the day, like the idea of writing completely dataframe agnostic code is a lot easier for new libraries.

00:42:39.040 --> 00:42:42.040
than for existing libraries that have backwards compatibility concerns.

00:42:42.040 --> 00:42:46.040
And we recognize that it might not be completely achievable.

00:42:46.040 --> 00:42:52.040
I think in all of the use cases where we've seen now it's adopted, they're doing most of it in a dataframe agnostic way.

00:42:52.040 --> 00:42:58.040
But they do have some parts of it where they're saying, okay, if this is a pandas dataframe, we've got some pandas-specific logic.

00:42:58.040 --> 00:43:01.040
And otherwise, let's go down the dataframe agnostic route.

00:43:01.040 --> 00:43:05.040
Yeah, you also have here levels of support.

00:43:05.040 --> 00:43:06.040
You have full and interchange.

00:43:06.040 --> 00:43:08.040
I think we talked about that a little bit.

00:43:08.040 --> 00:43:10.040
So maybe just point people here.

00:43:10.040 --> 00:43:15.040
But this is if you want to be qdf or modin, you can fully integrate.

00:43:15.040 --> 00:43:21.040
Or if you just want to have enough of an implementation that they can kind of work together, right?

00:43:21.040 --> 00:43:23.040
You can do this dataframe interchange protocol.

00:43:23.040 --> 00:43:24.040
Yeah, exactly.

00:43:24.040 --> 00:43:31.040
Or just write to us and we'd be happy to accommodate you without you having to go through the dataframe interchange protocol.

00:43:31.040 --> 00:43:32.040
Oh, yeah.

00:43:32.040 --> 00:43:33.040
Very nice.

00:43:33.040 --> 00:43:34.040
Okay.

00:43:34.040 --> 00:43:36.040
You mentioned the overhead before, but you do have a picture.

00:43:36.040 --> 00:43:37.040
Pictures are always fun.

00:43:37.040 --> 00:43:42.040
And in the picture, you've got little different operations, different times for each of the operations.

00:43:42.040 --> 00:43:47.040
And there's a quite small overhead for pandas versus pandas with narwhals.

00:43:47.040 --> 00:43:48.040
Yeah, exactly.

00:43:48.040 --> 00:43:51.040
Like in some of them, you can see it becoming a little bit faster.

00:43:51.040 --> 00:43:53.040
In some of them, you can see it becoming a little bit slower.

00:43:53.040 --> 00:43:54.040
Yeah.

00:43:54.040 --> 00:43:59.040
And these are queries that I think are the size that you can expect most data scientists to be working with a lot of the time.

00:43:59.040 --> 00:44:03.040
You've got queries that take between a couple of seconds to 30 seconds.

00:44:03.040 --> 00:44:08.040
And there, it's pretty hard to distinguish reliably between like the blue and red dots.

00:44:08.040 --> 00:44:11.040
Sometimes one's higher, sometimes the other one's higher.

00:44:11.040 --> 00:44:15.040
There's a bit of statistical variance just between running the same benchmark multiple times.

00:44:15.040 --> 00:44:18.040
But overall, yeah, we were pretty happy with these results.

00:44:18.040 --> 00:44:20.040
Yeah, that's great.

00:44:20.040 --> 00:44:23.040
So how well have we covered how it works?

00:44:23.040 --> 00:44:25.040
We talked about the API, but I don't know.

00:44:25.040 --> 00:44:32.040
We've talked about the implementation of how you actually, why is it basically almost the same speed?

00:44:32.040 --> 00:44:33.040
Are you not doing it?

00:44:33.040 --> 00:44:34.040
Why is it not going to work?

00:44:34.040 --> 00:44:35.040
Yeah.

00:44:35.040 --> 00:44:36.040
Well, maybe.

00:44:36.040 --> 00:44:37.040
Are you using underwater unicorn magic?

00:44:37.040 --> 00:44:38.040
Is that what it is?

00:44:38.040 --> 00:44:39.040
Yes.

00:44:39.040 --> 00:44:40.040
That's the secret, yes.

00:44:40.040 --> 00:44:41.040
Underwater unicorn magic.

00:44:41.040 --> 00:44:45.040
Well, perhaps first I should just say why we wrote this, how it works.

00:44:45.040 --> 00:44:49.040
And it's because really I want this to be a community driven project.

00:44:49.040 --> 00:44:54.040
And this is one of those cases where open source is more of a social game than a technical one.

00:44:54.040 --> 00:44:55.040
I'm not saying that's always the case.

00:44:55.040 --> 00:44:58.040
There are many problems that are purely technical.

00:44:58.040 --> 00:45:00.040
narwhals is a social game in the end.

00:45:00.040 --> 00:45:06.040
Like what we're doing isn't that complicated, but if we want it to work, then it needs to be accessible to the community.

00:45:06.040 --> 00:45:08.040
People do need to be able to trust us.

00:45:08.040 --> 00:45:11.040
And that typically does not happen if it's a one person project.

00:45:11.040 --> 00:45:19.040
So it was really important to me that different people would be able to contribute to it, that it all be as simple and clear as possible.

00:45:19.040 --> 00:45:21.040
So made this page trying to explain how it works.

00:45:21.040 --> 00:45:25.040
It's not quite as clear and quite as extensive as it'd like to be.

00:45:25.040 --> 00:45:28.040
But a few contributors did say that it really helped them.

00:45:28.040 --> 00:45:31.040
So in terms of how do we get this slow overhead?

00:45:31.040 --> 00:45:39.040
So we're just defining an expression as being a function from a data frame, your sequence of series, and then we're just repeatedly and strictly applying that definition.

00:45:39.040 --> 00:45:41.040
So there's nothing too fancy going on.

00:45:41.040 --> 00:45:49.040
That's like in the end, just evaluating Lambda functions in Python, going down the stack trace like it's pretty fast.

00:45:49.040 --> 00:45:50.040
Yeah, that's really cool.

00:45:50.040 --> 00:45:51.040
Yeah.

00:45:51.040 --> 00:45:52.040
So people can check this out.

00:45:52.040 --> 00:45:55.040
They want to know that's I think this might be where I saw the pandas like expression.

00:45:55.040 --> 00:45:56.040
Right.

00:45:56.040 --> 00:45:57.040
Yeah.

00:45:57.040 --> 00:46:02.040
Pandas like it's this class that encompasses your pandas mode in QDR, the ones that kind of follow the pandas API.

00:46:02.040 --> 00:46:03.040
Mm-hmm.

00:46:03.040 --> 00:46:04.040
Yeah.

00:46:04.040 --> 00:46:05.040
Close enough for what you need to do.

00:46:05.040 --> 00:46:06.040
Yeah, exactly.

00:46:06.040 --> 00:46:07.040
All right.

00:46:07.040 --> 00:46:14.040
Well, I saw a question out there in the audience somewhere from Francesco, which was basically asking about the roadmap.

00:46:14.040 --> 00:46:15.040
Like, where are you?

00:46:15.040 --> 00:46:16.040
Where are you going?

00:46:16.040 --> 00:46:18.040
Yeah, I should probably introduce Francesco.

00:46:18.040 --> 00:46:22.040
He's one of the most active contributors to the project.

00:46:22.040 --> 00:46:26.040
So thanks, Francesco, for helping to make it a success.

00:46:26.040 --> 00:46:31.040
He was actually also the first person to adopt in one of his libraries.

00:46:31.040 --> 00:46:37.040
Yeah, I spoke to him about it at a conference and he was like, I've got this tiny little time based CV library.

00:46:37.040 --> 00:46:39.040
Let's try now qualifying it as an experiment.

00:46:39.040 --> 00:46:41.040
Sure, we did that then.

00:46:41.040 --> 00:46:42.040
That's right.

00:46:42.040 --> 00:46:44.040
Not scikit-learn, sorry.

00:46:44.040 --> 00:46:45.040
Not scikit-lego.

00:46:45.040 --> 00:46:50.040
It was this kind of experimental building blocks for scikit-learn pipelines that he maintains.

00:46:50.040 --> 00:46:52.040
And then we've just been taking it from there.

00:46:52.040 --> 00:47:00.040
So in terms of roadmap, my top priority is helping out libraries that have shown interest in narwhals.

00:47:00.040 --> 00:47:08.040
So at the moment, Formulaic, that opened a draft pull request in which they were trying out narwhals and they tagged me just about some things they were missing.

00:47:08.040 --> 00:47:12.040
So I'd like to see if I can take that to completion.

00:47:12.040 --> 00:47:16.040
I think I've got most of it working, but just been a bit busy with conferences recently.

00:47:16.040 --> 00:47:21.040
So maybe next month I'll be able to get something ready for review and show that to them.

00:47:21.040 --> 00:47:23.040
That would be pretty cool.

00:47:23.040 --> 00:47:25.040
It's summer is passing.

00:47:25.040 --> 00:47:26.040
The conferences are ending.

00:47:26.040 --> 00:47:28.040
It's going to get dark and cold.

00:47:28.040 --> 00:47:29.040
Perfect time to program.

00:47:29.040 --> 00:47:36.040
Yeah, we'll get back to the situation that I was in when I started narwhals, which was that it was a rainy Friday.

00:47:36.040 --> 00:47:37.040
Not Friday, sorry.

00:47:37.040 --> 00:47:42.040
It was a rainy February weekend in Wales, the rainiest part of the UK.

00:47:42.040 --> 00:47:43.040
So, you know.

00:47:43.040 --> 00:47:45.040
Yeah, that's exactly the same in Oregon here.

00:47:45.040 --> 00:47:47.040
So it's a good time to get stuff done.

00:47:47.040 --> 00:47:48.040
Yeah, exactly.

00:47:48.040 --> 00:47:49.040
So, yeah.

00:47:49.040 --> 00:47:55.040
And then I've been speaking to people from Shiny and Plotly about potentially looking into narwhals.

00:47:55.040 --> 00:47:59.040
There's no contract set in stone or anything.

00:47:59.040 --> 00:48:02.040
These people may well change their mind if it doesn't work for them.

00:48:02.040 --> 00:48:04.040
But my idea is, okay, they've shown interest.

00:48:04.040 --> 00:48:10.040
Let's go head first into seeing whether we can help them and whether they'd be able to use narwhals.

00:48:10.040 --> 00:48:15.040
If it doesn't work out, we'll just have strengthened the narwhals API and learn some new things.

00:48:15.040 --> 00:48:18.040
If it does work, then great, exciting.

00:48:18.040 --> 00:48:20.040
So that's my top priority.

00:48:20.040 --> 00:48:25.040
And it's been really pleasing to see the contributed community develop around narwhals.

00:48:25.040 --> 00:48:28.040
I really thought it would be a one-person project for a long time.

00:48:28.040 --> 00:48:31.040
But so many people have been contributing really high-quality pull requests.

00:48:31.040 --> 00:48:34.040
It's really been, yeah, you see 42.

00:48:34.040 --> 00:48:35.040
Okay, one of them is this.

00:48:35.040 --> 00:48:38.040
Okay, maybe a couple of them here are like a GitHub bot.

00:48:38.040 --> 00:48:40.040
This pre-commit CI bot.

00:48:40.040 --> 00:48:41.040
Yeah.

00:48:41.040 --> 00:48:43.040
Maybe that's not counted as those.

00:48:43.040 --> 00:48:44.040
Maybe 40, 30, but still, that's a lot.

00:48:44.040 --> 00:48:47.040
While we're talking numbers on the homepage, I also want to point out,

00:48:47.040 --> 00:48:50.040
10 million downloads a month is a lot of downloads.

00:48:50.040 --> 00:48:51.040
That's awesome.

00:48:51.040 --> 00:48:58.040
Yeah, that's maybe slightly misleading because they pretty much just come from the fact that it's now a required dependency of Altair.

00:48:58.040 --> 00:49:00.040
And Altair gets millions of downloads.

00:49:00.040 --> 00:49:01.040
Yeah, yeah, yeah, exactly.

00:49:01.040 --> 00:49:04.040
But that's how, that's the place of some libraries.

00:49:04.040 --> 00:49:09.040
Like Berkzoyg, I don't think many people go, oh, let me go get this HTTP library or it's dangerous.

00:49:09.040 --> 00:49:11.040
They just go, I'll use Flask, right?

00:49:11.040 --> 00:49:19.040
But it's still a really important building block of the community, even if people don't seek it out as a top-level thing they use, right?

00:49:19.040 --> 00:49:20.040
Sure, cheers, thanks.

00:49:20.040 --> 00:49:20.040
Yeah.

00:49:20.040 --> 00:49:25.040
In fact, if we do our job well, then most people should never know about novels.

00:49:25.040 --> 00:49:26.040
Exactly.

00:49:26.040 --> 00:49:28.040
That tools should just use, just work.

00:49:28.040 --> 00:49:29.040
Sorry.

00:49:29.040 --> 00:49:30.040
Yeah, exactly.

00:49:30.040 --> 00:49:31.040
Yeah.

00:49:31.040 --> 00:49:42.040
So yeah, it's been really encouraging, really pleasing to see this contributor community emerge around the project.

00:49:42.040 --> 00:49:51.040
And I think a lot of the contributors are really interested in adding extra methods and adding extra backends and things.

00:49:51.040 --> 00:49:55.040
So I'm trying to leave a lot of that to the community.

00:49:55.040 --> 00:49:59.040
So like with Dask, I just got the rough building blocks together.

00:49:59.040 --> 00:50:07.040
And then it was just so nice, like so many really high quality contributions coming up that brought the Dask support pretty much complete.

00:50:07.040 --> 00:50:15.040
We should see now if we're able to execute all of the TPC-H queries with the Dask backend, we might actually be there or be pretty close to getting there.

00:50:15.040 --> 00:50:16.040
Nice.

00:50:16.040 --> 00:50:19.040
What does TPC-H stand for?

00:50:19.040 --> 00:50:29.040
I don't remember what it stands for, but it's a set of database queries that they were originally written for testing out different databases.

00:50:29.040 --> 00:50:44.040
So it's a bunch of SQL queries, but I'm not sure if it was Kaggle that popularized the idea of translating these SQL queries to data frame like APIs,

00:50:44.040 --> 00:50:49.040
and then running different data frames on them to see who wins the speed test.

00:50:49.040 --> 00:50:58.040
But we just figured they do a bunch of things like joins, concatenations, filtering, comparisons with dates, string operations.

00:50:58.040 --> 00:51:04.040
And we're like, okay, if the narwhals API is able to do all of this, then maybe it's extensive enough to be useful.

00:51:04.040 --> 00:51:11.040
Right. Yeah, yeah. That's super cool. It sounds a little bit like the TOB index plus other stuff maybe, but for databases.

00:51:11.040 --> 00:51:13.040
I'm not familiar with that.

00:51:13.040 --> 00:51:21.040
It's like a language ranking type of thing. And, you know, one aspect is maybe ranking the databases. But yeah, this is very cool. Okay, got it.

00:51:21.040 --> 00:51:22.040
Yeah.

00:51:22.040 --> 00:51:29.040
I mean, in the end, we're not trying to be fast as narwhals, but we just want to make sure that there's no extra overhead compared to running things natively.

00:51:29.040 --> 00:51:37.040
As long as you're not much slower than the stuff that you're operating with. Like, that's all you should ask for. You can't make it go faster in the extreme.

00:51:37.040 --> 00:51:41.040
Like you did talk about some optimizations, but you can't fundamentally change what's happening.

00:51:41.040 --> 00:51:50.040
Yeah, we could do some optimizations on the narwhals side. But to be honest, I'm not sure I want to. And part of the reason is because I want this to be a pretty simple project that's easy to maintain.

00:51:50.040 --> 00:51:51.040
Yeah, sure.

00:51:51.040 --> 00:51:53.040
That's really just low overhead.

00:51:53.040 --> 00:51:56.040
Add extra docs and tutorials coming. That's fun.

00:51:56.040 --> 00:51:56.040
Yeah.

00:51:56.040 --> 00:52:00.040
Looking for contributors and maybe want to write some tutorials or docs.

00:52:00.040 --> 00:52:08.040
I would love this. Yeah. I mean, it drives me crazy when I see so many projects where people have put so much effort into making a really good product, but then the documentation is really scant.

00:52:08.040 --> 00:52:17.040
Like if you don't prioritize writing good docs, nobody's going to use your product. So I was really grateful to my company.

00:52:17.040 --> 00:52:22.040
They had four interns come on who really helped out with making the docs look amazing.

00:52:22.040 --> 00:52:23.040
Oh, that's cool.

00:52:23.040 --> 00:52:32.040
Like if you look at the API reference, I think every single function now has got a, like a doc string with an example at the bottom.

00:52:32.040 --> 00:52:36.040
I think there's API reference. Yeah. If you search for any function in here, yeah.

00:52:36.040 --> 00:52:39.040
Yeah. In the search box at the top.

00:52:39.040 --> 00:52:40.040
I don't know. Series dot.

00:52:40.040 --> 00:52:41.040
Sure.

00:52:41.040 --> 00:52:43.040
Something easy for any of these.

00:52:43.040 --> 00:52:49.040
We've got like an example of, okay, here's how you could write a data frame agnostic function, which uses this, this method.

00:52:49.040 --> 00:52:53.040
And let's show that if you pass pandas or polars, you get the same result.

00:52:53.040 --> 00:53:01.040
And if there's some slight differences that we just cannot get around, like in the way that they handle missing values, then we've got a very clear note about in the docs.

00:53:01.040 --> 00:53:04.040
Yeah, that's great. Maybe, maybe someday support for DuckDB.

00:53:04.040 --> 00:53:10.040
I would like that. I don't think we have much of a choice about whether or not we support like DB.

00:53:10.040 --> 00:53:12.040
Like, like, DB is really on fire now.

00:53:12.040 --> 00:53:14.040
So it really is.

00:53:14.040 --> 00:53:26.040
Yeah, I think it's, it might be a question of either we have some level of support for DuckDB or somebody else is going to make something like novels that supports DuckDB and then we become extinct.

00:53:26.040 --> 00:53:35.040
But besides, like, to be honest, like, like, like, to be as amazing, I just find it a bit painful to write SQL strings.

00:53:35.040 --> 00:53:42.040
And so if I could use DuckDB, but with the Polar's API that I prefer and I'm more familiar with, then.

00:53:42.040 --> 00:53:51.040
Yeah, I 100% agree. It looks super nice. But if you look at it has a SQL example, and then the Python example is just SQL quote, quote, quote.

00:53:51.040 --> 00:53:52.040
Yeah, exactly.

00:53:52.040 --> 00:53:56.040
Here's the SQL embedded in Python, you know what I mean? So it's, it's, you're kind of writing SQL no matter what.

00:53:56.040 --> 00:54:05.040
Yeah, and then the error messages that you get sometimes are like, oh, there's a pass error near this keyword and you're like, what on earth is going on? Like, it's, and then you're like, oh, yeah, I forgot.

00:54:05.040 --> 00:54:08.040
I've got an extra comma at the end of my select or something. I don't know.

00:54:08.040 --> 00:54:09.040
Yeah. So this kind of thing.

00:54:09.040 --> 00:54:17.040
Yeah. So DuckDB. Yeah. So DuckDB is a little bit like SQL lite, but for analytics rather than relational, maybe. I'm not sure if that's a good scenario.

00:54:17.040 --> 00:54:32.040
I think it's primarily aimed at analysts. Yeah. Analytical kinds of things. Yeah. Data scientists and people. What I kind of, what we are going to struggle with is that in DuckDB, there's no guarantees about row order or operations.

00:54:32.040 --> 00:54:43.040
So, but on the plus side, when I look at what Altair are doing with data frames, when I look at some of the other libraries that I've shown interest in now, they're often just doing very simple things.

00:54:43.040 --> 00:54:51.040
They're not doing things that depend on row order. So if we could just initially just support DuckDB for the operations that don't require row order.

00:54:51.040 --> 00:54:57.040
So for something like a cumulative sum, maybe initially we just don't support that for DuckDB. Yeah.

00:54:57.040 --> 00:55:12.040
Like in the end, if you want to do advanced SQL, just use DuckDB directly. Like, as I said earlier, I don't recommend that end users use novels directly, but even just having some common operations, ones that aren't row order dependent.

00:55:12.040 --> 00:55:20.980
I'd like to think that this is already enough to solve some real problems for real people. Yeah. I know you said it's mostly for library builders, but if you were building an app and you

00:55:20.980 --> 00:55:31.980
were not committed to your data frame library or you really wanted to leave open the possibility of choosing a different data frame library, you know, sort of using narwhals to isolate that a little bit might be nice, right?

00:55:31.980 --> 00:55:50.920
Yeah. So yeah. Yeah. If anyone tries to do this and I'd love to hear your story. I did hear from somebody in our community call. We've got a community call every two weeks, by the way, if anyone wants to come and chat with us. I did hear from somebody that like at work has got some teams that are primarily using pandas.

00:55:50.920 --> 00:56:02.920
There's some teams that are primarily using polars and he just wanted to build some common logic that both teams could use. And he was using narwhals for that. So I think there are some use cases beyond just library maintainers.

00:56:02.920 --> 00:56:14.920
Yeah, absolutely. Maybe you're building just an internal library and it needs to work with some code you've written in pandas, but you maybe want to try your new project in polars, but you want to still use that library, right? That would be a cool use case as well.

00:56:14.920 --> 00:56:30.920
Yeah. Yeah. Yeah. Yeah. I'm pretty sure you've brought up on the show before that XKCD about like the space bar overheating. I can't remember which number that one is, but in the end with a lot of open source projects, you put it out with some intention of how it's meant to be used.

00:56:30.920 --> 00:56:34.920
Yes.

00:56:34.920 --> 00:56:49.460
Yeah. Yeah. It's a, it's a, it's a, it looks like something out of a, a, a change log with feedback or something that says changes in version 10.7. The CPU no longer overheats when you hold down the space for comments.

00:56:49.920 --> 00:57:05.200
Long time using four rights. This update broke my workflow. My control key is hard to reach. So I hold the space bar instead. And I configured Emacs to interpret a rapid temperature rise as control. That's horrifying. Look, my setup works for me. Just add an option to reenable space bar heating.

00:57:05.200 --> 00:57:09.540
I've seen it so many times, but it still makes me laugh each time.

00:57:09.540 --> 00:57:17.440
It's incredible. It's incredible. All right, Marco. Well, congrats on the cool library. Congrats on the traction. Final call to action. Maybe people want to start using narwhals. What do you tell them?

00:57:17.440 --> 00:57:31.460
Yeah. Give it a go and please join our discord and or our community calls. We're very friendly and open and would love to hear from you and see what we can do to address whatever limitations you might come up against.

00:57:44.960 --> 00:57:54.900
If you're using a B2B SaaS app at some point, your customers will start asking for enterprise features like SAML authentication, skim provisioning, audit logs, and fine-grained authorization.

00:57:54.900 --> 00:58:04.700
WorkOS helps ship enterprise features on day one without slowing down your core product development. Find out more at talkpython.fm/workOS.

00:58:04.700 --> 00:58:10.300
Want to level up your Python? We have one of the largest catalogs of Python video courses over at Talk Python.

00:58:10.300 --> 00:58:20.960
Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription in sight. Check it out for yourself at training.talkpython.fm.

00:58:20.960 --> 00:58:27.160
Be sure to subscribe to the show. Open your favorite podcast app and search for Python. We should be right at the top.

00:58:27.160 --> 00:58:36.520
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

00:58:36.940 --> 00:58:47.320
We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:58:47.320 --> 00:58:53.740
This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.

00:58:53.740 --> 00:59:23.720
We'll see you next time.

