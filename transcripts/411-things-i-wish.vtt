WEBVTT

00:00:00.000 --> 00:00:03.280
What advice would you give someone just getting into Python?


00:00:03.280 --> 00:00:07.680
What did you learn over time through hard work and a few tiers that would have really helped you?


00:00:07.680 --> 00:00:12.240
It's a fun game to play and we have Jason McDonald on the podcast to give us his take.


00:00:12.240 --> 00:00:18.480
This is Talk Python to Me, episode 411, recorded March 2nd, 2023.


00:00:18.480 --> 00:00:21.060
(upbeat music)


00:00:21.060 --> 00:00:32.680
- Welcome to Talk Python to Me,


00:00:32.680 --> 00:00:34.640
a weekly podcast on Python.


00:00:34.640 --> 00:00:36.400
This is your host, Michael Kennedy.


00:00:36.400 --> 00:00:38.760
Follow me on Mastodon, where I'm @mkennedy


00:00:38.760 --> 00:00:41.480
and follow the podcast using @talkpython,


00:00:41.480 --> 00:00:43.720
both on fosstodon.org.


00:00:43.720 --> 00:00:46.360
Be careful with impersonating accounts on other instances,


00:00:46.360 --> 00:00:47.560
there are many.


00:00:47.560 --> 00:00:53.120
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.


00:00:53.120 --> 00:00:56.560
We've started streaming most of our episodes live on YouTube.


00:00:56.560 --> 00:01:02.720
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be


00:01:02.720 --> 00:01:04.600
part of that episode.


00:01:04.600 --> 00:01:09.440
This episode is brought to you by Sentry and us over at Talk Python Training.


00:01:09.440 --> 00:01:11.840
Please check out what we're both offering during our segments.


00:01:11.840 --> 00:01:14.080
It really helps support the show.


00:01:14.080 --> 00:01:16.200
Jason, welcome to Talk Python and me.


00:01:16.200 --> 00:01:17.200
Thank you for having me.


00:01:17.200 --> 00:01:19.700
Yeah, it's great to have you here on the show.


00:01:19.700 --> 00:01:22.400
I'm looking forward to talking about a bunch of things


00:01:22.400 --> 00:01:26.000
I wish people taught you about Python sooner.


00:01:26.000 --> 00:01:29.400
I think there are many, many things that fall into that category.


00:01:29.400 --> 00:01:32.000
And part of that, I guess it's true with all languages,


00:01:32.000 --> 00:01:34.800
but I think it's maybe a little extra true in Python


00:01:34.800 --> 00:01:37.200
because getting started is so easy,


00:01:37.200 --> 00:01:41.200
but getting really good at it takes a lifetime sort of thing, you know?


00:01:41.200 --> 00:01:44.600
And so there's like this big mismatch of how accessible it feels,


00:01:44.600 --> 00:01:47.040
But then what you can get out of it if you go further.


00:01:47.040 --> 00:01:47.200
Right.


00:01:47.200 --> 00:01:49.800
So I think that we'll touch on that going further apart, maybe.


00:01:49.800 --> 00:01:50.440
Absolutely.


00:01:50.440 --> 00:01:51.240
Yeah, for sure.


00:01:51.240 --> 00:01:55.200
Now, before we get into all those things, let's start with your story.


00:01:55.200 --> 00:01:56.640
How'd you get into programming and Python?


00:01:56.640 --> 00:02:00.200
I, well, I got into programming by a route that I don't recommend to anybody.


00:02:00.200 --> 00:02:03.640
I fell down a staircase, hit my head on the banister and ended all


00:02:03.640 --> 00:02:05.600
hopes of ever becoming a doctor.


00:02:05.600 --> 00:02:12.240
Oh, so went from 4.0 straight A student, college level reading in high school


00:02:12.440 --> 00:02:16.420
to failing pre-game material, two extra years to climb back up where I was


00:02:16.420 --> 00:02:19.220
academically a bit longer after that for other things.


00:02:19.220 --> 00:02:22.920
But somewhere along the way, I discovered that I had a natural inclination


00:02:22.920 --> 00:02:28.280
towards an attack for coding and got into that because I wanted to make games.


00:02:28.280 --> 00:02:29.600
I wanted to make educational games.


00:02:29.600 --> 00:02:30.720
They had been part of my recovery.


00:02:30.720 --> 00:02:31.960
So I'm like, I want to make games.


00:02:31.960 --> 00:02:33.500
So I learned how to code.


00:02:33.500 --> 00:02:39.080
And so I taught myself VB.net and then felt very constrained by the.net


00:02:39.080 --> 00:02:41.820
ecosystem and broke out into Python.


00:02:42.360 --> 00:02:47.080
found my home, stayed put until I wound up going to a bunch of other languages.


00:02:47.080 --> 00:02:49.400
I used Flash for quite some time.


00:02:49.400 --> 00:02:50.560
I've used C++.


00:02:50.560 --> 00:02:55.200
I muck about in whatever Sandy, but Python is definitely near to dear to my heart.


00:02:55.200 --> 00:02:55.960
Yeah, absolutely.


00:02:55.960 --> 00:03:00.360
Well, if you started out in VB.net, I think it's a little less true these days,


00:03:00.360 --> 00:03:05.280
but in the earlier days, that was a really different ecosystem than Python, right?


00:03:05.280 --> 00:03:09.280
There was like, well, what is the framework for this thing that Microsoft recommends?


00:03:09.280 --> 00:03:10.360
Like, how do I do the web?


00:03:10.360 --> 00:03:12.400
I do ASP.net because that's what they provide me.


00:03:12.400 --> 00:03:13.300
How do I do database?


00:03:13.300 --> 00:03:15.060
I do this because that's what they provide me.


00:03:15.060 --> 00:03:18.400
And you come into Python, you're like, wait, there's a thousand different ways to do this.


00:03:18.400 --> 00:03:21.040
And I have to pick and decide and I can mix and match.


00:03:21.040 --> 00:03:23.640
And it's both amazing and like terrifying.


00:03:23.640 --> 00:03:24.740
Kind of like, yeah, it's terrifying.


00:03:24.740 --> 00:03:26.500
Like, what do I make the wrong choice?


00:03:26.500 --> 00:03:28.000
I've, how do I decide?


00:03:28.000 --> 00:03:29.260
I have no basis, right?


00:03:29.260 --> 00:03:30.000
I'm both new.


00:03:30.000 --> 00:03:33.900
So I have no basis for deciding, but I also, I've got to decide to get started.


00:03:33.900 --> 00:03:34.560
So where do we go?


00:03:34.560 --> 00:03:34.840
Right.


00:03:34.840 --> 00:03:36.000
Like it's, it's a different world.


00:03:36.100 --> 00:03:38.640
It is where I first started running into


00:03:38.640 --> 00:03:42.000
trouble with the paradox that I wound up


00:03:42.000 --> 00:03:42.720
addressing in my book.


00:03:42.720 --> 00:03:44.680
I'm back to that, but the paradox that a


00:03:44.680 --> 00:03:45.960
lot of people find themselves in, it's


00:03:45.960 --> 00:03:48.880
like, I know all this stuff, but I don't


00:03:48.880 --> 00:03:50.340
know enough to do this thing.


00:03:50.340 --> 00:03:52.400
And so you wind up with this weird little


00:03:52.400 --> 00:03:54.320
gap in a lot of training material because


00:03:54.320 --> 00:03:56.080
you have like the absolute basic elementary


00:03:56.080 --> 00:03:57.680
and the examples there are almost


00:03:57.680 --> 00:03:58.840
insultingly simplistic.


00:03:58.840 --> 00:04:00.820
It's like, oh, you just have to type this


00:04:00.820 --> 00:04:03.480
stuff into, into, into this file and you


00:04:03.480 --> 00:04:04.680
run the file and look at that.


00:04:04.680 --> 00:04:05.520
You have a hello world.


00:04:05.520 --> 00:04:06.320
Aren't you smart?


00:04:06.320 --> 00:04:09.560
And then you go all the way to the ever extreme and it's something like super


00:04:09.560 --> 00:04:10.800
complicated and I'll understand any of it.


00:04:10.800 --> 00:04:15.080
And nobody sat in Brett and wrote down, here's how you structure a multi-Python


00:04:15.080 --> 00:04:18.440
project in a way that's going to, at least when I started, that wasn't documented


00:04:18.440 --> 00:04:20.520
anywhere, like no one had ever written it down.


00:04:20.520 --> 00:04:22.200
So it was just like, what do I do now?


00:04:22.200 --> 00:04:23.280
Yeah, it's really tricky.


00:04:23.280 --> 00:04:27.120
A lot of the tutorials and stuff are like, you just put all the stuff into one file.


00:04:27.120 --> 00:04:30.520
And then it's magic and, but you should never ever do that.


00:04:30.520 --> 00:04:35.320
Well, maybe in simple cases, but yeah, super realistic apps, like no realistic


00:04:35.320 --> 00:04:38.500
app belongs in one file, like just like you wouldn't have one function or


00:04:38.500 --> 00:04:39.600
just like no functions, right?


00:04:39.600 --> 00:04:40.800
You're like, not really.


00:04:40.800 --> 00:04:41.680
It's not how you do it.


00:04:41.680 --> 00:04:42.400
Yeah.


00:04:42.400 --> 00:04:46.160
But so there is this, even when you're sort of hunting through


00:04:46.160 --> 00:04:49.560
tutorials, there's this mismatch of the simple way to show it the


00:04:49.560 --> 00:04:52.360
simplest way to show it and then like maybe how you should.


00:04:52.360 --> 00:04:52.840
Yeah.


00:04:52.840 --> 00:04:54.040
Oh yeah, exactly.


00:04:54.040 --> 00:04:57.400
It's it's the example of given is that there's two types of books


00:04:57.400 --> 00:04:59.360
slash articles slash tutorial out there.


00:04:59.360 --> 00:05:01.800
There's here's basics of variables, boys and girls.


00:05:02.080 --> 00:05:06.040
And then the next level after that is here's how to program a natural


00:05:06.040 --> 00:05:09.920
language recognition, OCR, AI, machine learning on a Raspberry Pi at your


00:05:09.920 --> 00:05:13.440
grandmother's base or running on a potato battery and there's nothing in between.


00:05:13.440 --> 00:05:14.360
Yeah.


00:05:14.360 --> 00:05:16.880
Yeah, that's true.


00:05:16.880 --> 00:05:18.200
It does make it quite challenging.


00:05:18.200 --> 00:05:18.800
All right.


00:05:18.800 --> 00:05:19.280
How about now?


00:05:19.280 --> 00:05:19.760
What are you up to?


00:05:19.760 --> 00:05:20.920
Oh, these days.


00:05:20.920 --> 00:05:24.840
So gosh, I'm actually kind of veering these days more into, actually


00:05:24.840 --> 00:05:28.760
more into kind of the, facilitation business analyst side of things more.


00:05:28.760 --> 00:05:31.720
Interestingly, the last, last couple of years, that's become a point


00:05:31.720 --> 00:05:34.400
particular interest, but you know, in terms of coding, I'm working on, I'm


00:05:34.400 --> 00:05:37.280
working on some interesting projects that, you know, at work building, you


00:05:37.280 --> 00:05:39.400
know, an API for an internal project.


00:05:39.400 --> 00:05:44.520
And that's been, that's been fun getting to get my hands dirty with FastAPI and


00:05:44.520 --> 00:05:47.960
SQLAlchemy and that's been, that's been fairly enjoyable.


00:05:47.960 --> 00:05:51.480
So that's been the majority of my programming bandwidth lately, but it's


00:05:51.480 --> 00:05:51.700
fun.


00:05:51.700 --> 00:05:54.280
It's, it's the sort of project you hope you're going to get at work because


00:05:54.280 --> 00:05:56.120
it's an interesting topic.


00:05:56.120 --> 00:05:59.160
You have enough love, leeway.


00:05:59.160 --> 00:06:02.120
That's where we're looking for enough leeway to do things right.


00:06:02.120 --> 00:06:05.440
And do things to some degree your way, if you can justify it well enough.


00:06:05.440 --> 00:06:07.080
And, you know, other tech lead on it.


00:06:07.080 --> 00:06:10.960
So I'm able to make sure like, you know, we're making good decisions early and


00:06:10.960 --> 00:06:14.080
paying down technical debt and building something that's really, really cool.


00:06:14.080 --> 00:06:15.640
So it's, it's a fun project.


00:06:15.640 --> 00:06:16.160
I'm enjoying it.


00:06:16.160 --> 00:06:16.440
Yeah.


00:06:16.440 --> 00:06:20.640
Those kinds of projects, they're, they're fun, but they're also important, right?


00:06:20.640 --> 00:06:25.320
Like if your work, if you work, if you work at a place where they say, you know,


00:06:25.320 --> 00:06:29.000
you need to use 10 year old technology and there's no opportunity to try


00:06:29.000 --> 00:06:31.840
new things like FastAPI and other others.


00:06:31.840 --> 00:06:35.320
What you end up with is a whole bunch of people who that work there who don't


00:06:35.320 --> 00:06:39.000
want to learn any new technologies and don't are not deeply passionate about


00:06:39.000 --> 00:06:42.400
programming. And it's kind of the self-fulfilling prophecy.


00:06:42.400 --> 00:06:45.520
And I think it's cool that the place you're working at allows that, right?


00:06:45.520 --> 00:06:49.280
Because I think it's, it's one of the signs of a healthy tech,


00:06:49.280 --> 00:06:51.720
not necessarily a startup or whatever,


00:06:51.720 --> 00:06:54.480
but all these companies have like small software teams within it.


00:06:54.480 --> 00:06:56.720
It's a sign of a healthy, small software team,


00:06:56.720 --> 00:06:58.440
even if it's just building internal software.


00:06:58.480 --> 00:06:59.260
Well, definitely.


00:06:59.260 --> 00:06:59.520
Yeah.


00:06:59.520 --> 00:07:00.800
And you know, and there's a place for older


00:07:00.800 --> 00:07:01.640
technology as well.


00:07:01.640 --> 00:07:03.580
It's good to be well-versed in both and be


00:07:03.580 --> 00:07:04.440
able to move between it.


00:07:04.440 --> 00:07:06.600
But I mean, yeah, if you're, if you're just


00:07:06.600 --> 00:07:09.080
stuck in the past, then you either play it,


00:07:09.080 --> 00:07:10.480
like you said, get a lot of people that are


00:07:10.480 --> 00:07:13.120
afraid of change or are really wanting that


00:07:13.120 --> 00:07:14.520
change and they're dissatisfied with the


00:07:14.520 --> 00:07:15.320
fact that they can't get it.


00:07:15.320 --> 00:07:17.120
But on the other hand, if you just, if you're


00:07:17.120 --> 00:07:18.920
only new technology, you'll just spontaneously


00:07:18.920 --> 00:07:21.920
combust because you can't, you know, there's


00:07:21.920 --> 00:07:25.580
just, there's so much constant invention and


00:07:25.580 --> 00:07:28.040
reinvention and research and unexpected bugs


00:07:28.040 --> 00:07:31.320
and whatever, it's like, sometimes the nice thing about a 10 year old library


00:07:31.320 --> 00:07:33.920
is that there's less bugs because it's eight years old.


00:07:33.920 --> 00:07:37.040
>> Or you can find documentation about issues or whatever.


00:07:37.040 --> 00:07:38.760
You know, they have a term.


00:07:38.760 --> 00:07:42.440
It's like a term in the software industry about this, this constant


00:07:42.440 --> 00:07:46.440
churn that's like going too quick and especially not appreciating stuff


00:07:46.440 --> 00:07:47.640
that's been around, it's called JavaScript.


00:07:47.640 --> 00:07:51.040
>> You're not wrong.


00:07:51.040 --> 00:07:53.720
JavaScript is the embodiment of shiny object syndrome.


00:07:53.720 --> 00:07:54.440
>> It is.


00:07:54.440 --> 00:07:59.320
I'm not bashing on JavaScript per se, but the life cycle of some of these


00:07:59.320 --> 00:08:01.780
frameworks is just so brief, you know, it's nuts.


00:08:01.780 --> 00:08:04.720
>> Everybody wanted to use Deno for about 10 minutes.


00:08:04.720 --> 00:08:05.520
I remember that.


00:08:05.520 --> 00:08:09.500
There was, there were a thousand articles a minute on Deno and now it's, now we've


00:08:09.500 --> 00:08:13.200
moved on to other things and it's, well, I mean, it's funny because you get a new,


00:08:13.200 --> 00:08:17.300
new technology, like, okay, the, the, the topic of the minute, ChatGPT and


00:08:17.300 --> 00:08:20.240
everybody on LinkedIn is an expert in ChatGPT, you know, have you noticed that?


00:08:20.240 --> 00:08:22.000
Every other post is about ChatGPT.


00:08:22.000 --> 00:08:26.160
It's like, well, it's interesting, but it's just a bit early.


00:08:26.160 --> 00:08:28.240
And the early adopters have a lot of egg


00:08:28.240 --> 00:08:30.840
they're still trying to wash off their face in the last six pads.


00:08:30.840 --> 00:08:33.440
So it's like, let's see what happens.


00:08:33.440 --> 00:08:36.040
But chances are, this is just an early hiccup.


00:08:36.040 --> 00:08:37.440
Yeah, for sure.


00:08:37.440 --> 00:08:41.440
So you mentioned FastAPI and SQLAlchemy and Yasser out there says


00:08:41.440 --> 00:08:42.840
SQLAlchemy is the best library.


00:08:42.840 --> 00:08:44.320
So SQLAlchemy is pretty great.


00:08:44.320 --> 00:08:48.200
And it's, you know, it's cool to see my Bayer and crew updated to 2.0


00:08:48.200 --> 00:08:50.400
and add async and await to it and stuff.


00:08:50.400 --> 00:08:55.680
But there's also, especially when you're in Pydantic world, say with FastAPI,


00:08:55.680 --> 00:09:01.520
you know, there's a SQL model for also from Sebastian Ramirez that says, Hey,


00:09:01.520 --> 00:09:05.880
we are already doing Pydantic for the API or front end exchange.


00:09:05.880 --> 00:09:08.040
Like, what about, what about making that your database?


00:09:08.040 --> 00:09:10.600
Did you all evaluate or consider a SQL model?


00:09:10.600 --> 00:09:11.120
I did.


00:09:11.120 --> 00:09:13.440
It's one of those things like this would be great.


00:09:13.440 --> 00:09:15.600
And I think we can move towards that later.


00:09:15.600 --> 00:09:18.800
But sometimes when you're paying down technical debt, you have to make a


00:09:18.800 --> 00:09:20.960
distinction between do I want to make,


00:09:20.960 --> 00:09:23.040
you know, the monthly payment as it were


00:09:23.040 --> 00:09:24.620
more than a month, a monthly payment,


00:09:24.620 --> 00:09:26.360
or do I want to try and pay it all off


00:09:26.360 --> 00:09:27.380
in one thing?


00:09:27.380 --> 00:09:28.920
And sometimes when you're having to


00:09:28.920 --> 00:09:30.960
budget that time, you know, for us,


00:09:30.960 --> 00:09:32.940
it made the most sense to migrate from


00:09:32.940 --> 00:09:35.180
the 1.0 that we were working with


00:09:35.180 --> 00:09:36.920
earlier on to using


00:09:36.920 --> 00:09:38.360
the, you know, SQLAlchemy 2.


00:09:38.360 --> 00:09:40.420
And so there was a relatively smaller


00:09:40.420 --> 00:09:41.960
set of changes that we needed to make.


00:09:41.960 --> 00:09:43.860
Moving to something like a SQL


00:09:43.860 --> 00:09:45.920
model would have, would


00:09:45.920 --> 00:09:47.940
be great, but it would also require


00:09:47.940 --> 00:09:49.840
us to rewrite some major things.


00:09:49.840 --> 00:09:53.240
And so that's one of those things is like, well, this might be a good option.


00:09:53.240 --> 00:09:56.480
I mean, it looks really cool, but let's defer that for right now so that we


00:09:56.480 --> 00:09:58.160
can actually get some stuff done.


00:09:58.160 --> 00:09:59.560
It's a constant balancing act.


00:09:59.560 --> 00:10:02.080
Like do we pay down, pay down technical debt or build new features?


00:10:02.080 --> 00:10:03.000
And the answer is yes.


00:10:03.000 --> 00:10:05.520
You have to do both, but you have to keep it in.


00:10:05.520 --> 00:10:07.960
You have to keep it in balance, pay down the credit card, but also make sure


00:10:07.960 --> 00:10:09.160
you're buying your groceries, you know?


00:10:09.160 --> 00:10:10.680
Yeah, absolutely.


00:10:10.680 --> 00:10:14.200
I feel like if you wanted to go that way, the change is pretty straightforward,


00:10:14.200 --> 00:10:17.340
but if you already have it all set up in the other way, again, it's like, eh,


00:10:17.600 --> 00:10:18.480
What is the value?


00:10:18.480 --> 00:10:23.460
Just one thing that kind of timely as of a couple days ago, let's see.


00:10:23.460 --> 00:10:29.120
As of two days ago, the Pydantic folks, Samuel Colvin and Terrence Dorsey posted,


00:10:29.120 --> 00:10:33.080
Hey, we're excited to announce the first alpha of Pydantic V2.


00:10:33.080 --> 00:10:36.480
And I had Samuel on like a year ago to talk about what they're doing there.


00:10:36.480 --> 00:10:43.580
But the big news is the headline news in here is they rewrote much of the core of


00:10:43.580 --> 00:10:48.860
Pydantic in Rust and now Pydantic version two is five to 50 times faster.


00:10:48.860 --> 00:10:49.820
Nice.


00:10:49.820 --> 00:10:50.380
That's cool.


00:10:50.380 --> 00:10:50.700
Right?


00:10:50.700 --> 00:10:51.980
That's gorgeous.


00:10:51.980 --> 00:10:52.660
Thank you.


00:10:52.660 --> 00:10:54.300
This is just put more work on my plate.


00:10:54.300 --> 00:10:54.940
That's okay.


00:10:54.940 --> 00:10:57.580
No, this will be good.


00:10:57.580 --> 00:10:58.820
I'll have to bring this up at work.


00:10:58.820 --> 00:11:00.380
It's like, Hey, we should look at this later.


00:11:00.380 --> 00:11:00.700
Yeah.


00:11:00.700 --> 00:11:04.500
I mean, I don't think that there's any, I don't think anything will, obviously


00:11:04.500 --> 00:11:08.220
nothing will change for your SQLAlchemy side, but even for FastAPI, I'm sure


00:11:08.220 --> 00:11:11.620
that that's, this is going to get rolled in in a smooth way, but it does mean


00:11:11.620 --> 00:11:15.180
that all that data exchange should just go way, way faster,


00:11:15.180 --> 00:11:18.260
which for basically no effort on users of things


00:11:18.260 --> 00:11:21.460
like FastAPI, SQL model, and Beanie, and all those.


00:11:21.460 --> 00:11:22.580
So that's cool news.


00:11:22.580 --> 00:11:23.540
- Yeah, definitely.


00:11:23.540 --> 00:11:24.420
That is neat.


00:11:24.420 --> 00:11:26.660
- Other than the fact that if you do a lot of work


00:11:26.660 --> 00:11:28.980
in directly in Pydantic models,


00:11:28.980 --> 00:11:30.500
there might be a few small breaking changes.


00:11:30.500 --> 00:11:33.700
But let's talk about our things,


00:11:33.700 --> 00:11:36.700
the things we wish someone had explained to us sooner.


00:11:36.700 --> 00:11:37.540
- Yes.


00:11:37.540 --> 00:11:38.820
- And I guess we can start with this.


00:11:38.820 --> 00:11:40.540
Like these things were motivated.


00:11:40.540 --> 00:11:43.300
We'll come back and talk a bit more about this at the end, but they're motivated.


00:11:43.300 --> 00:11:44.940
This whole conversation was motivated.


00:11:44.940 --> 00:11:48.980
This big, long book that you wrote here, dead simple Python, give people the


00:11:48.980 --> 00:11:50.340
elevator pitch and then we'll get to it.


00:11:50.340 --> 00:11:50.840
Exactly.


00:11:50.840 --> 00:11:53.180
So dead simple Python is the book I wish I had.


00:11:53.180 --> 00:11:55.900
And, yeah, it's, I get teased a lot.


00:11:55.900 --> 00:11:59.900
It's like dead simple and it's that thick, but it's dead simple in the


00:11:59.900 --> 00:12:01.980
same way that Python is obvious.


00:12:01.980 --> 00:12:03.580
It's obvious retrospective.


00:12:03.580 --> 00:12:04.840
Things are dead simple.


00:12:04.840 --> 00:12:07.220
Once you understand it, you look back and go, Oh, okay.


00:12:07.220 --> 00:12:07.720
That clicks.


00:12:07.720 --> 00:12:08.560
That just makes sense.


00:12:08.560 --> 00:12:10.260
A lot of things in Python are like that.


00:12:10.260 --> 00:12:12.360
You look into it, it's like, that looks really complicated.


00:12:12.360 --> 00:12:14.660
What, you know, how is this A6 supposed to work?


00:12:14.660 --> 00:12:16.660
And then you look back and go, oh, that's all.


00:12:16.660 --> 00:12:17.160
Okay.


00:12:17.160 --> 00:12:17.760
No, that's.


00:12:17.760 --> 00:12:18.260
Yeah, exactly.


00:12:18.260 --> 00:12:19.360
I was, why was I afraid?


00:12:19.360 --> 00:12:21.960
Why did I put learning, put off learning this for six months?


00:12:21.960 --> 00:12:22.760
Exactly.


00:12:22.760 --> 00:12:28.060
It's, you know, things look more intimidating than they, than they are in practice.


00:12:28.060 --> 00:12:37.560
But basically this is the book for those persons who already know another programming language, or maybe they've even been working with Python for a while.


00:12:37.560 --> 00:12:39.160
Like they're familiar with the basics.


00:12:39.360 --> 00:12:44.160
They do not want to have their hand held through the, you know, this is what a


00:12:44.160 --> 00:12:45.800
variable is and this is what a function is.


00:12:45.800 --> 00:12:49.080
I got the, they've been through this probably more times than they want to


00:12:49.080 --> 00:12:54.240
admit to, and they want to get into what's different about Python and how


00:12:54.240 --> 00:12:56.120
to use Python as Python.


00:12:56.120 --> 00:12:59.640
I think that's kind of the core of the book is there's a big difference between


00:12:59.640 --> 00:13:05.400
Python code that works and Python code that makes the most of the language and


00:13:05.400 --> 00:13:08.080
its patterns, what we would refer to as Pythonic code.


00:13:08.080 --> 00:13:13.180
And there's a big difference between the two, because it's very tempting to come in and write Python as


00:13:13.180 --> 00:13:19.080
BB dot that in my case, because that's where I started or write Python as C or write Python as Java, write Python as Ruby.


00:13:19.080 --> 00:13:25.880
And we wind up holding ourselves back and having a really convoluted and hard to maintain code because we don't understand the patterns.


00:13:25.880 --> 00:13:30.080
So the approach I took with the book is let me explain why we do things this way.


00:13:30.080 --> 00:13:37.080
Let's go all the way down into the internals and how this actually works under the hood.


00:13:37.080 --> 00:13:39.920
So by the time you get to the for loop, the web statements,


00:13:39.920 --> 00:13:41.720
the meta class or whatever, you're like,


00:13:41.720 --> 00:13:46.720
"Oh, I understand what this is, why it's there, how it's used, and when not to use it."


00:13:46.720 --> 00:13:48.640
>> Yeah, that's a great service.


00:13:48.640 --> 00:13:53.200
So you're saying if I create a class called like,


00:13:53.200 --> 00:13:56.680
user factory and it implemented I user factory,


00:13:56.680 --> 00:13:59.680
and then I would use dependency injection, I might be doing that wrong?


00:13:59.680 --> 00:14:01.840
>> You might be writing C# and Python.


00:14:01.840 --> 00:14:04.080
>> Yeah, indeed.


00:14:04.080 --> 00:14:09.080
This portion of Talk Python to Me is brought to you by Sentry.


00:14:09.080 --> 00:14:12.080
Is your Python application fast?


00:14:12.080 --> 00:14:16.080
Or does it sometimes suffer from slowdowns and unexpected latency?


00:14:16.080 --> 00:14:18.080
Does this usually only happen in production?


00:14:18.080 --> 00:14:22.080
It's really tough to track down the problems at that point, isn't it?


00:14:22.080 --> 00:14:26.080
If you've looked at APM, application performance monitoring, products before,


00:14:26.080 --> 00:14:28.080
they may have felt out of place for software teams.


00:14:28.080 --> 00:14:33.080
Many of them are more focused on legacy problems made for ops and infrastructure teams


00:14:33.080 --> 00:14:36.560
to keep their infrastructure and services up and running.


00:14:36.560 --> 00:14:40.740
Sentry has just launched their new APM service.


00:14:40.740 --> 00:14:43.000
And Sentry's approach to application monitoring


00:14:43.000 --> 00:14:45.560
is focused on being actionable, affordable,


00:14:45.560 --> 00:14:47.840
and actually built for developers.


00:14:47.840 --> 00:14:49.240
Whether it's a slow running query


00:14:49.240 --> 00:14:51.320
or latent payment endpoint that's at risk


00:14:51.320 --> 00:14:53.560
of timing out and causing sales to tank,


00:14:53.560 --> 00:14:57.440
Sentry removes the complexity and does the analysis for you,


00:14:57.440 --> 00:14:59.720
surfacing the most critical performance issues


00:14:59.720 --> 00:15:01.520
so you can address them immediately.


00:15:01.520 --> 00:15:05.720
Most legacy APM tools focus on an ingest everything approach,


00:15:05.720 --> 00:15:08.560
resulting in high storage costs, noisy environments,


00:15:08.560 --> 00:15:10.960
and an enormous amount of telemetry data


00:15:10.960 --> 00:15:14.040
most developers will never need to analyze.


00:15:14.040 --> 00:15:15.960
Sentry has taken a different approach,


00:15:15.960 --> 00:15:19.280
building the most affordable APM solution in the market.


00:15:19.280 --> 00:15:22.040
They've removed the noise and extract the maximum value


00:15:22.040 --> 00:15:23.200
out of your performance data


00:15:23.200 --> 00:15:25.920
while passing the savings directly onto you,


00:15:25.920 --> 00:15:27.880
especially for TalkBython listeners


00:15:27.880 --> 00:15:30.160
who use the code TalkBython.


00:15:30.160 --> 00:15:33.360
So get started at talkpython.fm/sentry


00:15:33.360 --> 00:15:37.120
and be sure to use their code, talkpython, all lowercase,


00:15:37.120 --> 00:15:40.280
so you let them know that you heard about them from us.


00:15:40.280 --> 00:15:44.040
My thanks to Sentry for keeping this podcast going strong.


00:15:44.040 --> 00:15:48.040
So I like the idea of it.


00:15:48.040 --> 00:15:51.040
Let's talk, let's go through the topics.


00:15:51.040 --> 00:15:53.120
We both contributed a little bit, mostly.


00:15:53.120 --> 00:15:54.600
I'll throw in a few if we got extra time.


00:15:54.600 --> 00:15:55.440
- Yeah, yeah.


00:15:55.440 --> 00:15:57.600
- The first one has to do with this, I guess,


00:15:57.600 --> 00:16:00.160
like really early stage writing code,


00:16:00.160 --> 00:16:01.720
like how to create variables,


00:16:01.720 --> 00:16:03.520
what are the deals with types and variables,


00:16:03.520 --> 00:16:05.480
but also types and objects.


00:16:05.480 --> 00:16:06.320
Tell us about that.


00:16:06.320 --> 00:16:07.140
- Yeah, exactly.


00:16:07.140 --> 00:16:08.560
How names and values actually work.


00:16:08.560 --> 00:16:12.040
And this is something that I had to learn early,


00:16:12.040 --> 00:16:13.440
but I didn't fully understand.


00:16:13.440 --> 00:16:16.000
So when I first logged into the Python IRC room


00:16:16.000 --> 00:16:18.000
back when I learned this language,


00:16:18.000 --> 00:16:20.200
you know, back in the Cretaceous period,


00:16:20.200 --> 00:16:22.480
I logged in and I, you know,


00:16:22.480 --> 00:16:24.120
I'm coming from a strongly type background,


00:16:24.120 --> 00:16:26.720
so I'm saying, okay, so how do I declare a data type


00:16:26.720 --> 00:16:28.520
on a variable because I'm used to VB.


00:16:28.520 --> 00:16:30.640
I was like, yeah, DM and the name of the variable,


00:16:30.640 --> 00:16:31.880
type equals whatever.


00:16:31.880 --> 00:16:33.080
I don't want to call it type.


00:16:33.080 --> 00:16:34.480
It's before type hints existed.


00:16:34.480 --> 00:16:36.480
And one of the guys in the room goes,


00:16:36.480 --> 00:16:37.360
you're a data type.


00:16:37.360 --> 00:16:38.720
And I'm like, sorry, what?


00:16:38.720 --> 00:16:40.400
And he goes on to explain, well,


00:16:40.400 --> 00:16:42.800
it doesn't quite work this way in Python,


00:16:42.800 --> 00:16:44.600
but I didn't realize just how different it was.


00:16:44.600 --> 00:16:46.800
So because I just sort of had this vague,


00:16:46.800 --> 00:16:48.760
like, oh, you just have the name equals the value.


00:16:48.760 --> 00:16:50.960
Cool. Type still seems kind of important.


00:16:50.960 --> 00:16:52.920
Maybe I should start doing Hungarian notation.


00:16:52.920 --> 00:16:53.720
Don't do that.


00:16:53.720 --> 00:16:57.300
- SZ user name, no.


00:16:57.300 --> 00:17:01.060
- Exactly, exactly, int age or whatever.


00:17:01.060 --> 00:17:01.900
- Yeah, yeah.


00:17:01.900 --> 00:17:03.680
- And I thought I was being super clever and I wasn't,


00:17:03.680 --> 00:17:06.120
but eventually someone explained to me,


00:17:06.120 --> 00:17:07.360
I think it was actually Ned Batchelder,


00:17:07.360 --> 00:17:10.180
someone gave me the link to Ned Batchelder's talk on this,


00:17:10.180 --> 00:17:13.520
is that Python's variables work very differently


00:17:13.520 --> 00:17:14.840
than other languages,


00:17:14.840 --> 00:17:16.920
so much so that some smart alecks like to say,


00:17:16.920 --> 00:17:18.520
well, Python doesn't really have variables.


00:17:18.520 --> 00:17:21.200
Yes, it does, but they're variables in a different sense.


00:17:21.200 --> 00:17:25.360
You have names which are just like, they're like labels and you can call it whatever you


00:17:25.360 --> 00:17:27.920
want but a name has a scope.


00:17:27.920 --> 00:17:31.160
You know, so the name exists in the context of your whole program or in the context of


00:17:31.160 --> 00:17:32.640
your function or whatever.


00:17:32.640 --> 00:17:34.960
And a name can be bound to whatever you want.


00:17:34.960 --> 00:17:40.260
Imagine drawing, you know, basically having this label on a corkboard, think like a conspiracy


00:17:40.260 --> 00:17:41.440
theorist corkboard.


00:17:41.440 --> 00:17:44.840
You know, you have the tack and the label and you put a little string around it and


00:17:44.840 --> 00:17:49.900
you tie that string to this other thing over here and that's your value.


00:17:49.900 --> 00:17:55.500
value has a type. It has, it is one thing. It's a Boolean or it is an integer or it is


00:17:55.500 --> 00:17:56.700
a string or it is a list.


00:17:56.700 --> 00:18:01.500
>> We've all seen the error, you cannot combine integer and string with plus operation. Like


00:18:01.500 --> 00:18:02.780
they know what they are, right?


00:18:02.780 --> 00:18:06.140
>> Exactly. Those values know what they are and that's something that throws people off


00:18:06.140 --> 00:18:09.100
coming from JavaScript where everything's weakly typed. It'll just try to coerce them


00:18:09.100 --> 00:18:12.380
together. Python says, "Hey, these two values are different. I'm not going to try and figure


00:18:12.380 --> 00:18:15.740
this out." That's because it's working with the values. The values have type, but the


00:18:15.740 --> 00:18:21.620
the values don't have scope. And this is where people get thrown off. Because if


00:18:21.620 --> 00:18:26.700
you say, you know, let's say, I'm gonna use example here, x equals spam. If you


00:18:26.700 --> 00:18:32.820
were to say z equals x, you're binding z to the same value as x. And then if you


00:18:32.820 --> 00:18:36.820
decide to change z, that works x is unchanged, z is changed, you might think,


00:18:36.820 --> 00:18:41.260
Oh, cool. Okay, this is just it just made a copy. Not exactly. Because we have


00:18:41.260 --> 00:18:44.200
this whole thing about mutable and immutable types.


00:18:44.200 --> 00:18:46.200
Some things can't be changed.


00:18:46.200 --> 00:18:47.840
Boolean and integer string,


00:18:47.840 --> 00:18:49.840
a tuple, they're not changed.


00:18:49.840 --> 00:18:51.960
The value is never modified in memory.


00:18:51.960 --> 00:18:54.080
A new thing is made instead.


00:18:54.080 --> 00:18:57.620
But then some, and by some I mean most,


00:18:57.620 --> 00:18:58.680
sorry about my clock,


00:18:58.680 --> 00:19:01.720
most types in Python like lists and dictionaries


00:19:01.720 --> 00:19:03.120
and the objects that you're creating


00:19:03.120 --> 00:19:05.320
with your fancy little classes are immutable.


00:19:05.320 --> 00:19:08.800
So if you create a list or a dictionary


00:19:08.800 --> 00:19:11.560
and you bind that to two different names.


00:19:11.560 --> 00:19:14.720
You modify, you add a value to that list.


00:19:14.720 --> 00:19:16.080
It doesn't matter which of the names you use,


00:19:16.080 --> 00:19:19.560
you're modifying the value in memory, in place.


00:19:19.560 --> 00:19:22.280
And now that is accessible from either of those names.


00:19:22.280 --> 00:19:23.760
And that can be confusing,


00:19:23.760 --> 00:19:25.520
especially when you start to understand that


00:19:25.520 --> 00:19:26.840
functions don't pass by value,


00:19:26.840 --> 00:19:28.240
they don't pass by reference.


00:19:28.240 --> 00:19:32.240
They just bind the value to the name of that argument.


00:19:32.240 --> 00:19:34.360
Pass by assignment is what we usually call it.


00:19:34.360 --> 00:19:36.440
So you're just having one more handle,


00:19:36.440 --> 00:19:38.840
one more alias pointing to that value in memory.


00:19:38.840 --> 00:19:41.240
So if you change on that argument,


00:19:41.240 --> 00:19:43.280
you're just changing your spot in memory.


00:19:43.280 --> 00:19:47.520
- Many languages have values that are


00:19:47.520 --> 00:19:49.720
like local and copied types of values.


00:19:49.720 --> 00:19:53.680
So you mentioned VB.NET, which like the integer


00:19:53.680 --> 00:19:56.480
and float values, numbers and things like that.


00:19:56.480 --> 00:19:58.720
If you assign one, it's a copy of a thing.


00:19:58.720 --> 00:20:02.560
Whereas Python, literally everything is a pointer, right?


00:20:02.560 --> 00:20:06.280
This corkboard conspiracy theory,


00:20:06.280 --> 00:20:07.120
thing, right?


00:20:07.120 --> 00:20:09.700
There's, there's no concept of, Oh, I created this on the stack.


00:20:09.700 --> 00:20:11.200
And when the function returns, it's gone.


00:20:11.200 --> 00:20:15.580
It's everything is a, you know, even like a, just an integer is a


00:20:15.580 --> 00:20:18.060
PI long star down in the runtime.


00:20:18.060 --> 00:20:18.460
Right.


00:20:18.460 --> 00:20:20.420
That's a bit of a mental thing.


00:20:20.420 --> 00:20:24.660
People got to get used to just like how much, because when you come from a


00:20:24.660 --> 00:20:28.840
language like C++ or something, pointers and these reference type type


00:20:28.840 --> 00:20:30.740
of ideas are like right in your face.


00:20:30.740 --> 00:20:31.200
Right?


00:20:31.200 --> 00:20:35.700
Like you see this, like I just said, PI long star, like the star means it


00:20:35.700 --> 00:20:38.460
points at things without the star it's on the stack, right?


00:20:38.460 --> 00:20:41.040
That it's, you are way down in those details.


00:20:41.040 --> 00:20:43.820
Whereas in Python, you never see pointers.


00:20:43.820 --> 00:20:45.780
Like you could imagine, like, there's no such, like, we don't


00:20:45.780 --> 00:20:46.740
even have pointers in Python.


00:20:46.740 --> 00:20:51.820
Like, but the irony is like, literally everything is basically managed in that


00:20:51.820 --> 00:20:54.580
on the heap reference type style of work.


00:20:54.580 --> 00:20:56.740
So that's certainly something I wish I knew.


00:20:56.740 --> 00:20:57.540
Yeah.


00:20:57.540 --> 00:21:00.780
And, and of course then people come to C++ to see like, oh, cool.


00:21:00.780 --> 00:21:01.220
That's easy.


00:21:01.220 --> 00:21:02.160
So it's all pointers.


00:21:02.660 --> 00:21:06.460
Well, once again, Python being Python, not quite because it's


00:21:06.460 --> 00:21:08.800
actually technically called a reference, not a pointer.


00:21:08.800 --> 00:21:15.560
And that's important because a Python reference or Python value has two things.


00:21:15.560 --> 00:21:18.500
It has, yes, it does have a pointer, at least we're talking about CPython, but


00:21:18.500 --> 00:21:22.600
it also has a reference counter, which is itself an integer and that's adding overhead.


00:21:22.600 --> 00:21:27.400
So if you ever do actually go down and look at the sizes of things, you will


00:21:27.400 --> 00:21:31.800
notice that your base value has this additional overhead.


00:21:31.800 --> 00:21:32.240
Yeah.


00:21:32.300 --> 00:21:35.100
of two numbers, one of them is your pointer


00:21:35.100 --> 00:21:38.660
and the other one is your reference counter


00:21:38.660 --> 00:21:40.980
because it has a reference count in Garbage Collection.


00:21:40.980 --> 00:21:41.980
- Yeah, often a lot more.


00:21:41.980 --> 00:21:44.720
I think, trying to, I guess I could check,


00:21:44.720 --> 00:21:48.780
but either an integer or a single character,


00:21:48.780 --> 00:21:51.460
I can't remember which, is 28 bytes, right?


00:21:51.460 --> 00:21:53.980
And that's in C, the single character


00:21:53.980 --> 00:21:55.620
would be one or two bytes,


00:21:55.620 --> 00:21:58.500
and the integer would be two, four, or eight, right?


00:21:58.500 --> 00:22:00.060
And so there's just a big difference


00:22:00.060 --> 00:22:01.380
in the way you got to sort of,


00:22:01.380 --> 00:22:02.940
like the implications of that.


00:22:02.940 --> 00:22:05.500
So related to that, kind of moving on to the next,


00:22:05.500 --> 00:22:07.060
oh no, before we move on,


00:22:07.060 --> 00:22:08.300
the other thing that you mentioned,


00:22:08.300 --> 00:22:11.860
and I think is also a really big deal in this area,


00:22:11.860 --> 00:22:13.900
is the scope of a variable.


00:22:13.900 --> 00:22:16.060
And so in some languages,


00:22:16.060 --> 00:22:18.140
you have very fine-grained control


00:22:18.140 --> 00:22:21.180
of the lifetime of a variable by where you declare it.


00:22:21.180 --> 00:22:25.540
So for example, if you declare a variable in C++


00:22:25.540 --> 00:22:29.140
or VB.NET or whatever, in a if block,


00:22:29.140 --> 00:22:31.260
when you leave the if block, the thing goes away.


00:22:31.260 --> 00:22:35.420
Like if there's curly braces around it in a lot of languages, like that is the


00:22:35.420 --> 00:22:41.300
lifetime of the variable innermost bracket of curly braces, like outside of a loop.


00:22:41.300 --> 00:22:43.200
The thing goes away in Python.


00:22:43.200 --> 00:22:43.980
We don't have that.


00:22:43.980 --> 00:22:47.360
And that's, you know, kind of the variable persists and lives


00:22:47.360 --> 00:22:49.180
after afterwards, right.


00:22:49.180 --> 00:22:51.460
Which is a interesting difference.


00:22:51.460 --> 00:22:51.700
Yeah.


00:22:51.700 --> 00:22:54.480
Because the garbage collection is something you're never


00:22:54.480 --> 00:22:55.540
supposed to have to deal with.


00:22:55.540 --> 00:22:59.060
So even if you called delete on something, it's not necessarily


00:22:59.060 --> 00:23:01.380
guaranteed to be cleaned up when you expect it.


00:23:01.380 --> 00:23:04.480
Like the language is going to handle things when it, when it


00:23:04.480 --> 00:23:06.520
sees fit for whatever reason.


00:23:06.520 --> 00:23:09.740
So yeah, there's only to my knowledge, there's only three, there's


00:23:09.740 --> 00:23:12.200
only actually three scopes in Python.


00:23:12.200 --> 00:23:18.480
There's global level, there's module level, and there's I need to back.


00:23:18.480 --> 00:23:20.060
It's a little pedantic.


00:23:20.060 --> 00:23:23.620
And then you have function level classes are not their own scope.


00:23:23.620 --> 00:23:28.180
Classes actually do not a class exists in the global level.


00:23:28.400 --> 00:23:31.200
And whenever you have an attribute sitting on a class or sitting on an


00:23:31.200 --> 00:23:35.300
instance is actually in a dictionary, unless using slots, I'm not going into


00:23:35.300 --> 00:23:41.340
that, actually sitting in a dictionary that is a part of that object in memory.


00:23:41.340 --> 00:23:41.540
Yep.


00:23:41.540 --> 00:23:43.340
It's special, but it works out.


00:23:43.340 --> 00:23:44.840
It's just something you got to kind of get used to.


00:23:44.840 --> 00:23:45.400
Definitely.


00:23:45.400 --> 00:23:45.800
All right.


00:23:45.800 --> 00:23:46.680
Next one.


00:23:46.680 --> 00:23:47.400
Ducks.


00:23:47.400 --> 00:23:49.340
Wank duck typing.


00:23:49.340 --> 00:23:49.720
Yeah.


00:23:49.720 --> 00:23:52.280
And, and it's, this is where I went.


00:23:52.280 --> 00:23:53.080
Oh, Heywire.


00:23:53.080 --> 00:23:56.340
When I, when I was doing that, that Hungarian notation, I mentioned


00:23:56.340 --> 00:24:02.340
I'm being so clever, I'm just putting the name of the type in the name, and then I know it.


00:24:02.340 --> 00:24:06.580
But unfortunately, you're coming from a strongly typed language, you're actually,


00:24:06.580 --> 00:24:11.620
it's easy to underestimate just how much strong typing can actually hold us back in some cases,


00:24:11.620 --> 00:24:15.220
because we start thinking about what a thing is rather than what it can do.


00:24:15.220 --> 00:24:18.580
And we see this in Java, like you have to have these complex inheritance patterns,


00:24:18.580 --> 00:24:23.300
because you want to be able to say, well, this thing is, it is this matches this interface,


00:24:23.300 --> 00:24:25.460
you know, it does this particular thing.


00:24:25.460 --> 00:24:29.220
Python's take is, I really don't care what it is.


00:24:29.220 --> 00:24:33.620
As long as I can interact with it according to a particular


00:24:33.620 --> 00:24:35.220
kind of set of assumptions,


00:24:35.220 --> 00:24:37.780
then I don't care what it's really doing. I'm good.


00:24:37.780 --> 00:24:41.860
And this can be really beneficial because it allows you to create new things that act like


00:24:41.860 --> 00:24:45.700
integers, even though they're not integers, or new things that act like Booleans that aren't Booleans,


00:24:45.700 --> 00:24:47.460
new things that act like strings that aren't strings.


00:24:47.460 --> 00:24:48.500
Python doesn't care.


00:24:48.500 --> 00:24:53.220
It's just interfacing with those objects on the basis of


00:24:53.220 --> 00:24:58.260
how it can use them and what certain things are going to return.


00:24:58.260 --> 00:24:59.620
That's all it cares about.


00:24:59.620 --> 00:25:05.860
So the concept of duck type in being it doesn't care whether it's a duck or a picture of a duck or a statue of a duck or a moose in a duck suit.


00:25:05.860 --> 00:25:08.860
As long as it can interact with it in the way it needs, it's good.


00:25:08.860 --> 00:25:10.380
And that's very freeing.


00:25:10.380 --> 00:25:13.580
>> It walks like a duck and talks like a duck and quacks like a duck and it's probably a duck.


00:25:13.580 --> 00:25:14.500
>> Yeah, exactly.


00:25:14.500 --> 00:25:19.420
And it's very freeing once you get that because you don't have to muck about with all this weird inheritance anymore.


00:25:19.420 --> 00:25:22.100
It's like, well, it does what I need.


00:25:22.100 --> 00:25:23.180
And that's the important part.


00:25:23.180 --> 00:25:27.380
There is certainly less inheritance and less complex hierarchies in Python.


00:25:27.380 --> 00:25:31.500
Not that there's not an important place for object-oriented programming and classes.


00:25:31.500 --> 00:25:33.540
They're just often simpler.


00:25:33.540 --> 00:25:35.300
A lot more straightforward, definitely.


00:25:35.300 --> 00:25:40.500
And it frees us up to then the saying I coined a couple of years ago during a


00:25:40.500 --> 00:25:44.660
conference talk was that you need to define object by every constituent data.


00:25:44.660 --> 00:25:47.700
So when you're writing a class or you're designing an object, you're


00:25:47.700 --> 00:25:50.420
thinking about what is it storing?


00:25:50.420 --> 00:25:53.240
Like what, what sort of state, if you


00:25:53.240 --> 00:25:54.980
think in a functional way, or what sort


00:25:54.980 --> 00:25:57.700
of data am I really putting in here?


00:25:57.700 --> 00:26:01.200
And you can design based off of that.


00:26:01.200 --> 00:26:03.160
And then you can think about, well, how


00:26:03.160 --> 00:26:05.120
do I want, how does the system need


00:26:05.120 --> 00:26:07.580
to interact with that data?


00:26:07.580 --> 00:26:09.120
But you don't really have to sit there


00:26:09.120 --> 00:26:10.600
and think about encapsulating behavior.


00:26:10.600 --> 00:26:11.760
Cause that's not really the point.


00:26:11.760 --> 00:26:13.560
The point is you can think about, like


00:26:13.560 --> 00:26:15.200
with example, I use this, we always


00:26:15.200 --> 00:26:16.520
see the example of, I'm going to create


00:26:16.520 --> 00:26:19.040
a class called cat and a class called dog and they


00:26:19.040 --> 00:26:20.760
inherit from animal. And that's actually a really


00:26:20.760 --> 00:26:24.400
lousy example we need to stop using because that's


00:26:24.400 --> 00:26:26.480
starting from the concept of behavior. Well, it


00:26:26.480 --> 00:26:30.500
barks, it meows, it eats, whatever. And in real


00:26:30.500 --> 00:26:35.040
systems, what we think about is I have a, you know,


00:26:35.040 --> 00:26:37.720
someone design a game, I have a monster. Okay. What


00:26:37.720 --> 00:26:40.920
is a monster? Well, it's, it's a bad guy. No, no,


00:26:40.920 --> 00:26:44.200
no, no, not what it does. What is it? Well, it's,


00:26:44.200 --> 00:26:46.880
that's a collection of statistics about the character,


00:26:46.880 --> 00:26:49.880
you know, like how much strength it has and how much health it has.


00:26:49.880 --> 00:26:53.840
Okay, that is not a monster, that's an entity.


00:26:53.840 --> 00:26:58.360
You don't have to put what it's doing into that code,


00:26:58.360 --> 00:27:01.480
it is this collection of information.


00:27:01.480 --> 00:27:07.000
And when you shift your thinking to a data-first mindset about object-oriented,


00:27:07.000 --> 00:27:09.240
then you find that you can actually use it with


00:27:09.240 --> 00:27:12.360
functional paradigms that are sometimes a lot easier to reason about.


00:27:12.360 --> 00:27:15.200
- Yeah, the grouping together of data is an important part.


00:27:15.200 --> 00:27:18.480
I would say the most extreme example


00:27:18.480 --> 00:27:22.160
of duck typing in Python, maybe a couple areas,


00:27:22.160 --> 00:27:26.200
and they all seem to revolve around the magic methods


00:27:26.200 --> 00:27:28.600
or the Python data types, like the dunder methods, right?


00:27:28.600 --> 00:27:30.560
- I love those. - So I could, yeah, I know.


00:27:30.560 --> 00:27:33.520
So I could have a function, which I could call,


00:27:33.520 --> 00:27:36.740
or I could have a class that implements dunder call,


00:27:36.740 --> 00:27:40.240
is a callable, but is actually an instance of an object,


00:27:40.240 --> 00:27:43.700
Right. And, but as far as Python's concerned, it doesn't matter.


00:27:43.700 --> 00:27:46.660
It can call it and pass parameters to the thing it called.


00:27:46.660 --> 00:27:47.160
Right.


00:27:47.160 --> 00:27:50.420
And there's no real type that disambiguates those two things.


00:27:50.420 --> 00:27:51.500
Like one is a function type.


00:27:51.500 --> 00:27:54.660
One is a, you know, a class with a particular method on it.


00:27:54.660 --> 00:27:55.060
Right.


00:27:55.060 --> 00:27:56.700
But they work just fine.


00:27:56.700 --> 00:27:58.660
And that's a pretty extreme example.


00:27:58.660 --> 00:28:03.660
You know, another one would be, I have a list I can iterate, or I have something


00:28:03.660 --> 00:28:07.480
that implements the iterator pattern through the Dunder methods, right?


00:28:07.480 --> 00:28:09.180
Like the Dunder iterator and so on.


00:28:09.180 --> 00:28:09.660
Right.


00:28:09.740 --> 00:28:14.020
Well, yeah, one of the classes I, one of the examples of the book I gave was like


00:28:14.020 --> 00:28:17.540
a, a cafe queue, so a queue of customers in a line.


00:28:17.540 --> 00:28:22.120
And yeah, I wrote it as an iterable, but there was all this additional stuff in


00:28:22.120 --> 00:28:23.820
there, it wasn't just a basic list.


00:28:23.820 --> 00:28:24.980
There was more to it than that.


00:28:24.980 --> 00:28:28.900
And, but because I implemented as an iterable, I didn't care.


00:28:28.900 --> 00:28:34.400
I could use it like I use a list, but it was able to do this additional work with


00:28:34.400 --> 00:28:40.160
data behind the scenes that made it just easier to use the, to reason about this


00:28:40.160 --> 00:28:41.320
line of customers.


00:28:41.320 --> 00:28:45.320
And then you get generator methods with the yield keyword and yield from and


00:28:45.320 --> 00:28:46.640
like all sorts of stuff.


00:28:46.640 --> 00:28:51.480
You, you get pytest fixtures that allow you to set up and tear down without


00:28:51.480 --> 00:28:55.520
actually writing try finally blocks and all these things.


00:28:55.520 --> 00:28:57.120
A lot, a lot of interesting places.


00:28:57.120 --> 00:29:00.680
While I was thinking about this conversation and this topic in particular, I ran


00:29:00.680 --> 00:29:05.400
across an article called static duck typing in Python with protocols.


00:29:05.400 --> 00:29:08.140
How's that to like crash two ideas together?


00:29:08.140 --> 00:29:13.640
Yeah, it's well, and it's, well, when we look at data types, it's like the


00:29:13.640 --> 00:29:18.640
way Python even does its data types is yeah, you can say that you want to say,


00:29:18.640 --> 00:29:22.760
okay, this is a list and you can type it as a list, but you can also just


00:29:22.760 --> 00:29:27.800
actually type it as a neverable and basically tell Python what you care about.


00:29:27.800 --> 00:29:30.100
Do you really care that it's a list?


00:29:30.320 --> 00:29:31.320
Probably not.


00:29:31.320 --> 00:29:36.160
You care that it's an iterable that you can work with similar to a list?


00:29:36.160 --> 00:29:37.600
How are you going to use it?


00:29:37.600 --> 00:29:38.600
That's what you ask yourself.


00:29:38.600 --> 00:29:41.000
And you base your annotations around that.


00:29:41.000 --> 00:29:44.000
And so you can say, well, like here, measurement-like,


00:29:44.000 --> 00:29:47.320
I want it to be usable as a measurement.


00:29:47.320 --> 00:29:48.920
I don't really care what it is.


00:29:48.920 --> 00:29:51.000
It doesn't need to be this particular type of class.


00:29:51.000 --> 00:29:52.920
And so that's moving from, like we're talking about,


00:29:52.920 --> 00:29:55.520
moving from Java thinking into Python thinking is,


00:29:55.520 --> 00:29:58.360
well, it's not what it is, it's what it does.


00:29:58.360 --> 00:30:04.840
Yeah, a lot of the types people put down are like, I need to treat it like some duck typing situation.


00:30:04.840 --> 00:30:07.800
So it needs to have these attributes about it.


00:30:07.800 --> 00:30:13.120
Let's try to put that aspect of it into the formal static typing rather than earlier.


00:30:13.120 --> 00:30:13.520
Yeah.


00:30:13.520 --> 00:30:14.160
Okay.


00:30:14.160 --> 00:30:18.360
Maybe, maybe a quick audience question or a bit of feedback here before we move on to the next one.


00:30:18.360 --> 00:30:19.280
It's relevant.


00:30:19.280 --> 00:30:24.040
Nick says early in my Python journey, I wish I had gotten better understanding of all the intricacies,


00:30:24.040 --> 00:30:28.080
differences and use cases for various data structures like set versus list.


00:30:28.280 --> 00:30:28.640
Right.


00:30:28.640 --> 00:30:29.240
Yeah.


00:30:29.240 --> 00:30:30.320
Versus dictionary.


00:30:30.320 --> 00:30:34.080
And those are certainly, even if you've done programming before, maybe that


00:30:34.080 --> 00:30:37.800
environment language didn't deeply embrace these data structures.


00:30:37.800 --> 00:30:41.080
So certainly those are table stakes for being good at Python.


00:30:41.080 --> 00:30:41.720
Absolutely.


00:30:41.720 --> 00:30:44.940
Use cases hits the nail on the head because it's like, what's


00:30:44.940 --> 00:30:45.680
the difference between them?


00:30:45.680 --> 00:30:46.880
Well, you know, it's a collection.


00:30:46.880 --> 00:30:51.420
And so maybe that's all you care about, but I find myself using all of them in


00:30:51.420 --> 00:30:54.080
different cases because it's like, all right, I never need to add or remove


00:30:54.080 --> 00:30:55.440
things from it, I probably have too.


00:30:55.740 --> 00:30:59.780
Or I need to, or I need to be able to hash it, use it as an immutable.


00:30:59.780 --> 00:31:00.340
That's a tuple.


00:31:00.340 --> 00:31:03.340
Or I need to be able to see what's in group A and not group B.


00:31:03.340 --> 00:31:04.060
That's set.


00:31:04.060 --> 00:31:05.420
Or I care about the order.


00:31:05.420 --> 00:31:06.340
That's a list.


00:31:06.340 --> 00:31:08.320
Or I want to be able to associate two things.


00:31:08.320 --> 00:31:09.140
That's a dictionary.


00:31:09.140 --> 00:31:12.220
So knowing your different data structures is helpful.


00:31:12.220 --> 00:31:15.540
And you know, it's tricky because Python's data structures aren't really all that


00:31:15.540 --> 00:31:19.580
unique, but they have different names than maybe you use whatever languages.


00:31:19.580 --> 00:31:21.980
So, you know, you come across list and what is that?


00:31:21.980 --> 00:31:27.180
well, it's a C++ vector or a JavaScript array, you know, it's like, it's, it's,


00:31:27.180 --> 00:31:30.620
which is where it's helpful to come back to Python kind of with a fresh mind is


00:31:30.620 --> 00:31:32.020
like, what is this?


00:31:32.020 --> 00:31:35.500
Not assuming that things have the same names, but being prepared to get a


00:31:35.500 --> 00:31:36.540
different vocabulary.


00:31:36.540 --> 00:31:42.220
This portion of talk Python me is brought to you by us over at talk Python


00:31:42.220 --> 00:31:43.740
training with our courses.


00:31:43.740 --> 00:31:47.660
I want to tell you about a brand new one that I'm super excited about.


00:31:47.660 --> 00:31:50.900
Python web apps that fly with CDNs.


00:31:51.500 --> 00:31:55.060
If you have a Python web app, you want it to go super fast.


00:31:55.060 --> 00:31:58.100
Static resources turn out to be a huge portion


00:31:58.100 --> 00:31:59.420
of that equation.


00:31:59.420 --> 00:32:03.000
Leveraging a CDN could save you up to 75% of your server load


00:32:03.000 --> 00:32:06.000
and make your app way faster for your users.


00:32:06.000 --> 00:32:09.980
And this course is a step-by-step guide on how to do it.


00:32:09.980 --> 00:32:12.620
And using a CDN to make your Python apps faster


00:32:12.620 --> 00:32:14.900
is way easier than you think.


00:32:14.900 --> 00:32:16.660
So if you've got a Python web app


00:32:16.660 --> 00:32:19.500
and you would like to have it scaled out globally,


00:32:19.500 --> 00:32:23.760
If you'd like to have your users have a much better experience and maybe even


00:32:23.760 --> 00:32:27.900
save some money on server hosting and bandwidth, check out this course over


00:32:27.900 --> 00:32:30.260
at talk, python.fm/courses.


00:32:30.260 --> 00:32:31.580
It'll be right up there at the top.


00:32:31.580 --> 00:32:34.060
And of course the link will be in your show notes.


00:32:34.060 --> 00:32:36.420
Thank you to everyone who's taken one of our courses.


00:32:36.420 --> 00:32:38.100
It really helps support the podcast.


00:32:38.100 --> 00:32:39.340
I'm back to the show.


00:32:39.340 --> 00:32:45.500
Iteration, iterables, iterators, Lubin.


00:32:45.500 --> 00:32:46.420
Yes.


00:32:46.700 --> 00:32:51.420
So I was working in some code last year and I came across something that just, I, I,


00:32:51.420 --> 00:32:55.520
I was, I cringed and then I laughed out loud because this was written.


00:32:55.520 --> 00:33:01.520
So this code was written by who I best guess university data scientists.


00:33:01.520 --> 00:33:05.780
So, you know, a, to their favor, this is not a software engineer.


00:33:05.780 --> 00:33:09.500
What they had written and they could tell it had been a refactor a few times, but I


00:33:09.500 --> 00:33:10.020
am not kidding.


00:33:10.020 --> 00:33:13.320
They had said, all right, so I have this thing that it's iterable.


00:33:13.320 --> 00:33:15.480
It was already something that we could use in a loop.


00:33:15.500 --> 00:33:18.440
I'll come back to what that is for anyone who's curious, but we have this iterable.


00:33:18.440 --> 00:33:20.880
I'm going to convert that into a list.


00:33:20.880 --> 00:33:25.660
By the way, we're talking about in this case, tens of thousands of items in that list.


00:33:25.660 --> 00:33:26.920
I'm going to convert that into a list.


00:33:26.920 --> 00:33:34.060
Then on the next line, they say for index comma value in enumerate, enumerate is a


00:33:34.060 --> 00:33:37.880
thing that lets you get the indexes as well, enumerate that list.


00:33:37.880 --> 00:33:43.140
And then it says, you know, and then it accessed the value again, inside the loop


00:33:43.140 --> 00:33:46.380
by going to the original list and accessing using the index.


00:33:46.380 --> 00:33:50.680
And I just sat there and I kind of half laugh, half cries.


00:33:50.680 --> 00:33:54.480
It's just like there is so much, this is so convoluted.


00:33:54.480 --> 00:33:58.480
And all I had to do was take all that logic out and just say


00:33:58.480 --> 00:34:02.340
for item in original iterable, and then item was the thing.


00:34:02.340 --> 00:34:06.340
But what had happened was that they didn't understand what was really happening in a for loop.


00:34:06.340 --> 00:34:09.240
They were still thinking C or C++.


00:34:09.240 --> 00:34:13.240
And the thing is that Python has these two magic methods called iter and next.


00:34:13.240 --> 00:34:19.560
Iter just says, give me the thing I can use that has the next operator that knows where it is in the list.


00:34:19.560 --> 00:34:20.560
I'm gonna leave it at that.


00:34:20.560 --> 00:34:22.160
And the next just says, give me the next item.


00:34:22.160 --> 00:34:24.520
That's all it is. Just give me the next item.


00:34:24.520 --> 00:34:28.800
All a for loop ever does is it grabs that, is it calls that next.


00:34:28.800 --> 00:34:29.800
It's like, give me the next thing.


00:34:29.800 --> 00:34:32.280
All right, good. I'm done. Give me the next thing. Give me the next thing. Give me the next thing.


00:34:32.280 --> 00:34:38.880
You can write entire classes that behave like this, even generate the value at that moment.


00:34:38.880 --> 00:34:40.680
It's called lazy iteration.


00:34:40.680 --> 00:34:44.200
You can actually generate the next value when it's wanted, not a moment sooner,


00:34:44.200 --> 00:34:47.600
which means you only ever have one value in memory sometimes.


00:34:47.600 --> 00:34:49.600
And then you can just put that in the for loop.


00:34:49.600 --> 00:34:53.920
You come up with any arbitrary name for when you access it for each thing in


00:34:53.920 --> 00:34:57.800
iterable and name thing, whatever you want, and then use it directly in your code.


00:34:57.800 --> 00:35:02.280
And I wish someone had told me that a lot sooner, discover that about three


00:35:02.280 --> 00:35:04.720
years into my journey, I'm like, Oh my gosh, I've been making lists out of


00:35:04.720 --> 00:35:05.840
everything and I've been doing it.


00:35:05.840 --> 00:35:07.080
It's like a waste.


00:35:07.080 --> 00:35:09.280
- Yeah, and you know, the yield keyword,


00:35:09.280 --> 00:35:12.240
obviously is a super easy way to do that lazy iteration


00:35:12.240 --> 00:35:14.880
that you talk about, but it also is really important


00:35:14.880 --> 00:35:16.680
for things like databases, right?


00:35:16.680 --> 00:35:17.520
- Yeah.


00:35:17.520 --> 00:35:18.340
- If you talk SQLAlchemy, right?


00:35:18.340 --> 00:35:20.480
I'm gonna do a query, I could call the all method


00:35:20.480 --> 00:35:22.240
and turn it into an in-memory list,


00:35:22.240 --> 00:35:23.520
or I could, if I don't need that,


00:35:23.520 --> 00:35:25.200
I could just loop over it, right?


00:35:25.200 --> 00:35:26.920
And kind of read it cursor style,


00:35:26.920 --> 00:35:29.360
potentially stop talking to the database halfway through.


00:35:29.360 --> 00:35:30.200
- Exactly.


00:35:30.200 --> 00:35:31.880
If I only need it, I don't need the rest of the data.


00:35:31.880 --> 00:35:32.720
- Exactly.


00:35:32.720 --> 00:35:33.540
- Yeah, exactly.


00:35:33.540 --> 00:35:34.380
Yeah, interesting.


00:35:34.380 --> 00:35:35.220
Cool.


00:35:35.220 --> 00:35:41.620
I think iteration is quite, it's settled because there's only two types of loops in Python


00:35:41.620 --> 00:35:47.700
and usually we're using the for loops, but the variations, there's just so many of them,


00:35:47.700 --> 00:35:48.700
right?


00:35:48.700 --> 00:35:51.380
You can have your for loop that just goes over a thing, but what if you need the index


00:35:51.380 --> 00:35:54.660
like you described, not for this improper use, but sometimes you actually still do need


00:35:54.660 --> 00:35:55.660
the index.


00:35:55.660 --> 00:36:00.180
So you could do enumerate of that thing and get a tuple, but you could take it to another


00:36:00.180 --> 00:36:04.980
level do tuple unpacking and say like index comma value in enumerate of things.


00:36:04.980 --> 00:36:05.460
Right.


00:36:05.460 --> 00:36:08.300
And you get it back and you can unpack a dictionary too.


00:36:08.300 --> 00:36:10.420
You can unpack a tuple with that in the dictionary.


00:36:10.420 --> 00:36:13.900
There's this whole library and it built in a Python called inner tools.


00:36:13.900 --> 00:36:17.580
And if you ever have, you know, 10 minutes over coffee, just pull up the


00:36:17.580 --> 00:36:20.660
documentation for inner tools and just kind of scroll through there's some neat


00:36:20.660 --> 00:36:25.140
stuff, like you can, you can like find every possible combination of three


00:36:25.140 --> 00:36:27.860
different lists, I just give it three different lists and this is one that


00:36:27.860 --> 00:36:30.540
It'll take all three of them, just give you every single possible


00:36:30.540 --> 00:36:32.220
combination of it, actually use it in the book.


00:36:32.220 --> 00:36:35.300
And it's just, there's all these neat things you can do with iterables.


00:36:35.300 --> 00:36:36.700
And some of them don't even have to stop.


00:36:36.700 --> 00:36:39.820
There are infinite iterables where you can just say, I want to get


00:36:39.820 --> 00:36:42.060
this sequence repeating infinitely.


00:36:42.060 --> 00:36:44.420
One, two, three, one, two, three, one, two, three, one, two, three, one, two, three,


00:36:44.420 --> 00:36:46.060
one, two, three, and two lines of code.


00:36:46.060 --> 00:36:47.460
And you can have that repeating forever.


00:36:47.460 --> 00:36:51.620
And if you're using an old fashioned while loop or an old fashioned C++


00:36:51.620 --> 00:36:53.700
style for loop, that would be multiple lines of code.


00:36:53.700 --> 00:36:56.300
Like, you don't have to keep track of the state and all that stuff.


00:36:56.300 --> 00:36:57.540
I think it's two lines.


00:36:57.580 --> 00:36:58.820
- Yeah, it's amazing.


00:36:58.820 --> 00:37:00.460
Yeah, so there's a lot of depth,


00:37:00.460 --> 00:37:02.780
even though it seems so simple when you first look at it.


00:37:02.780 --> 00:37:05.180
Closely related to that are comprehensions.


00:37:05.180 --> 00:37:07.460
- Yes. - Like a list comprehension.


00:37:07.460 --> 00:37:10.500
People often see a list comprehension


00:37:10.500 --> 00:37:12.420
or a set comprehension and go,


00:37:12.420 --> 00:37:13.580
especially a list comprehension,


00:37:13.580 --> 00:37:15.460
they're like, "Oh, that's the same thing as a for loop."


00:37:15.460 --> 00:37:17.800
Where I create, before the for loop, I create a list,


00:37:17.800 --> 00:37:20.080
and then in the for loop, I add the thing to the list,


00:37:20.080 --> 00:37:21.120
and these are the same.


00:37:21.120 --> 00:37:22.220
May have the same outcome,


00:37:22.220 --> 00:37:24.260
but they're not actually the same thing.


00:37:24.260 --> 00:37:25.460
- They're very different. - The runtime performance


00:37:25.460 --> 00:37:27.380
is not the same.


00:37:27.380 --> 00:37:30.540
The bytecode implementation of those two things is not the same.


00:37:30.540 --> 00:37:34.400
This is like a nonstop debate I have on YouTube whenever I put a video and


00:37:34.400 --> 00:37:37.200
mention something about list comprehensions, they're like, that's just a for loop.


00:37:37.200 --> 00:37:38.980
It's not actually just a for loop.


00:37:38.980 --> 00:37:43.640
It's like a kind of accomplishing the same thing, but we now have for


00:37:43.640 --> 00:37:50.280
potentially 312, Carl Meyer put out a PEP 709 called inlined list


00:37:50.280 --> 00:37:55.700
comprehensions, which are supposed to take some of the mostly invisible


00:37:55.700 --> 00:37:57.380
behind the scene implementation and make


00:37:57.380 --> 00:37:59.380
comprehensions two times faster.


00:37:59.380 --> 00:38:01.700
I believe they're already faster than this looping


00:38:01.700 --> 00:38:03.700
story I talked about, but this would make them


00:38:03.700 --> 00:38:06.100
faster still, which is pretty cool.


00:38:06.100 --> 00:38:06.600
Yeah.


00:38:06.600 --> 00:38:08.940
Wow. How does this syntax work?


00:38:08.940 --> 00:38:12.100
I'm curious. It's just like, it's just an internal change?


00:38:12.100 --> 00:38:12.980
Okay.


00:38:12.980 --> 00:38:14.900
So the syntax is unchanged.


00:38:14.900 --> 00:38:17.780
Yeah. So here's the magic of list comprehensions


00:38:17.780 --> 00:38:19.780
that's funky that people maybe aren't aware of.


00:38:19.780 --> 00:38:23.140
Is it, it used to actually create a list comprehension


00:38:23.140 --> 00:38:25.380
object that implemented the loop


00:38:25.380 --> 00:38:30.380
in a function and then it called that function as if you'd like nested a function


00:38:30.380 --> 00:38:32.880
to create isolation of the list comprehension.


00:38:32.880 --> 00:38:37.180
So that created a stack frame, that created an object, then it did function


00:38:37.180 --> 00:38:41.080
in direction and all those things made it slower than it needs to be. So now


00:38:41.080 --> 00:38:47.580
they create a new load fast and clear byte code operation that like stores the state of the function


00:38:47.580 --> 00:38:53.280
then does the list comprehension and then pops it back off the stack to unwind it. So


00:38:53.280 --> 00:38:55.000
Anyway, comprehensions are interesting.


00:38:55.000 --> 00:38:57.000
I just wanted to, this is like kind of a brand new thing.


00:38:57.000 --> 00:38:57.800
That's cool.


00:38:57.800 --> 00:38:59.080
That's coming along.


00:38:59.080 --> 00:39:00.720
That might be interesting for people.


00:39:00.720 --> 00:39:05.160
Well, I think it's worth mentioning then that what a list comprehension really is.


00:39:05.160 --> 00:39:09.960
So like if I unpacked it, because people think, oh, people use that term very loosely a lot of times.


00:39:09.960 --> 00:39:13.080
They say, well, it's a list comprehension, but what is a list comprehension?


00:39:13.080 --> 00:39:20.720
And if I unpack that, what it really is, is it is a generator expression


00:39:20.720 --> 00:39:23.980
that is being unpacked into a list. So


00:39:23.980 --> 00:39:25.760
what's a generator expression? Generator


00:39:25.760 --> 00:39:27.400
expression is a type of generator. What's


00:39:27.400 --> 00:39:30.800
the generator? A generator is a function


00:39:30.800 --> 00:39:33.780
or type of function that is itself


00:39:33.780 --> 00:39:36.800
iterable. So that's where this is. That's


00:39:36.800 --> 00:39:38.960
where this is critical is that a


00:39:38.960 --> 00:39:41.180
generator you can you can write a


00:39:41.180 --> 00:39:43.280
generator that what wouldn't call it that


00:39:43.280 --> 00:39:44.600
it has you mentioned that earlier this


00:39:44.600 --> 00:39:47.680
yield keyword and so you can do whatever


00:39:47.680 --> 00:39:49.960
you want in this function. You can write


00:39:49.960 --> 00:39:52.440
it however much logic you want, every time you hit the yield


00:39:52.440 --> 00:39:55.900
statement, it will return that value and then it's going to


00:39:55.900 --> 00:39:59.240
wait for the next call, then the next iteration of that, like the


00:39:59.240 --> 00:40:01.960
next call to next on that generator, and then it's going


00:40:01.960 --> 00:40:04.000
to run through again until it hits a yield. And then it's


00:40:04.000 --> 00:40:06.800
going to stop returning that value and wait again. And you


00:40:06.800 --> 00:40:09.760
can do some incredible things with these. But once you


00:40:09.760 --> 00:40:13.080
understand the generator, which are incredibly powerful tools,


00:40:13.080 --> 00:40:17.080
then you can write a generator expression, which is I had


00:40:17.080 --> 00:40:20.940
discovered later, a generator expression is to a generator as a lambda as to a


00:40:20.940 --> 00:40:26.340
function. It's an anonymous generator. That's all it is. A lambda is just a very


00:40:26.340 --> 00:40:31.740
small inline anonymous function. Has the logic, it can take in some values, return


00:40:31.740 --> 00:40:35.800
some values. It's a lot simpler, a lot shorter, and you do it right in place. So


00:40:35.800 --> 00:40:38.260
you're not having to go off somewhere and write a different function and come


00:40:38.260 --> 00:40:42.240
back. That's why we have anonymous functions is so that we can just do it


00:40:42.240 --> 00:40:46.200
like, like you see there at the bottom, reduce and just some, some rules right


00:40:46.200 --> 00:40:48.320
there instead of writing a separate function, generate


00:40:48.320 --> 00:40:50.520
expression, same sort of thing. We're doing writing some


00:40:50.520 --> 00:40:54.440
generator logic, it's shorter, it's creating a generator, but


00:40:54.440 --> 00:40:57.520
it's just a lot smaller. And if you just wrap it in in


00:40:57.520 --> 00:41:00.840
parentheses, you can use it as a generator. But when you change


00:41:00.840 --> 00:41:04.120
those parentheses to be square brackets, what happens is you're


00:41:04.120 --> 00:41:07.280
running that generator, and then you're loading all the values


00:41:07.280 --> 00:41:11.640
into the list. You do it in in curly braces, you're creating a


00:41:11.640 --> 00:41:15.640
set or if you're if you're doing the same thing, but you are the


00:41:15.640 --> 00:41:18.360
return value in each step is a key value pair,


00:41:18.360 --> 00:41:19.680
then you're going to create a dictionary.


00:41:19.680 --> 00:41:21.600
But all you're really doing is unpacking


00:41:21.600 --> 00:41:23.480
that generator into a data structure.


00:41:23.480 --> 00:41:26.400
So sometimes you want to think when you're mucking about with these,


00:41:26.400 --> 00:41:30.640
do you really want the data structure when you're done,


00:41:30.640 --> 00:41:32.380
or do you just want to go over the values?


00:41:32.380 --> 00:41:34.080
Maybe you can just write a generator expression.


00:41:34.080 --> 00:41:35.560
>> Yeah, the difference is super subtle.


00:41:35.560 --> 00:41:37.200
Like do you have square brackets or do you have


00:41:37.200 --> 00:41:39.760
parentheses around the expression,


00:41:39.760 --> 00:41:44.480
but the effect or consequence of that is very significant at runtime.


00:41:44.480 --> 00:41:46.480
It's kind of like that example you talked about,


00:41:46.480 --> 00:41:49.480
putting everything in a list and looping over it or just looping over it.


00:41:49.480 --> 00:41:50.360
Right?


00:41:50.360 --> 00:41:51.200
Exactly.


00:41:51.200 --> 00:41:55.880
And because these one-liners and we as coders tend to get addicted to these one-liners.


00:41:55.880 --> 00:41:58.080
It's like, oh, look at all the cool things I can do.


00:41:58.080 --> 00:41:59.440
I have a couple of examples in the book.


00:41:59.440 --> 00:42:01.840
Some real list comprehensions I've come across


00:42:01.840 --> 00:42:04.000
or some colleagues of mine have come across where it's like,


00:42:04.000 --> 00:42:08.280
it's multiple lines and that's a bad list comprehension.


00:42:08.280 --> 00:42:09.800
That's a bad generator expression.


00:42:09.800 --> 00:42:11.880
Just like you don't want to have a multi-line lambda.


00:42:11.880 --> 00:42:13.960
At that point, write a function.


00:42:13.960 --> 00:42:16.960
Generator expressions and lambdas are supposed to be these really small,


00:42:16.960 --> 00:42:18.880
short in place bits of logic.


00:42:18.880 --> 00:42:20.680
And if it's getting complicated,


00:42:20.680 --> 00:42:22.160
write the full size thing.


00:42:22.160 --> 00:42:23.760
It's a lot easier to debug.


00:42:23.760 --> 00:42:25.600
If nothing else, it's easier to debug,


00:42:25.600 --> 00:42:26.960
but it's also a lot easier to read.


00:42:26.960 --> 00:42:28.400
It is. It is.


00:42:28.400 --> 00:42:30.120
Just while we're kind of


00:42:30.120 --> 00:42:31.520
ranching on these things, like,


00:42:31.520 --> 00:42:34.080
I wish there was a way to specify a sort


00:42:34.080 --> 00:42:36.120
in these list comprehensions,


00:42:36.120 --> 00:42:37.720
generator expressions, and


00:42:37.720 --> 00:42:39.240
maybe not the generators,


00:42:39.240 --> 00:42:40.440
because that gets tricky, but


00:42:40.440 --> 00:42:41.600
so often I find myself,


00:42:41.600 --> 00:42:43.080
I'm doing a list comprehension,


00:42:43.080 --> 00:42:44.880
And then I got to turn around and sort it.


00:42:44.880 --> 00:42:47.820
Like if it could just, just add that in there, that would make me happy, but all


00:42:47.820 --> 00:42:54.240
right, moving on packaging, deciding on packaging and all that right up front.


00:42:54.240 --> 00:42:57.360
Actually, before we get to that, I guess the other one that you threw in


00:42:57.360 --> 00:42:58.520
here is virtual environments.


00:42:58.520 --> 00:42:59.040
Indeed.


00:42:59.040 --> 00:42:59.400
Yeah.


00:42:59.400 --> 00:43:01.400
Virtual environments use them.


00:43:01.400 --> 00:43:04.920
There'll be only, I avoided them for years because I thought, oh, these are scary.


00:43:04.920 --> 00:43:06.120
I don't understand them.


00:43:06.120 --> 00:43:07.440
They're not scary.


00:43:07.440 --> 00:43:10.680
I'm actually gonna, I'm actually gonna hijack something I learned from a, one of


00:43:10.680 --> 00:43:14.280
I guess on my own podcast recently is what a containers actually are.


00:43:14.280 --> 00:43:17.200
By the way, Docker containers, this is where this is relevant.


00:43:17.200 --> 00:43:19.040
You know what a Docker container actually is?


00:43:19.040 --> 00:43:22.720
Is it's the folder on your operating system and it's just changing the root.


00:43:22.720 --> 00:43:24.880
So when you're working inside of it, it's just changing the root.


00:43:24.880 --> 00:43:27.920
That there's a bunch of magic logic around that, but that's all it is.


00:43:27.920 --> 00:43:31.640
It's like, it's pretending that that folder is the root and


00:43:31.640 --> 00:43:32.960
it's running things accordingly.


00:43:32.960 --> 00:43:35.360
That's all a virtual environment really is doing either.


00:43:35.360 --> 00:43:37.840
It's so there's not a lot of difference between.


00:43:37.840 --> 00:43:39.960
It lies to Python about the path.


00:43:39.960 --> 00:43:40.360
Yeah.


00:43:40.360 --> 00:43:43.360
It's not a lot of difference in a virtual environment and a Docker image.


00:43:43.360 --> 00:43:45.760
Like they're the same fundamental concept.


00:43:45.760 --> 00:43:49.560
So all you're doing is you're creating this little spot on here, this little folder,


00:43:49.560 --> 00:43:52.260
and you're saying, "These are my Python packages."


00:43:52.260 --> 00:43:54.360
And unless you tell it otherwise,


00:43:54.360 --> 00:43:56.760
"Don't go looking anywhere else. These are the ones I want to use."


00:43:56.760 --> 00:43:59.460
And they're super easy to create.


00:43:59.460 --> 00:44:01.360
It's like one line to create a virtual environment.


00:44:01.360 --> 00:44:04.760
And it lets you maintain exactly the packages you want


00:44:04.760 --> 00:44:07.060
for that particular situation.


00:44:07.060 --> 00:44:08.060
And it's great.


00:44:08.060 --> 00:44:11.180
It is, yeah. Once you get used to it, it's great.


00:44:11.180 --> 00:44:13.900
I remember it being frustrating at the beginning.


00:44:13.900 --> 00:44:17.060
You're like, "Ah, I don't remember exactly how do I create the environment?


00:44:17.060 --> 00:44:20.060
How do I activate it? How do I know? Do I really need this?"


00:44:20.060 --> 00:44:23.340
And yeah, I don't start any projects without having them as


00:44:23.340 --> 00:44:26.540
just straight up, use them right away. Like, absolutely.


00:44:26.540 --> 00:44:29.620
I probably have created them for projects that don't even have external dependencies


00:44:29.620 --> 00:44:31.220
because I was just like on autopilot.


00:44:31.220 --> 00:44:33.500
Like, "Oh, actually I didn't need that, but whatever. It's still good to have."


00:44:33.500 --> 00:44:36.820
Yeah, absolutely. It's a control which Python version you're using


00:44:36.820 --> 00:44:38.860
and then you can install whatever packages you want.


00:44:38.860 --> 00:44:42.420
You don't not worry about messing up your system or user scope packages.


00:44:42.420 --> 00:44:44.340
And a coworker recently said,


00:44:44.340 --> 00:44:47.020
I dream of the day when I can actually remember how to activate this,


00:44:47.020 --> 00:44:48.780
but it's actually really easy.


00:44:48.780 --> 00:44:52.380
So once you, so assuming you know the name of the folder,


00:44:52.380 --> 00:44:55.500
you can pick the name of the folder you use for your virtual environment.


00:44:55.500 --> 00:44:57.940
Traditionally, it's called like VENV.


00:44:57.940 --> 00:44:59.940
And it's, here's the thing to remember,


00:44:59.940 --> 00:45:02.260
you don't actually have to activate your virtual environment.


00:45:02.260 --> 00:45:03.660
Put that in your mind for a moment.


00:45:03.660 --> 00:45:06.740
You can run things directly in the virtual environment.


00:45:06.740 --> 00:45:10.860
So in Unix systems like Linux and Mac, there's a bin folder.


00:45:10.860 --> 00:45:15.420
So them slash bin slash and then whatever Python by whatever


00:45:15.420 --> 00:45:16.840
Python executable you want to run.


00:45:16.840 --> 00:45:19.180
It could be Python, it could be pip, it could be your own package.


00:45:19.180 --> 00:45:22.520
You can actually just navigate into that bin folder.


00:45:22.520 --> 00:45:27.620
And so I can say them bin pip, and I've got the pip and that knows to only


00:45:27.620 --> 00:45:29.420
work within its virtual environment.


00:45:29.420 --> 00:45:30.940
It's not going to break out of that container.


00:45:30.940 --> 00:45:33.980
Once you understand that, here's where the activate script is.


00:45:33.980 --> 00:45:35.260
Them bin activate.


00:45:35.500 --> 00:45:36.780
It lives in the bin file.


00:45:36.780 --> 00:45:37.100
Yeah.


00:45:37.100 --> 00:45:39.740
And if you're on windows, the only thing you're changing is you're going


00:45:39.740 --> 00:45:42.740
from bin to capital S scripts.


00:45:42.740 --> 00:45:46.740
And then the things have an ending of like either dot bad or dot PS one,


00:45:46.740 --> 00:45:49.860
depending on what you're, what you're, you know, what show you're using, but


00:45:49.860 --> 00:45:52.300
that's the structure of a virtual environment.


00:45:52.300 --> 00:45:54.180
And once you understand that they're a little over scary.


00:45:54.180 --> 00:45:54.580
Yeah.


00:45:54.580 --> 00:46:00.460
My RC file, my, for my user profile on my Mac is just full of, here's the


00:46:00.460 --> 00:46:03.820
Python executable in some virtual environment, and here's the script and


00:46:03.820 --> 00:46:06.980
and commands to send to it for like little aliases and stuff.


00:46:06.980 --> 00:46:09.100
And like none of those activate the virtual environments.


00:46:09.100 --> 00:46:11.500
They just run the Python in the virtual environment


00:46:11.500 --> 00:46:12.860
to make all the magic happen.


00:46:12.860 --> 00:46:16.260
Another thing I would recommend is people think about


00:46:16.260 --> 00:46:18.900
creating aliases that make virtual environments


00:46:18.900 --> 00:46:20.700
happier and easier to use.


00:46:20.700 --> 00:46:23.100
So for example, and you could do this in PowerShell


00:46:23.100 --> 00:46:25.460
on Windows, you can obviously do it in your RC files


00:46:25.460 --> 00:46:27.020
on Mac and Linux.


00:46:27.020 --> 00:46:30.100
So for example, I have VNV, which is for VENV,


00:46:30.100 --> 00:46:32.500
but I don't want it to accidentally change the directory


00:46:32.500 --> 00:46:34.340
and if you haven't, like whatever.


00:46:34.340 --> 00:46:35.480
I just have a short version,


00:46:35.480 --> 00:46:36.920
so I know it's something slightly different,


00:46:36.920 --> 00:46:38.700
but it'll go run the virtual environment


00:46:38.700 --> 00:46:42.340
and it'll always remember to add --prompt=.


00:46:42.340 --> 00:46:43.860
which will make the virtual environment


00:46:43.860 --> 00:46:45.420
not just be called VE and V,


00:46:45.420 --> 00:46:48.580
but it'll be called the name of the project that it's in.


00:46:48.580 --> 00:46:51.220
So for example, if it's in like Talk Python,


00:46:51.220 --> 00:46:52.460
like the virtual environment,


00:46:52.460 --> 00:46:53.300
when I activate it,


00:46:53.300 --> 00:46:55.820
it will say it's the virtual environment Talk Python, right?


00:46:55.820 --> 00:46:57.140
And then it activates it.


00:46:57.140 --> 00:47:00.620
And then I think this is almost a bug in Python


00:47:00.620 --> 00:47:05.160
that most of the time, I would say like 49 weeks


00:47:05.160 --> 00:47:07.480
out of the year, when I create a virtual environment,


00:47:07.480 --> 00:47:10.500
the first thing I hear is, "Warning, your pip is out of date."


00:47:10.500 --> 00:47:13.100
You know, like, okay, well, I'm starting a new project.


00:47:13.100 --> 00:47:14.420
How about we start with a new one?


00:47:14.420 --> 00:47:16.340
Let's just go with that right now, right?


00:47:16.340 --> 00:47:19.900
And so my, just that is, I always want the new one.


00:47:19.900 --> 00:47:22.460
I don't ever want the old one because this is brand new.


00:47:22.460 --> 00:47:24.020
So I want the new one.


00:47:24.020 --> 00:47:24.900
Why don't we fix that?


00:47:24.900 --> 00:47:28.500
So my alias then says, pip install -upip,


00:47:28.500 --> 00:47:30.260
setup tools, wheels, pip-tools, et cetera,


00:47:30.260 --> 00:47:31.600
and just ditches that output.


00:47:31.600 --> 00:47:34.000
So like, right, immediately, like I have,


00:47:34.000 --> 00:47:35.000
when I create a virtual environment,


00:47:35.000 --> 00:47:36.080
it's immediately active


00:47:36.080 --> 00:47:37.820
and it's immediately named the project


00:47:37.820 --> 00:47:39.580
and it's immediately up to date.


00:47:39.580 --> 00:47:41.940
So I don't see those silly warnings, at least for a while.


00:47:41.940 --> 00:47:44.560
And all I got to remember is type VNV, boom.


00:47:44.560 --> 00:47:45.400
And that's it, right?


00:47:45.400 --> 00:47:46.340
So if you get into this,


00:47:46.340 --> 00:47:47.800
if you just do a few little steps.


00:47:47.800 --> 00:47:49.120
- I do this too.


00:47:49.120 --> 00:47:50.400
- Yeah, yeah, I imagine you did.


00:47:50.400 --> 00:47:53.120
And so it's, I just strongly encourage people


00:47:53.120 --> 00:47:55.120
to somehow either do this in PowerShell


00:47:55.120 --> 00:47:56.800
or do this in their terminal setup


00:47:56.800 --> 00:48:00.200
because like that big long thing to type, that's a hassle.


00:48:00.200 --> 00:48:03.080
Three letters is not a hassle and they just makes it,


00:48:03.080 --> 00:48:05.080
there's something about lowering the friction


00:48:05.080 --> 00:48:07.080
that makes it really nice.


00:48:07.080 --> 00:48:09.080
- And there's tools you can also install that do it,


00:48:09.080 --> 00:48:11.080
but like I recommend just writing your own aliases too


00:48:11.080 --> 00:48:13.080
because everyone's got a sub-different workflow


00:48:13.080 --> 00:48:14.580
instead of perfecting it anyway,


00:48:14.580 --> 00:48:16.580
that's why VIMP has so many options.


00:48:16.580 --> 00:48:19.380
So writing this yourself, it's super easy


00:48:19.380 --> 00:48:21.880
and it teaches you a bit about how it's working


00:48:21.880 --> 00:48:24.880
so that you're not surprised at the results.


00:48:24.880 --> 00:48:26.880
- Yeah, yeah, indeed.


00:48:26.880 --> 00:48:28.880
Okay, now packaging.


00:48:28.880 --> 00:48:35.360
And, I I'm going, I'm going to keep this one super short because it's a deep, deep, deep, deep, deep, deep, deep rabbit hole.


00:48:35.360 --> 00:48:37.040
Figure out your packaging day one.


00:48:37.040 --> 00:48:42.160
Like you get, I will figure out packaging for even figure out what I'm, you know, how I'm building stuff.


00:48:42.160 --> 00:48:51.120
I am just going to set up a basic hello world, and then I'm going to get the packaging work because I actually, and I learned this the hard way.


00:48:51.120 --> 00:48:53.880
I built a project once it took me one month.


00:48:53.880 --> 00:48:55.320
I was very happy with it.


00:48:55.320 --> 00:48:56.080
It was gorgeous.


00:48:56.080 --> 00:48:56.640
It was a game.


00:48:56.640 --> 00:48:58.320
You can actually find it online now.


00:48:58.560 --> 00:49:00.440
I was very happy with myself.


00:49:00.440 --> 00:49:03.120
And then I spent the next two years trying to package the dark peg.


00:49:03.120 --> 00:49:05.040
Turned out it was impossible to package


00:49:05.040 --> 00:49:08.160
because of certain assumptions that one of the libraries I was using made.


00:49:08.160 --> 00:49:09.960
Had I actually tried to package it from the beginning,


00:49:09.960 --> 00:49:11.560
I could have saved myself a heck of a lot of time


00:49:11.560 --> 00:49:12.600
and just used a different library.


00:49:12.600 --> 00:49:16.000
So, you figure it out from day one.


00:49:16.000 --> 00:49:18.280
And then the benefit you get to this is that


00:49:18.280 --> 00:49:20.680
then you are constantly,


00:49:20.680 --> 00:49:22.120
especially if you're doing out of place testing,


00:49:22.120 --> 00:49:23.480
which I strongly recommend,


00:49:23.480 --> 00:49:24.720
run your tests,


00:49:24.720 --> 00:49:26.840
your tests should not be in your source folder,


00:49:26.840 --> 00:49:28.080
put them separate.


00:49:28.080 --> 00:49:34.180
that's going to force you to actually install your package into a virtual environment and then run the test against that package.


00:49:34.180 --> 00:49:36.380
It's not as scary as it sounds. I have a whole,


00:49:36.380 --> 00:49:41.380
by the way, if you go to my website code mouse92.com, I've got a whole talk on this called Escaping the Cardinal Cult.


00:49:41.380 --> 00:49:44.380
And I explain how these patterns work. But


00:49:44.380 --> 00:49:48.780
when you do it that way, that means from day one and ever onward, you are testing your packaging,


00:49:48.780 --> 00:49:54.480
you're testing your assumptions about the working directories and all that. And


00:49:54.480 --> 00:49:58.580
you are testing it in the same way that it's going to be used on someone else's computer.


00:49:58.580 --> 00:50:02.380
So you never again have to have the thing of, well, it works on my machine,


00:50:02.380 --> 00:50:07.980
because you are, all of your tests are depending on actually installing your package.


00:50:07.980 --> 00:50:09.580
So if something breaks,


00:50:09.580 --> 00:50:12.780
you bring in a dependency that just doesn't work with your packaging scheme,


00:50:12.780 --> 00:50:15.880
you know right away and you can make a decision about it.


00:50:15.880 --> 00:50:17.080
Yeah, that's good advice.


00:50:17.080 --> 00:50:20.080
There's a lot of depth to the packaging thing. I had a whole panel on it


00:50:20.080 --> 00:50:21.680
on talkPython not long ago.


00:50:21.680 --> 00:50:22.980
Definitely a lot there.


00:50:22.980 --> 00:50:23.480
No, yeah.


00:50:23.480 --> 00:50:24.920
Deep rabbit hole, but you know what?


00:50:24.920 --> 00:50:25.780
Don't copy it.


00:50:25.780 --> 00:50:27.120
Don't, don't copy, pasta.


00:50:27.120 --> 00:50:27.960
Don't copy paste.


00:50:27.960 --> 00:50:30.320
Find out what the things you're using are doing because.


00:50:30.320 --> 00:50:33.820
All right.


00:50:33.820 --> 00:50:34.920
Last one.


00:50:34.920 --> 00:50:35.380
Yeah.


00:50:35.380 --> 00:50:35.860
Currency.


00:50:35.860 --> 00:50:36.620
Currency.


00:50:36.620 --> 00:50:37.220
Yes.


00:50:37.220 --> 00:50:40.580
Which for years I heard concurrency, asynchrony,


00:50:40.580 --> 00:50:42.920
threading, parallelism, multiprocessing.


00:50:42.920 --> 00:50:46.180
I heard those all used as, as synonyms for one another.


00:50:46.180 --> 00:50:50.320
They're completely different things.


00:50:50.520 --> 00:50:55.720
So, and actually I have to thank the Go Language for teaching me this.


00:50:55.720 --> 00:50:58.120
Thank you Rob Pike for his talk,


00:50:58.120 --> 00:51:00.320
concurrency and parallelism are not the same thing.


00:51:00.320 --> 00:51:03.520
But here's the thing to understand, concurrency is doing,


00:51:03.520 --> 00:51:05.320
you're switching between tasks.


00:51:05.320 --> 00:51:07.520
You're checking your phone and you're talking to your friend.


00:51:07.520 --> 00:51:09.520
Are you doing both at once? No.


00:51:09.520 --> 00:51:13.220
You're not reading stuff on Twitter and listening to what your friend says.


00:51:13.220 --> 00:51:16.920
You're actually switching between the two contexts rapidly.


00:51:16.920 --> 00:51:19.920
You're not really multitasking, you're just changing your focus


00:51:19.920 --> 00:51:22.580
fast enough that no one ever notices the difference. That's


00:51:22.580 --> 00:51:27.340
concurrency. So you have one CPU or potentially, potentially


00:51:27.340 --> 00:51:29.820
multiple remote this where people get confused. Python's


00:51:29.820 --> 00:51:34.300
nice because you're locked the one CPU for concurrency. So it's


00:51:34.300 --> 00:51:36.180
I'm gonna work on this, then I'll work on this and work on


00:51:36.180 --> 00:51:38.380
this, then work on this, it doesn't make your code faster.


00:51:38.380 --> 00:51:40.740
It'll never make your code faster, just like multitasking


00:51:40.740 --> 00:51:43.220
will not make you get through your workday faster. What it's


00:51:43.220 --> 00:51:46.620
going to do is it's going to slow you down. But it doesn't


00:51:46.620 --> 00:51:50.280
look like is in some cases, it'll make your code look


00:51:50.280 --> 00:51:53.040
faster. Because while you're waiting on the user to type in


00:51:53.040 --> 00:51:55.440
their answer, this example I use the book, or you're waiting on


00:51:55.440 --> 00:51:58.380
the user to type in their answer to a question, you're doing some


00:51:58.380 --> 00:52:00.960
math in the background, your IO blocked, you're waiting on


00:52:00.960 --> 00:52:03.520
something over which you have no control, you can do some other


00:52:03.520 --> 00:52:06.720
work while you wait, that's concurrency. And you can do that


00:52:06.720 --> 00:52:09.840
with a synchrony where Python's handling that multitasking, or


00:52:09.840 --> 00:52:12.840
you can do with threading where the operating system is handling


00:52:12.840 --> 00:52:16.000
that multitasking. That's different than parallelism,


00:52:16.000 --> 00:52:19.000
which is where you're actually using different CPU cores and


00:52:19.000 --> 00:52:23.160
you're doing two things at the same time, because you have two


00:52:23.160 --> 00:52:27.400
different CPUs, two different cores working in parallel. And


00:52:27.400 --> 00:52:29.260
they're not depending on one another. Not they're not


00:52:29.260 --> 00:52:33.040
waiting. You're doing multiple tasks at once. Both of them have


00:52:33.040 --> 00:52:35.960
overhead near one is a silver bullet for performance, you're


00:52:35.960 --> 00:52:38.460
really going to have to think a lot about it. But I actually


00:52:38.460 --> 00:52:41.560
like the GIL for this reason, global interpreter lock the much


00:52:41.560 --> 00:52:45.640
aligned thing that stops us from getting free multiprocess


00:52:45.640 --> 00:52:48.920
of free parallelism, free multiprocessing with every thread.


00:52:48.920 --> 00:52:53.680
Because this forces us to actually stop and think, which thing do I need?


00:52:53.680 --> 00:52:56.400
Do I need concurrency or do I need parallelism?


00:52:56.400 --> 00:53:01.840
Because you can get both in Python, but the GIL makes sure that you have to make a decision.


00:53:01.840 --> 00:53:05.800
Because if you want multiprocessing, you're going to have to create different processes,


00:53:05.800 --> 00:53:07.640
spin them off, manage them separately.


00:53:07.640 --> 00:53:12.960
There's more overhead, but you're going to have to address all of those things of how do we share resources,


00:53:12.960 --> 00:53:14.600
which is a really snarly topic.


00:53:14.800 --> 00:53:17.800
And Python doesn't let you pretend that that's not going to be an issue.


00:53:17.800 --> 00:53:19.640
It makes you think about that.


00:53:19.640 --> 00:53:20.880
It does make you think about it.


00:53:20.880 --> 00:53:24.640
While you can't get more done, you can't make an individual thing go


00:53:24.640 --> 00:53:26.920
faster by using concurrency on it.


00:53:26.920 --> 00:53:31.040
You can start a bunch of things that run outside of your control and outside of


00:53:31.040 --> 00:53:32.840
your program, and then get them back.


00:53:32.840 --> 00:53:33.040
Right?


00:53:33.040 --> 00:53:37.520
Like I could issue a web request to three API endpoints, all of them, and then


00:53:37.520 --> 00:53:38.720
start gathering up the answers.


00:53:38.720 --> 00:53:39.960
The first one comes back, right?


00:53:39.960 --> 00:53:43.920
Like you have to think about, I think the main thing to think about here is


00:53:44.160 --> 00:53:48.600
Where am I waiting on something else when you're looking for the


00:53:48.600 --> 00:53:50.200
async and await type of benefits?


00:53:50.200 --> 00:53:51.960
Like, am I waiting on a thing?


00:53:51.960 --> 00:53:53.960
Could I be doing something while I'm waiting?


00:53:53.960 --> 00:53:57.760
And async and await amount, it makes it super easy to do stuff while you're


00:53:57.760 --> 00:54:02.580
waiting, but your program itself is still constrained by the GIL and often


00:54:02.580 --> 00:54:06.480
with async and await, there's not even a second thread involved, right?


00:54:06.480 --> 00:54:09.440
It's just slicing up time, slicing up the current thread.


00:54:09.440 --> 00:54:09.760
Yeah.


00:54:09.760 --> 00:54:12.900
Which I mean, technically is all that's going on with the threads anyway.


00:54:12.900 --> 00:54:14.020
like when you have multiple threads,


00:54:14.020 --> 00:54:16.380
the operating system is now just doing the slicing up.


00:54:16.380 --> 00:54:18.540
You're still constrained to one process.


00:54:18.540 --> 00:54:19.860
Then you need a separate process


00:54:19.860 --> 00:54:21.940
if you want to do multiple things.


00:54:21.940 --> 00:54:23.620
- Yeah, but like my machine has 10 cores.


00:54:23.620 --> 00:54:25.980
It will go across the cores according to the OS,


00:54:25.980 --> 00:54:28.580
but the effect in Python, because of the GIL,


00:54:28.580 --> 00:54:30.340
means it doesn't actually make any difference.


00:54:30.340 --> 00:54:31.260
It's still the same, right?


00:54:31.260 --> 00:54:33.340
But if you get multi-processing, then for sure.


00:54:33.340 --> 00:54:34.860
So yeah, super, super interesting.


00:54:34.860 --> 00:54:37.780
I think one of the things people tell,


00:54:37.780 --> 00:54:39.340
I think people say two things.


00:54:39.340 --> 00:54:41.340
One, asynchronous programming is so hard,


00:54:41.340 --> 00:54:42.420
you should never try it.


00:54:42.420 --> 00:54:45.480
I hear that all the time. It's, it's so complicated. It's so hard.


00:54:45.480 --> 00:54:47.940
You're going to end up with race conditions. Just don't try it.


00:54:47.940 --> 00:54:51.180
Mere mortals don't dare. They only regret.


00:54:51.180 --> 00:54:58.380
Maybe if you're doing like signaled events in C++ across, you know,


00:54:58.380 --> 00:55:03.500
hardware notification, like there are scenarios that are super, super tricky


00:55:03.500 --> 00:55:06.540
using async and await generally don't fall into that.


00:55:06.540 --> 00:55:09.940
Like you write regular code without changing the structure.


00:55:09.940 --> 00:55:12.820
You don't have to have callbacks and signals and locks.


00:55:12.820 --> 00:55:15.820
You just write regular code or you have the async stuff you put away.


00:55:15.820 --> 00:55:17.180
It's kind of the end of the story.


00:55:17.180 --> 00:55:20.260
And it's not necessarily as simple as straight up regular programming, but


00:55:20.260 --> 00:55:22.000
it's, you know, it's like 10% more.


00:55:22.000 --> 00:55:23.380
It's not 10 X more.


00:55:23.380 --> 00:55:23.700
Yeah.


00:55:23.700 --> 00:55:27.460
I think a lot of people for some, I don't understand why, but a lot of people, I


00:55:27.460 --> 00:55:32.020
think they, they want to feel like I've conquered this dragon.


00:55:32.020 --> 00:55:36.300
And if I'm going to tell other people how to do it or what to do, the first


00:55:36.300 --> 00:55:39.420
thing I'm going to tell them is how hard it is and how daunting it is.


00:55:39.420 --> 00:55:41.720
And like, yet I've conquered it and now I will help you.


00:55:41.720 --> 00:55:41.960
Right.


00:55:41.960 --> 00:55:43.520
That doesn't do people a favor.


00:55:43.520 --> 00:55:44.920
I feel that overall.


00:55:44.920 --> 00:55:46.820
I guess so.


00:55:46.820 --> 00:55:50.920
But I, I feel like threading and parallelism lands deeply in that


00:55:50.920 --> 00:55:53.420
space where people are like, Oh, it's super hard.


00:55:53.420 --> 00:55:55.420
And it's not, it really isn't.


00:55:55.420 --> 00:55:58.160
But where it's hard is you, you have to be prepared to really


00:55:58.160 --> 00:55:59.560
think about why do I need it?


00:55:59.560 --> 00:56:05.020
And if I can briefly say, I have two entire chapters in this book on that topic.


00:56:05.020 --> 00:56:05.360
Yeah.


00:56:05.360 --> 00:56:05.860
Cool.


00:56:05.860 --> 00:56:09.060
And I pick one example and it has nothing to do with waiting for a webpage to


00:56:09.060 --> 00:56:12.060
download because that is both overused and something that most of us don't need.


00:56:12.060 --> 00:56:13.980
And I apply a symphony.


00:56:13.980 --> 00:56:14.760
I apply threading.


00:56:14.760 --> 00:56:20.580
I apply parallelism and you actually see all those little concerns of how do you


00:56:20.580 --> 00:56:22.780
handle deadlocking, live locking?


00:56:22.780 --> 00:56:24.740
How do you handle starvation?


00:56:24.740 --> 00:56:27.020
How do you handle the producer consumer problem?


00:56:27.020 --> 00:56:31.160
How do you handle the fact that, huh, I just had a 15 multi, multi processing


00:56:31.160 --> 00:56:33.420
workers and now this thing is like way slower.


00:56:33.420 --> 00:56:33.940
Why?


00:56:33.940 --> 00:56:35.520
I go into all of that.


00:56:35.540 --> 00:56:39.240
And I think that's one thing I wanted to say is when I was writing this book,


00:56:39.240 --> 00:56:43.440
that was the thing that was my chief delight was coming up with examples for


00:56:43.440 --> 00:56:47.340
all of the topics from the simplest, all the way to the most complicated, where I


00:56:47.340 --> 00:56:49.900
did not hold back on the relevant complexity.


00:56:49.900 --> 00:56:53.780
My list comprehensions were the starliest list comprehensions you're


00:56:53.780 --> 00:56:54.840
ever going to find in this tutorial.


00:56:54.840 --> 00:56:57.640
You know, my, you know, I have, I go into recursion.


00:56:57.640 --> 00:57:01.260
I go into, yes, I go into meta classes, whichever one's afraid of, I


00:57:01.260 --> 00:57:02.480
go into all of these things.


00:57:02.720 --> 00:57:06.280
I dig into them, but the complexity is always relevant.


00:57:06.280 --> 00:57:09.100
So you're only going to get the complexity from the topic and


00:57:09.100 --> 00:57:11.900
you're going to understand where all these bits and pieces interplay.


00:57:11.900 --> 00:57:17.980
But the complexity coming in from other irrelevant topics, I try to keep to a


00:57:17.980 --> 00:57:22.340
minimum so you can really focus on understanding, not just the happy path


00:57:22.340 --> 00:57:25.700
of coding, not just the happy path of like, okay, well, you can async this.


00:57:25.700 --> 00:57:26.900
Look how easy that was.


00:57:26.900 --> 00:57:30.200
Well, it's not easy, but it's also not painfully hard.


00:57:30.460 --> 00:57:35.200
you just have to be prepared to think through those different factors.


00:57:35.200 --> 00:57:39.340
And so I focused a lot of time on really helping you learn how to think through


00:57:39.340 --> 00:57:41.340
those factors as it relates to your code.


00:57:41.340 --> 00:57:41.760
Excellent.


00:57:41.760 --> 00:57:45.260
It sounds like a bit of the Einstein philosophy, simple as possible, but not


00:57:45.260 --> 00:57:45.620
simpler.


00:57:45.620 --> 00:57:45.920
Right.


00:57:45.920 --> 00:57:46.500
Exactly.


00:57:46.500 --> 00:57:46.740
Yeah.


00:57:46.740 --> 00:57:47.040
Cool.


00:57:47.040 --> 00:57:49.000
I know I'm last thoughts on the async stuff.


00:57:49.000 --> 00:57:52.900
Like I think a sprinkling of async and await makes massive difference for a lot


00:57:52.900 --> 00:57:53.820
of scenarios.


00:57:53.820 --> 00:57:54.920
And that's pretty straightforward.


00:57:54.920 --> 00:57:58.620
If you're going to try to write trio or some full on framework that deeply


00:57:58.620 --> 00:58:02.820
coordinates and understands it. Like, yeah, that's super, super hard. Again,


00:58:02.820 --> 00:58:06.980
some of the signaling stories I talked about with like C code, that's super


00:58:06.980 --> 00:58:10.340
hard, but this stuff, people, it's pretty approachable. So don't, don't forget


00:58:10.340 --> 00:58:15.380
to check it out. All right. Well, I think that's it for our things we wish we


00:58:15.380 --> 00:58:19.180
knew if we had more time, we could wish upon more things, but this pretty much


00:58:19.180 --> 00:58:22.980
definitely covers it. Doesn't it? Yeah, I think so. Nice. All right. Well,


00:58:22.980 --> 00:58:25.540
before you get out of here, let me ask you the final two questions. If you're


00:58:25.540 --> 00:58:28.580
going to write some code, what editor to use?


00:58:28.580 --> 00:58:31.180
Yeah, you know, for the longest time I was a VS Code guy.


00:58:31.180 --> 00:58:34.700
I still love it, but I broke down and I bought PyCharm professional.


00:58:34.700 --> 00:58:39.700
And I love that because I do a lot of refactoring and PyCharm saves my butt


00:58:39.700 --> 00:58:43.060
so much when it comes to refactoring that I fell in love with it.


00:58:43.060 --> 00:58:44.860
I can't imagine working without it now.


00:58:44.860 --> 00:58:45.780
I hear you.


00:58:45.780 --> 00:58:46.580
So I'm spoiled.


00:58:46.580 --> 00:58:53.140
It does surprise me how people, not just a PyCharm comment, but in general,


00:58:53.140 --> 00:58:56.200
There's a lot of people are like, Oh, I don't really want to get like a new


00:58:56.200 --> 00:59:00.480
computer or I don't really want to pay 20 bucks for this thing that would save


00:59:00.480 --> 00:59:06.640
you thousands of dollars worth of time as you go for, you know, like, so I'm glad.


00:59:06.640 --> 00:59:07.960
Marks on your tools.


00:59:07.960 --> 00:59:10.240
Hey, as far as your budget will allow you.


00:59:10.240 --> 00:59:12.560
And I I've been on both ends of that, that spectrum.


00:59:12.560 --> 00:59:15.640
And as your budget allows you to support on your tools, because third, what


00:59:15.640 --> 00:59:18.940
you're going to be spending most of the day using anyway, and the last thing


00:59:18.940 --> 00:59:21.040
you want is something that you're going to be getting splitters on.


00:59:21.040 --> 00:59:21.480
So


00:59:22.040 --> 00:59:22.440
Indeed.


00:59:22.440 --> 00:59:26.040
And then notable PyPI package, something you're like, all this


00:59:26.040 --> 00:59:26.580
thing's awesome.


00:59:26.580 --> 00:59:28.780
I just ran across XYZ.


00:59:28.780 --> 00:59:30.300
I guess I have two.


00:59:30.300 --> 00:59:34.020
One would be, I think my favorite, and this has certainly gotten plenty of


00:59:34.020 --> 00:59:34.700
press, but I love it.


00:59:34.700 --> 00:59:36.340
It's the hypothesis testing library.


00:59:36.340 --> 00:59:38.260
I love hypothesis.


00:59:38.260 --> 00:59:40.000
Hypothesis is fantastic.


00:59:40.000 --> 00:59:41.860
It will revolutionize the way you write tests.


00:59:41.860 --> 00:59:44.500
It's not as scary as the documentation makes it look.


00:59:44.500 --> 00:59:47.700
If you click on what you can generate and how start there, but I'd go for the


00:59:47.700 --> 00:59:49.540
quick start, grind and then go right to this.


00:59:49.780 --> 00:59:53.680
And it's so cool because you just write these strategies on like, okay, this is


00:59:53.680 --> 00:59:56.540
what my data is kind of sort of supposed to look like.


00:59:56.540 --> 00:59:59.700
And then your test is going to try and break your code.


00:59:59.700 --> 01:00:04.200
I love hypothesis is going for all sorts of garbage at you until it finds a way to


01:00:04.200 --> 01:00:04.800
break your code.


01:00:04.800 --> 01:00:07.760
And then it's going to go, Hey, here's the simplest thing I could find that blew up


01:00:07.760 --> 01:00:08.200
your code.


01:00:08.200 --> 01:00:09.400
It's it lovely.


01:00:09.400 --> 01:00:09.700
Nice.


01:00:09.700 --> 01:00:10.440
So much fun.


01:00:10.440 --> 01:00:14.960
The other favorite package I have is one of my own actually branch detective.


01:00:14.960 --> 01:00:17.280
I built this at two jobs ago.


01:00:17.520 --> 01:00:21.040
And basically, we had the problem where we had these


01:00:21.040 --> 01:00:24.120
diverging branches where we had no choice but to completely


01:00:24.120 --> 01:00:26.760
diverge them and we were cherry picking back and forth. And


01:00:26.760 --> 01:00:29.220
there was always this which commits are in this one that


01:00:29.220 --> 01:00:31.480
aren't in this one, when you're doing cherry picking your


01:00:31.480 --> 01:00:35.880
hashes are complete garbage. So I built this tool that allows


01:00:35.880 --> 01:00:39.080
you to see what's in one branch, it's not in another branch, any


01:00:39.080 --> 01:00:43.000
branch arbitrarily, you can specify day range, it knows how


01:00:43.000 --> 01:00:45.760
to handle cherry picks, it knows how to handle merge revisions or


01:00:45.760 --> 01:00:50.340
filter them out and you can even pass the dash M flag and just get this nice.


01:00:50.340 --> 01:00:52.520
Markdown for using conventional commits.


01:00:52.520 --> 01:00:55.800
We'll just spit out this markdown that you can then copy and paste into your PR


01:00:55.800 --> 01:00:58.800
and say, Hey, here's, here's all, here's the summaries of the


01:00:58.800 --> 01:01:00.520
26 commits I'm putting in here.


01:01:00.520 --> 01:01:06.280
So I use this every single day and I've improved it for every project I'm on so


01:01:06.280 --> 01:01:08.880
far and I, I just, I love it.


01:01:08.880 --> 01:01:09.640
It's my favorite.


01:01:09.640 --> 01:01:10.920
One of my favorite things ever built.


01:01:10.920 --> 01:01:13.440
So you kind of wrote set forget, right?


01:01:13.440 --> 01:01:15.640
Like you can say what's in the set, subtract that set.


01:01:15.640 --> 01:01:18.040
Show me those things. Yeah. Speaking of data structures.


01:01:18.040 --> 01:01:20.280
Exactly. Like what's here. That's not there. Yes.


01:01:20.280 --> 01:01:23.720
Yeah. Cool. All right, Jason. Well, thanks for being here.


01:01:23.720 --> 01:01:27.320
Final call to action. People will get their Python better. What do you tell them?


01:01:27.320 --> 01:01:32.280
Yes. So that's a book I thought is available from wherever you buy books,


01:01:32.280 --> 01:01:38.040
but especially if you go to no starch.com, you can get this comes in ebook or in physical book form.


01:01:38.040 --> 01:01:41.880
And, Hey, you know what? I wrote it and I refer to it every single day because this is


01:01:41.880 --> 01:01:43.880
This is the book I wish I had had.


01:01:43.880 --> 01:01:45.880
And my favorite little feature of this


01:01:45.880 --> 01:01:47.880
is that I have a thing in the back


01:01:47.880 --> 01:01:49.880
with every single command for the debugger.


01:01:49.880 --> 01:01:51.880
Also, I have every single


01:01:51.880 --> 01:01:53.880
Dunder method is also documented in here.


01:01:53.880 --> 01:01:55.880
Which, even the Python docs didn't do that.


01:01:55.880 --> 01:01:57.880
This is the entire core language, bar nothing,


01:01:57.880 --> 01:01:59.880
explained for the


01:01:59.880 --> 01:02:01.880
existing coder. So, check this out.


01:02:01.880 --> 01:02:03.880
From nostars.com.


01:02:03.880 --> 01:02:05.880
Well, thanks for taking the time for being here and enjoy the chat.


01:02:05.880 --> 01:02:07.880
Thank you so much. It's been a pleasure.


01:02:07.880 --> 01:02:09.880
You bet. See you later.


01:02:09.880 --> 01:02:13.060
This has been another episode of Talk Python to Me.


01:02:13.060 --> 01:02:14.520
Thank you to our sponsors.


01:02:14.520 --> 01:02:15.860
Be sure to check out what they're offering.


01:02:15.860 --> 01:02:18.020
It really helps support the show.


01:02:18.020 --> 01:02:19.620
Take some stress out of your life.


01:02:19.620 --> 01:02:21.800
Get notified immediately about errors


01:02:21.800 --> 01:02:23.800
and performance issues in your web


01:02:23.800 --> 01:02:25.720
or mobile applications with Sentry.


01:02:25.720 --> 01:02:30.600
Just visit talkpython.fm/sentry and get started for free.


01:02:30.600 --> 01:02:34.320
And be sure to use the promo code talkpython, all one word.


01:02:34.320 --> 01:02:35.640
Want to level up your Python?


01:02:35.640 --> 01:02:37.420
We have one of the largest catalogs


01:02:37.420 --> 01:02:39.780
of Python video courses over at Talk Python.


01:02:39.780 --> 01:02:44.900
Our content ranges from true beginners to deeply advanced topics like memory and async.


01:02:44.900 --> 01:02:47.580
And best of all, there's not a subscription in sight.


01:02:47.580 --> 01:02:50.540
Check it out for yourself at training.talkpython.fm.


01:02:50.540 --> 01:02:55.160
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.


01:02:55.160 --> 01:02:56.520
We should be right at the top.


01:02:56.520 --> 01:03:02.060
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the Direct


01:03:02.060 --> 01:03:06.620
RSS feed at /rss on talkpython.fm.


01:03:06.620 --> 01:03:09.140
We're live streaming most of our recordings these days.


01:03:09.140 --> 01:03:12.740
If you want to be part of the show and have your comments featured on the air, be sure


01:03:12.740 --> 01:03:17.460
to subscribe to our YouTube channel at talkpython.fm/youtube.


01:03:17.460 --> 01:03:18.700
This is your host Michael Kennedy.


01:03:18.700 --> 01:03:19.900
Thanks so much for listening.


01:03:19.900 --> 01:03:21.140
I really appreciate it.


01:03:21.140 --> 01:03:22.860
Now get out there and write some Python code.


01:03:22.860 --> 01:03:44.860
[MUSIC]

