WEBVTT

00:00:00.000 --> 00:00:05.880
The release of Pydantic 2.0, its partial rewrite in Rust, and its refactoring into Pydantic


00:00:05.880 --> 00:00:09.800
Core and top-level Pydantic in Python is big news.


00:00:09.800 --> 00:00:12.720
In fact, the alpha of Pydantic 2 was just released.


00:00:12.720 --> 00:00:17.780
Of course, these changes will have potentially wide-ranging and positive effects on the libraries


00:00:17.780 --> 00:00:22.600
that are built upon Pydantic, such as FastAPI, Beanie, and others.


00:00:22.600 --> 00:00:26.880
That's why this chance I had to catch up with Samuel Colvin from Pydantic and Sebastian


00:00:26.880 --> 00:00:33.880
Ramirez from FastAPI together live from PyCon 2023 was really timely. It's a super fun and


00:00:33.880 --> 00:00:38.320
wide ranging interview I'm sure you'll enjoy. Plus, there's a bit of an Easter egg in the


00:00:38.320 --> 00:00:43.960
middle. This is Talk Python to Me episode 415 recorded on location at PyCon in Salt


00:00:43.960 --> 00:00:50.960
Lake City on April 23rd, 2023.


00:00:50.960 --> 00:01:05.280
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.


00:01:05.280 --> 00:01:10.200
Follow me on Mastodon, where I'm @mkennedy and follow the podcast using @talkpython,


00:01:10.200 --> 00:01:12.440
both on fosstodon.org.


00:01:12.440 --> 00:01:15.080
Be careful with impersonating accounts on other instances.


00:01:15.080 --> 00:01:16.120
There are many.


00:01:16.120 --> 00:01:18.240
Keep up with the show and listen to over seven years


00:01:18.240 --> 00:01:20.980
of past episodes at talkpython.fm.


00:01:20.980 --> 00:01:23.040
We've started streaming most of our episodes


00:01:23.040 --> 00:01:24.400
live on YouTube.


00:01:24.400 --> 00:01:25.600
Subscribe to our YouTube channel


00:01:25.600 --> 00:01:28.000
over at talkpython.fm/youtube


00:01:28.000 --> 00:01:30.200
to get notified about upcoming shows


00:01:30.200 --> 00:01:31.920
and be part of that episode.


00:01:31.920 --> 00:01:34.360
This episode is sponsored by Sentry.


00:01:34.360 --> 00:01:36.240
Don't let those errors go unnoticed.


00:01:36.240 --> 00:01:37.220
Use Sentry.


00:01:37.220 --> 00:01:40.380
get started today at talkpython.fm/sentry.


00:01:40.380 --> 00:01:42.660
And it's brought to you by InfluxDB.


00:01:42.660 --> 00:01:45.160
InfluxDB is a database purpose-built


00:01:45.160 --> 00:01:47.340
for handling time series data


00:01:47.340 --> 00:01:49.940
at a massive scale for real-time analytics.


00:01:49.940 --> 00:01:53.540
Try it for free at talkpython.fm/influxdb.


00:01:53.540 --> 00:01:56.980
Samuel, Sebastian, super nice to see you here at PyCon.


00:01:56.980 --> 00:01:57.820
Welcome to the show.


00:01:57.820 --> 00:01:59.180
- Thank you very much for having us.


00:01:59.180 --> 00:02:02.820
It's strange and exciting to do this live


00:02:02.820 --> 00:02:04.300
and to see you in person. - It is, yes, I know.


00:02:04.300 --> 00:02:07.880
- Normally it's remote over screen share


00:02:07.880 --> 00:02:09.340
over half the world or something like that.


00:02:09.340 --> 00:02:10.840
- Yeah, I've been able to talk with you,


00:02:10.840 --> 00:02:12.480
like also with Samuel here,


00:02:12.480 --> 00:02:14.680
like it's super cool, super cool to be here.


00:02:14.680 --> 00:02:15.520
- Yeah, thank you very much, yes.


00:02:15.520 --> 00:02:16.360
It's great to be here.


00:02:16.360 --> 00:02:17.520
It's really fun being at PyCon


00:02:17.520 --> 00:02:19.760
and then doing this is like, yeah, even more fun.


00:02:19.760 --> 00:02:21.760
I've done my talk, so I'm much more relaxed


00:02:21.760 --> 00:02:23.960
than I would have been if it had been this time yesterday.


00:02:23.960 --> 00:02:25.880
- I was just thinking, talking to someone else,


00:02:25.880 --> 00:02:28.120
like one of the best parts about giving a talk


00:02:28.120 --> 00:02:30.720
is that when it's over, you can really relax.


00:02:30.720 --> 00:02:31.560
You know what I mean?


00:02:31.560 --> 00:02:33.480
You're like, okay, now I can enjoy the conference.


00:02:33.480 --> 00:02:34.320
- Absolutely, yeah.


00:02:34.320 --> 00:02:35.800
- And the parties, 'cause you can't go too big


00:02:35.800 --> 00:02:37.000
on the parties if you gotta talk.


00:02:37.000 --> 00:02:38.560
- I feel like all the best ones were last night.


00:02:38.560 --> 00:02:39.380
I feel like--


00:02:39.380 --> 00:02:40.880
- I'm afraid, we were at a pretty good one last night.


00:02:40.880 --> 00:02:41.720
(laughing)


00:02:41.720 --> 00:02:42.540
Yeah.


00:02:42.540 --> 00:02:43.380
- Yeah.


00:02:43.380 --> 00:02:44.220
- But that was excellent.


00:02:44.220 --> 00:02:46.660
All right, well, really good to have you both at the show.


00:02:46.660 --> 00:02:49.840
I guess you hardly need introductions.


00:02:49.840 --> 00:02:51.400
You both are doing such cool work.


00:02:51.400 --> 00:02:53.800
We've had you on the show several times each.


00:02:53.800 --> 00:02:56.040
So maybe just, let's start with a catch up.


00:02:56.040 --> 00:02:58.040
Like, you both have lots of big news.


00:02:58.040 --> 00:02:59.880
Don't wanna necessarily spoil too much,


00:02:59.880 --> 00:03:01.400
but you know, what have you been up to?


00:03:01.400 --> 00:03:04.120
Yeah, so I raised money earlier this year.


00:03:04.120 --> 00:03:05.380
Well, it was all sorted last year.


00:03:05.380 --> 00:03:07.040
Money came in in January this year.


00:03:07.040 --> 00:03:08.780
Started a company around Pydantic.


00:03:08.780 --> 00:03:10.620
So I've been busy hiring.


00:03:10.620 --> 00:03:12.260
Got a team of seven now.


00:03:12.260 --> 00:03:14.240
One more going to join in June.


00:03:14.240 --> 00:03:16.580
And yeah, currently we're working full-time


00:03:16.580 --> 00:03:18.980
on Pydantic version two, getting that released.


00:03:18.980 --> 00:03:20.160
And then after that, we're gonna move on


00:03:20.160 --> 00:03:21.780
to the commercial plans,


00:03:21.780 --> 00:03:23.300
which I'm not talking about too much,


00:03:23.300 --> 00:03:25.360
mostly because they're up in the air a bit.


00:03:25.360 --> 00:03:27.060
Also because if you start talking about them,


00:03:27.060 --> 00:03:28.260
you have to finish talking about them,


00:03:28.260 --> 00:03:30.620
and then that's like, I'll just take over the whole podcast.


00:03:30.620 --> 00:03:35.220
So I'll say that, yeah, working on Pydantic V2 for now and then moving on soon.


00:03:35.220 --> 00:03:37.180
Well, first from the whole community, congratulations.


00:03:37.180 --> 00:03:38.580
You must be really thrilled.


00:03:38.580 --> 00:03:40.360
Yeah, it's amazing.


00:03:40.360 --> 00:03:41.500
It's a very surreal, right?


00:03:41.500 --> 00:03:43.940
Because I was going to say, did you see this coming?


00:03:43.940 --> 00:03:45.940
No, I didn't.


00:03:45.940 --> 00:03:50.060
My plan had been to start a different company once Pydantic V2 was done.


00:03:50.060 --> 00:03:55.740
And then in November, Bogumil from Sequoia, who Sebastian knew, Sebastian recommended


00:03:55.740 --> 00:03:56.860
he chatted to me.


00:03:56.860 --> 00:03:57.860
We had a call.


00:03:57.860 --> 00:03:59.120
We had another call two weeks later.


00:03:59.120 --> 00:04:02.680
And then he said, let's have the final meeting with a few more partners to decide whether


00:04:02.680 --> 00:04:04.340
to invest in two weeks time.


00:04:04.340 --> 00:04:07.160
So I thought, oh, I should probably go and speak to some other VCs.


00:04:07.160 --> 00:04:09.080
So Sebastian very kindly got me lots of intros.


00:04:09.080 --> 00:04:10.680
My girlfriend also got me some intros.


00:04:10.680 --> 00:04:12.780
I had like five meetings lined up.


00:04:12.780 --> 00:04:17.300
And then the floodgates opened and I got another 20 or so VCs emailing me being like, please


00:04:17.300 --> 00:04:18.300
can I call?


00:04:18.300 --> 00:04:21.200
Starting to hear about, oh, why are we not part of this?


00:04:21.200 --> 00:04:22.200
Right.


00:04:22.200 --> 00:04:23.320
And then I got COVID.


00:04:23.320 --> 00:04:28.480
So I spent a week locked in the bedroom upstairs doing VC calls, most of them with the camera


00:04:28.480 --> 00:04:30.280
are feeling absolutely horrific.


00:04:30.280 --> 00:04:32.500
And yeah, and then came back full circle,


00:04:32.500 --> 00:04:34.320
back and had the big call with Sequoia


00:04:34.320 --> 00:04:35.720
and took their money.


00:04:35.720 --> 00:04:36.560
And they've been amazing.


00:04:36.560 --> 00:04:37.760
- So it was Sequoia that invested?


00:04:37.760 --> 00:04:38.600
- Yeah.


00:04:38.600 --> 00:04:39.420
- Wow, awesome.


00:04:39.420 --> 00:04:40.680
That's a big name to have behind you.


00:04:40.680 --> 00:04:43.520
- So it's Sequoia and Patek, who are the smaller VC,


00:04:43.520 --> 00:04:44.920
who are like French American,


00:04:44.920 --> 00:04:46.080
and then Irregular Expression,


00:04:46.080 --> 00:04:48.480
which is this really cool CTO network


00:04:48.480 --> 00:04:51.760
based kind of again like New York and Paris,


00:04:51.760 --> 00:04:52.880
and then a bunch of angels.


00:04:52.880 --> 00:04:55.600
- Yeah, last time we spoke it was about Pydantic V2


00:04:55.600 --> 00:04:58.000
and then all of this broke and yeah.


00:04:58.000 --> 00:05:00.160
I feel like I'm just back up to, as in,


00:05:00.160 --> 00:05:02.400
problem was, although I was doing it to speed up,


00:05:02.400 --> 00:05:05.480
that was within two months of basically doing meetings


00:05:05.480 --> 00:05:06.420
and doing legals.


00:05:06.420 --> 00:05:08.080
So I think I've now got a team sufficiently


00:05:08.080 --> 00:05:09.640
that I'm like caught up to where I would have been


00:05:09.640 --> 00:05:12.120
if I had just sat there and written code all along.


00:05:12.120 --> 00:05:12.940
- Yeah.


00:05:12.940 --> 00:05:15.280
That's how it goes, right?


00:05:15.280 --> 00:05:17.960
You gotta put a little more sand in the gears


00:05:17.960 --> 00:05:20.160
to grow, I guess.


00:05:20.160 --> 00:05:21.400
And Sebastian, how about you?


00:05:21.400 --> 00:05:22.600
What have you been up to?


00:05:22.600 --> 00:05:23.440
How have you been?


00:05:23.440 --> 00:05:25.280
- Oh, I've been good.


00:05:25.280 --> 00:05:27.840
Very excited about what they are doing at Pydantic.


00:05:27.840 --> 00:05:30.840
like the team they are assembling is like just amazing.


00:05:30.840 --> 00:05:35.440
And like, yeah, just like recently working a bunch in FastAPI and like


00:05:35.440 --> 00:05:41.540
Dyper and actually like in also some of the low level things of FastAPI and


00:05:41.540 --> 00:05:45.740
also not just FastAPI, but like the things that go underneath. Right now,


00:05:45.740 --> 00:05:49.840
like one of the things that I am pushing for is having documentation of


00:05:49.840 --> 00:05:53.640
the API reference of the reference of the each one of the parameters for


00:05:53.640 --> 00:05:56.040
what it is for each one of the methods, like all the stuff.


00:05:56.040 --> 00:06:06.040
Yeah, and I want to do it in a better way that is more maintainable and that I can test the actual documentation for those parameters and consistency between like,


00:06:06.040 --> 00:06:17.040
there's a bunch of things that I'm trying to do and like it also goes to the low levels of like typing and interacting with the people that is handling typing and like all the stuff that is super cool, super exciting, but like,


00:06:17.040 --> 00:06:20.680
I think it can work and it can make these things have like,


00:06:20.680 --> 00:06:23.280
you know, like the API reference for the tools


00:06:23.280 --> 00:06:25.920
is something that a lot of people have been requesting


00:06:25.920 --> 00:06:28.040
and like being able to have that in a way


00:06:28.040 --> 00:06:31.040
that is easy to maintain, that can work well


00:06:31.040 --> 00:06:32.240
and that I can handle, like,


00:06:32.240 --> 00:06:34.080
I think that's super exciting on that side.


00:06:34.080 --> 00:06:35.200
And on the other side, of course,


00:06:35.200 --> 00:06:38.360
like the integration with Pydantic V2 is super exciting


00:06:38.360 --> 00:06:41.720
now that they have like the first alpha available.


00:06:41.720 --> 00:06:44.240
- It is, I mean, here you are going along,


00:06:44.240 --> 00:06:45.960
working on FastAPI.


00:06:45.960 --> 00:06:49.120
everyone I talked to was just universally impressed with it.


00:06:49.120 --> 00:06:52.800
Honestly, I've never heard a bad thing about FastAPI,


00:06:52.800 --> 00:06:54.460
and people are really enjoying it.


00:06:54.460 --> 00:06:57.800
And then here comes Samuel just changing the foundation,


00:06:57.800 --> 00:06:59.800
changing up Finante.


00:06:59.800 --> 00:07:01.800
- Taking FastAPI.


00:07:01.800 --> 00:07:03.180
- No, no, no, I'm just teasing.


00:07:03.180 --> 00:07:06.440
So how much work is that actually going to be to kind of


00:07:06.440 --> 00:07:09.100
make this change? Is it kind of nothing or is it some work?


00:07:09.100 --> 00:07:11.140
- No, there will be some work in FastAPI.


00:07:11.140 --> 00:07:13.480
The thing is, for final users,


00:07:13.480 --> 00:07:15.600
it will be like almost transparent.


00:07:15.600 --> 00:07:19.760
They will probably, like if they are doing like weird stuff,


00:07:19.760 --> 00:07:22.680
complex things like that touches the corner cases


00:07:22.680 --> 00:07:23.520
or things like that,


00:07:23.520 --> 00:07:25.360
like they will probably have to update some things.


00:07:25.360 --> 00:07:27.040
But for most of the use cases,


00:07:27.040 --> 00:07:29.640
it will be pretty much transparent for people.


00:07:29.640 --> 00:07:30.800
And they will just like get like the,


00:07:30.800 --> 00:07:32.840
like I don't know, like 10, 20X performance


00:07:32.840 --> 00:07:34.040
from Python TV2.


00:07:34.040 --> 00:07:35.280
And also like the--


00:07:35.280 --> 00:07:36.120
- I was gonna suggest on the performance,


00:07:36.120 --> 00:07:37.560
I'm sorry to interrupt you.


00:07:37.560 --> 00:07:39.680
One of the big things that we will be able to,


00:07:39.680 --> 00:07:42.540
you'll be able to drop from FastAPI is the,


00:07:42.540 --> 00:07:43.380
I'm gonna call it hack,


00:07:43.380 --> 00:07:45.440
but it's not your fault, it's my fault.


00:07:45.440 --> 00:07:49.160
of like don't ask the type problem of serialization.


00:07:49.160 --> 00:07:51.360
So I think that the speed up on serialization


00:07:51.360 --> 00:07:53.560
in FastAPI could exceed,


00:07:53.560 --> 00:07:54.920
like it could be even bigger than that.


00:07:54.920 --> 00:07:57.040
I don't know that yet, but I'm really hopeful


00:07:57.040 --> 00:08:00.680
for some massive improvements because of fixes in Pydantic


00:08:00.680 --> 00:08:03.480
that make FastAPI simpler and more elegant.


00:08:03.480 --> 00:08:06.320
- Yeah, and since they're turning off the lights,


00:08:06.320 --> 00:08:07.720
we'll see how long we last here.


00:08:07.720 --> 00:08:08.800
(laughing)


00:08:08.800 --> 00:08:10.680
We'll stay as long as we can.


00:08:10.680 --> 00:08:11.880
If you hear any noise in the background,


00:08:11.880 --> 00:08:14.080
that's 'cause they're trying to tear down PyCon,


00:08:14.080 --> 00:08:14.920
but we're gonna work for it.


00:08:14.920 --> 00:08:16.400
- We're wearing down PyCon around us, it seems.


00:08:16.400 --> 00:08:19.080
- We will not let it be torn down, it will live on.


00:08:19.080 --> 00:08:20.980
- It's not because of Pydantic, we do.


00:08:20.980 --> 00:08:22.080
(laughing)


00:08:22.080 --> 00:08:24.120
- So, yeah, we may have to pause a minute,


00:08:24.120 --> 00:08:25.200
but we'll find out.


00:08:25.200 --> 00:08:29.160
Anyway, from a user for Pydantic, Samuel,


00:08:29.160 --> 00:08:32.280
if you haven't gone, like, deeply gone into, like,


00:08:32.280 --> 00:08:35.080
root object validation and all that kind of stuff,


00:08:35.080 --> 00:08:36.720
it's probably, you won't even know, right?


00:08:36.720 --> 00:08:38.560
- So I think the hardest thing, yeah, you're right,


00:08:38.560 --> 00:08:41.440
the vast majority of your code will either continue to work


00:08:41.440 --> 00:08:42.600
or we'll have a,


00:08:44.660 --> 00:08:45.660
>> We'll have-- >> We're going to crush it.


00:08:45.660 --> 00:08:47.380
>> If you get run over by a forklift,


00:08:47.380 --> 00:08:48.980
it's going to really slow down the development


00:08:48.980 --> 00:08:50.180
of Pydantic, by the way.


00:08:50.180 --> 00:08:53.820
>> We're going to have a mod tool


00:08:53.820 --> 00:08:55.860
to change the name of methods.


00:08:55.860 --> 00:08:58.380
So, with luck, the vast majority


00:08:58.380 --> 00:09:00.740
of the changes should be automated.


00:09:00.740 --> 00:09:02.540
I suspect that, and I was saying this earlier


00:09:02.540 --> 00:09:05.080
in the open space, the hardest thing


00:09:05.080 --> 00:09:07.440
is probably going to be where your API


00:09:07.440 --> 00:09:09.980
subtly changes in its restrictions


00:09:09.980 --> 00:09:11.940
because of effectively edge cases


00:09:11.940 --> 00:09:13.020
that Pydantic has fixed.


00:09:13.020 --> 00:09:14.800
Like, so for example, in Pylantic V1,


00:09:14.800 --> 00:09:17.480
we would coerce a int to a string.


00:09:17.480 --> 00:09:20.600
If you ever passed a string to an int to a string field,


00:09:20.600 --> 00:09:22.040
we would coerce it.


00:09:22.040 --> 00:09:23.800
I think that that's wrong and we shouldn't have done it,


00:09:23.800 --> 00:09:24.840
and so now we don't.


00:09:24.840 --> 00:09:26.000
But I was saying in the example,


00:09:26.000 --> 00:09:28.880
if for some reason you stored your IDs as strings,


00:09:28.880 --> 00:09:32.040
and therefore your API had the ID field as a string,


00:09:32.040 --> 00:09:35.120
but your user was just like pumping them into your API


00:09:35.120 --> 00:09:37.200
as integers 'cause that seemed to make sense to them,


00:09:37.200 --> 00:09:38.320
that's going to break.


00:09:38.320 --> 00:09:40.500
And you probably haven't gotten a unit test that tests that


00:09:40.500 --> 00:09:42.480
because you know your ID field is a string.


00:09:42.480 --> 00:09:44.240
So I feel sorry for those people.


00:09:44.240 --> 00:09:48.960
And my biggest request would be if you're a user,


00:09:48.960 --> 00:09:51.120
try Pydantic v2 as soon as possible.


00:09:51.120 --> 00:09:53.400
I know if you use it via FastAPI, you can't yet,


00:09:53.400 --> 00:09:55.040
but like all the other libraries.


00:09:55.040 --> 00:09:57.800
But the sooner you can try it, the sooner you can tell us,


00:09:57.800 --> 00:09:59.760
and the more easily we can fix things.


00:09:59.760 --> 00:10:02.840
And we are prepared to add compatibility shims.


00:10:02.840 --> 00:10:04.560
- Okay, well, I mean, in Python,


00:10:04.560 --> 00:10:06.760
we have sort of a from futures import,


00:10:06.760 --> 00:10:11.180
well, there'd be from history import type of reverse thing,


00:10:11.180 --> 00:10:14.740
to slow that down or is it going to be a deprecation or is it just...


00:10:14.740 --> 00:10:19.020
So we're doing deprecation warnings everywhere we can or deprecation errors saying this has


00:10:19.020 --> 00:10:21.300
gone away you probably want to replace it with this thing.


00:10:21.300 --> 00:10:22.740
We're working really hard on that.


00:10:22.740 --> 00:10:28.980
We haven't got a like from future import or a compact layer yet for actual like validation


00:10:28.980 --> 00:10:30.980
logic but if we have to we will.


00:10:30.980 --> 00:10:32.940
Yeah okay you'll see right?


00:10:32.940 --> 00:10:34.380
See how much screaming...


00:10:34.380 --> 00:10:38.580
What we didn't want to do was try and guess at what the problems were and build a compatibility


00:10:38.580 --> 00:10:39.580
layer that people didn't need.


00:10:39.580 --> 00:10:40.580
Yeah, of course.


00:10:40.580 --> 00:10:42.180
So that's why we're doing it this way.


00:10:42.180 --> 00:10:43.680
Yeah, that makes a lot of sense.


00:10:43.680 --> 00:10:48.940
You want to go as minimal, backwards, trying to fill those gaps as possible, right?


00:10:48.940 --> 00:10:52.740
And if I'm brutal about it, if, in certain name of big bank that use Pydantic locks and


00:10:52.740 --> 00:10:57.420
never engage with the open source community, get stung by this, they never paid me a penny


00:10:57.420 --> 00:11:01.740
and they've never engaged, then I'm sorry for them, but I'm not as sorry as I would


00:11:01.740 --> 00:11:06.060
be if they had come and reported an issue and tried to help along the way.


00:11:06.060 --> 00:11:07.060
Yeah, yeah.


00:11:07.060 --> 00:11:09.340
Can we work with you to smooth this over?


00:11:09.340 --> 00:11:12.700
you know, worst case, pin it, be, you know, equal, equal,


00:11:12.700 --> 00:11:14.900
Pydantic equal, equal, 1.10.


00:11:14.900 --> 00:11:16.700
- I think we'll carry on supporting


00:11:16.700 --> 00:11:18.780
critical security fixes for a year.


00:11:18.780 --> 00:11:20.660
- Okay, so there's something of an LTS


00:11:20.660 --> 00:11:21.580
type of thing you're thinking?


00:11:21.580 --> 00:11:23.380
- Yeah, for a while we have to, right?


00:11:23.380 --> 00:11:25.300
For a while, and yeah, we'll see,


00:11:25.300 --> 00:11:27.340
look at the download numbers and play it by ear.


00:11:27.340 --> 00:11:28.700
- Yeah, all right, cool.


00:11:28.700 --> 00:11:30.020
While we're talking about compatibility,


00:11:30.020 --> 00:11:34.260
if people are like doing a lot of the overriding functions


00:11:34.260 --> 00:11:35.860
and stuff in their Pydantic models,


00:11:35.860 --> 00:11:37.700
like what do they, what should they expect?


00:11:37.700 --> 00:11:39.240
Too many changes or pretty similar?


00:11:39.240 --> 00:11:44.780
One of the biggest changes is that the init method of a model is now no longer called


00:11:44.780 --> 00:11:47.420
unless you literally call init.


00:11:47.420 --> 00:11:52.580
So if you call model validate or if your model is nested inside another model,


00:11:52.580 --> 00:11:53.980
init is no longer called.


00:11:53.980 --> 00:11:57.700
The solution for that is to use a wrap validator or a model validator,


00:11:57.700 --> 00:12:00.180
but that's going to be one of the pain points for people.


00:12:00.180 --> 00:12:02.540
But it turns out with the Rust API,


00:12:02.540 --> 00:12:05.540
it's literally impossible without a massive performance hit to do that.


00:12:07.420 --> 00:12:10.540
This portion of Talk Python to Me is brought to you by Sentry.


00:12:10.540 --> 00:12:14.860
You know that Sentry captures the errors that would otherwise go unnoticed.


00:12:14.860 --> 00:12:19.100
Of course, they have incredible support for basically any Python framework.


00:12:19.100 --> 00:12:25.580
They have direct integrations with Flask, Django, FastAPI, and even things like AWS Lambda and


00:12:25.580 --> 00:12:30.700
Celery. But did you know they also have native integrations with mobile app frameworks?


00:12:30.700 --> 00:12:36.140
Whether you're building an Android or iOS app or both, you can gain complete visibility into


00:12:36.140 --> 00:12:41.300
your application's correctness both on the mobile side and server side.


00:12:41.300 --> 00:12:46.840
We just completely rewrote Talk Python's mobile apps for taking our courses, and we massively


00:12:46.840 --> 00:12:50.820
benefited from having Sentry integration right from the start.


00:12:50.820 --> 00:12:55.420
We used Flutter for our native mobile framework, and with Sentry, it was literally just two


00:12:55.420 --> 00:12:59.520
lines of code to start capturing errors as soon as they happen.


00:12:59.520 --> 00:13:03.820
Of course, we don't love errors, but we do love making our users happy.


00:13:03.820 --> 00:13:08.880
problems as soon as possible with Sentry on the mobile Flutter code and the Python server


00:13:08.880 --> 00:13:14.740
side code together made understanding error reports a breeze. So whether you're building


00:13:14.740 --> 00:13:20.420
Python server side apps, or mobile apps, or both, give Sentry a try to get a complete


00:13:20.420 --> 00:13:25.380
view of your apps correctness. Thank you to Sentry for sponsoring the show and helping


00:13:25.380 --> 00:13:28.060
us ship more reliable mobile apps to all of you.


00:13:28.060 --> 00:13:30.820
Do you already have a roadmap?


00:13:30.820 --> 00:13:33.580
Have you already tried the alpha on FastAPI?


00:13:33.580 --> 00:13:35.500
Like what's the story for you guys?


00:13:35.500 --> 00:13:36.340
- So like,


00:13:36.340 --> 00:13:37.460
- Pedantic wise.


00:13:37.460 --> 00:13:38.300
- Yeah, yeah.


00:13:38.300 --> 00:13:40.820
So like, we have actually been interacting a lot,


00:13:40.820 --> 00:13:42.620
like with what are the changes that are needed?


00:13:42.620 --> 00:13:43.660
Like what is it gonna be?


00:13:43.660 --> 00:13:44.680
And like, as someone was saying,


00:13:44.680 --> 00:13:48.820
like I have a lot of code that is quite hacky.


00:13:48.820 --> 00:13:51.540
I was actually surprised it didn't break much.


00:13:51.540 --> 00:13:53.300
It just like really worked.


00:13:53.300 --> 00:13:56.220
And like, it's for this particular use case


00:13:56.220 --> 00:13:58.320
where you can have like, they are so loud,


00:13:58.320 --> 00:13:59.960
they really want to tear us down.


00:13:59.960 --> 00:14:02.220
- I know, we might have to be really silent,


00:14:02.220 --> 00:14:03.940
but let's go ahead and finish this up, yeah.


00:14:03.940 --> 00:14:04.780
- So--


00:14:04.780 --> 00:14:05.920
- Wait, what are those like concentration challenges?


00:14:05.920 --> 00:14:07.760
(laughing)


00:14:07.760 --> 00:14:09.980
- Validation error, can it concentrate?


00:14:09.980 --> 00:14:13.640
So imagine this use case where you have user model,


00:14:13.640 --> 00:14:16.660
and then this, you want to return this user model,


00:14:16.660 --> 00:14:19.180
but then you have an authenticated user model,


00:14:19.180 --> 00:14:22.640
as you were showing in the talk, in the PyCon talk.


00:14:22.640 --> 00:14:24.640
And then this authenticated user model


00:14:24.640 --> 00:14:26.440
has a field that is a password.


00:14:26.440 --> 00:14:31.440
If you return that use, the authenticated user directly,


00:14:31.440 --> 00:14:34.160
FastAPI does a lot of tricks to make sure


00:14:34.160 --> 00:14:36.600
that what you receive in the client side


00:14:36.600 --> 00:14:38.840
is the actual user without the password.


00:14:38.840 --> 00:14:40.000
That is the thing that you declared


00:14:40.000 --> 00:14:41.400
that we were going to return.


00:14:41.400 --> 00:14:43.960
But by default, if you don't do it through FastAPI,


00:14:43.960 --> 00:14:46.120
but you do it with just plain Pydantic,


00:14:46.120 --> 00:14:46.960
it will just check like,


00:14:46.960 --> 00:14:48.560
hey, is this an instance of the other?


00:14:48.560 --> 00:14:51.040
And then it will include the field.


00:14:51.040 --> 00:14:54.200
Because like, you know, because in thinking about types,


00:14:54.200 --> 00:14:56.960
it makes sense, like, oh, this is a subclass of that,


00:14:56.960 --> 00:14:58.640
so it makes sense that it's valid.


00:14:58.640 --> 00:15:00.600
But when you think about data in an API,


00:15:00.600 --> 00:15:02.640
it doesn't make sense that it will include more data


00:15:02.640 --> 00:15:03.840
than what it should.


00:15:03.840 --> 00:15:06.320
- Right, right, right, 'cause you don't wanna


00:15:06.320 --> 00:15:09.960
either have a mass injection attack on the inbound data


00:15:09.960 --> 00:15:13.060
or an over-exposure on the way out, right?


00:15:13.060 --> 00:15:14.840
- You know, give away the password from users.


00:15:14.840 --> 00:15:15.840
- Is that bad?


00:15:15.840 --> 00:15:16.840
- I think it's pretty bad.


00:15:16.840 --> 00:15:18.640
- Okay, yeah, all right.


00:15:18.640 --> 00:15:22.020
- You know, for example, some months ago or years


00:15:22.020 --> 00:15:24.900
or something like I remember that the Kaggle API


00:15:24.900 --> 00:15:28.620
was returning some of the hashes of the experiments.


00:15:28.620 --> 00:15:31.340
So like, you know, it's a mistake,


00:15:31.340 --> 00:15:34.020
but it's sad that it could end up just like


00:15:34.020 --> 00:15:36.420
filtering more data than what it should be returning.


00:15:36.420 --> 00:15:38.140
And it's something that can happen very easily.


00:15:38.140 --> 00:15:40.900
It can happen very easily to FastAPI applications


00:15:40.900 --> 00:15:44.140
if people don't specify what is the response model,


00:15:44.140 --> 00:15:45.340
the thing that they want to return,


00:15:45.340 --> 00:15:47.660
and they just return a bunch of data directly.


00:15:47.660 --> 00:15:50.100
So FastAPI does a lot of things to make sure


00:15:50.100 --> 00:15:52.940
that when you declare a response model that


00:15:52.940 --> 00:15:55.620
should filter this data, the data is filtered.


00:15:55.620 --> 00:15:58.780
But that's a lot of code in FastAPI to make it compatible.


00:15:58.780 --> 00:16:00.620
With the new Pydantic V2, that's going


00:16:00.620 --> 00:16:02.340
to be pretty much transparent.


00:16:02.340 --> 00:16:04.100
So that's amazing.


00:16:04.100 --> 00:16:04.820
That is amazing.


00:16:04.820 --> 00:16:06.620
There's going to be a bunch of things that


00:16:06.620 --> 00:16:09.780
require some refactoring and also making sure


00:16:09.780 --> 00:16:13.580
that the Pydantic V1 and V2 are compatible at the same time


00:16:13.580 --> 00:16:17.060
in some way so that people can have a migration path.


00:16:17.060 --> 00:16:20.660
But yeah, we have been making sure that all the things that


00:16:20.660 --> 00:16:22.580
need to be changed or that need to be updated,


00:16:22.580 --> 00:16:25.440
or all the things that need to be exposed from the Pydantic


00:16:25.440 --> 00:16:26.740
side are actually available.


00:16:26.740 --> 00:16:29.460
Yeah, it's awesome that you guys are working so closely together.


00:16:29.460 --> 00:16:30.460
I mean, it's going to make it--


00:16:30.460 --> 00:16:31.180
Yeah, absolutely.


00:16:31.180 --> 00:16:31.820
So--


00:16:31.820 --> 00:16:34.180
In my mind, these two projects are pretty closely tied.


00:16:34.180 --> 00:16:36.620
I know that they're not, but that's a big use case.


00:16:36.620 --> 00:16:37.740
Yeah, I think that's true.


00:16:37.740 --> 00:16:41.620
And we know that FastAPI is by far our biggest dependent.


00:16:41.620 --> 00:16:44.780
But also, Django Ninja, which is, I think, now second or third,


00:16:44.780 --> 00:16:48.020
maybe third after SQL model by stars,


00:16:48.020 --> 00:16:49.820
is like Vitaly who maintains that,


00:16:49.820 --> 00:16:52.020
has been engaging a lot with us on V2.


00:16:52.020 --> 00:16:54.340
So yeah, lots of other projects are interested in it.


00:16:54.340 --> 00:16:56.100
And I think, yeah, lots of people will be able


00:16:56.100 --> 00:16:57.940
to remove messy code because of that problem.


00:16:57.940 --> 00:17:00.000
Because yeah, like the invariance


00:17:00.000 --> 00:17:01.660
of the response interface problem.


00:17:01.660 --> 00:17:02.500
- That's fantastic.


00:17:02.500 --> 00:17:04.540
- Coming back to your previous question about--


00:17:04.540 --> 00:17:05.380
- Before you go to that,


00:17:05.380 --> 00:17:07.380
I think we should probably find out what do you think?


00:17:07.380 --> 00:17:08.220
- Yeah, I think you might be right.


00:17:08.220 --> 00:17:09.300
- Yeah, not even necessarily,


00:17:09.300 --> 00:17:10.500
I think the audio may be okay,


00:17:10.500 --> 00:17:11.700
but just for a concentration,


00:17:11.700 --> 00:17:13.340
it's very loud with the trucks around us.


00:17:13.340 --> 00:17:15.080
I feel like I'm on the deck of the aircraft carrier,


00:17:15.080 --> 00:17:16.040
so I throw things off the side.


00:17:16.040 --> 00:17:17.720
- Yeah, okay, let's pause this for a moment.


00:17:17.720 --> 00:17:19.780
We'll be back, hold on.


00:17:19.780 --> 00:17:23.120
So we have survived the disassembly.


00:17:23.120 --> 00:17:24.840
We have returned to continue.


00:17:24.840 --> 00:17:27.520
We were talking about the integration of FastAPI


00:17:27.520 --> 00:17:29.580
and Pydantic, and that was really cool.


00:17:29.580 --> 00:17:32.540
I think something I'd like to kind of move to real quick


00:17:32.540 --> 00:17:35.680
is this big announcement, alpha of version two.


00:17:35.680 --> 00:17:37.240
Samuel, last time you were on the show,


00:17:37.240 --> 00:17:40.020
we spoke about the plan for version two,


00:17:40.020 --> 00:17:42.360
and now you're at least in an alpha stage.


00:17:42.360 --> 00:17:43.800
tell people where we are with this.


00:17:43.800 --> 00:17:46.200
- Yeah, so we're, yeah, we've had two alphas,


00:17:46.200 --> 00:17:47.920
maybe three alphas now out.


00:17:47.920 --> 00:17:51.000
We're basically pretty close to a feature freeze,


00:17:51.000 --> 00:17:53.840
and the plan is to release the package,


00:17:53.840 --> 00:17:55.400
release the beta, and effectively,


00:17:55.400 --> 00:17:58.280
we hope that we can then release the full release,


00:17:58.280 --> 00:18:00.520
say two weeks after that, but there'll be bugs,


00:18:00.520 --> 00:18:01.980
and we'll fix them, and we'll have more betas,


00:18:01.980 --> 00:18:04.080
but like, effectively, once we get to beta,


00:18:04.080 --> 00:18:06.040
the plan is that like, active development


00:18:06.040 --> 00:18:07.920
is stopping bar fixing bugs.


00:18:07.920 --> 00:18:09.960
- Now it's performance and bugs, right?


00:18:09.960 --> 00:18:11.460
- Yeah, and obviously one of the big things


00:18:11.460 --> 00:18:16.580
be once that's out, there'll be a lot more work on say, FastAPI, Django Ninja, etc, etc.


00:18:16.580 --> 00:18:18.820
And that might come back with, we really need this thing.


00:18:18.820 --> 00:18:23.320
Either this is broken or we really need that to make it, you know, to reduce the overhead


00:18:23.320 --> 00:18:24.780
of upgrading.


00:18:24.780 --> 00:18:30.260
One of the things I did for Pydantic 1.10, which was super valuable in beta, was to go


00:18:30.260 --> 00:18:35.180
through packages that use Pydantic, initially sorting by star, but then looking at what


00:18:35.180 --> 00:18:37.620
they actually do and trying to upgrade them.


00:18:37.620 --> 00:18:41.500
And that found me a bunch of bugs in either libraries or in Pydantic.


00:18:41.500 --> 00:18:46.860
So we're not promising we're going to go and upgrade the whole of GitHub to Pydantic v2,


00:18:46.860 --> 00:18:50.620
but we'll do a bit of that mostly to try and find bugs.


00:18:50.620 --> 00:18:54.100
One of the things that would be really useful is if anyone has an application that uses


00:18:54.100 --> 00:18:59.280
Pydantic, preferably without FastAPI or another library, that they would like help upgrading,


00:18:59.280 --> 00:19:01.220
we would love to come and help.


00:19:01.220 --> 00:19:05.920
And it might be a really powerful way of us, again, seeing the real pain points and identifying


00:19:05.920 --> 00:19:07.380
bugs before we get to v2.


00:19:07.380 --> 00:19:15.060
Yeah, and I guess another thing to mention that is a real headline and I also want to get your thoughts on this, Sebastian, is the performance numbers, right?


00:19:15.060 --> 00:19:20.540
I mean, you put out some pretty impressive performance numbers and Sebastian gets to piggyback on that, right?


00:19:20.540 --> 00:19:23.700
Yeah, I mean, yeah, I'm really proud of it, right?


00:19:23.700 --> 00:19:24.820
Yeah, you should be.


00:19:24.820 --> 00:19:33.780
To go in a change of release, in a bump of release, to be in the ballpark of 22 times faster, not 22%, but 22 times faster,


00:19:33.780 --> 00:19:38.020
I don't know of another package that's made an upgrade of that kind of order of magnitude.


00:19:38.020 --> 00:19:42.260
What's crazy is it's not numerical computing, right? It's general purpose. If you look at


00:19:42.260 --> 00:19:46.580
the example I gave in my talk earlier, it's a completely standard Pydantic model with four


00:19:46.580 --> 00:19:51.380
fields. And that's where we're seeing that kind of like 22 times speed up. So I think it's going


00:19:51.380 --> 00:19:56.740
to be massive. I have my own cynicism about people who hype about performance as being the most


00:19:56.740 --> 00:20:01.380
important thing. I don't think most applications, it's actually the thing that matters most.


00:20:01.380 --> 00:20:05.380
But I think it matters, A, it matters to everyone and everyone wants it to go in the same direction.


00:20:05.380 --> 00:20:10.340
And two, it matters to the whole world and to the whole community that we effectively reduce


00:20:10.340 --> 00:20:14.260
the energy that we consume, like doing compute, basically.


00:20:14.260 --> 00:20:18.740
Right. That's absolutely true. And also, even if people don't actually need it,


00:20:18.740 --> 00:20:22.180
there's a group of people who are like, "Well, I'm going to leave for Go because it's not fast


00:20:22.180 --> 00:20:26.500
enough or I can't do enough concurrency or whatever." And if they don't have that feeling,


00:20:26.500 --> 00:20:29.460
even if they didn't actually need that percentage increase, that's still really


00:20:29.460 --> 00:20:30.740
good for the Python community.


00:20:30.740 --> 00:20:35.940
Even me, I was saying I had a gigabyte of data from web analytics that I was,


00:20:35.940 --> 00:20:38.340
I needed to load into a Polar's data frame.


00:20:38.340 --> 00:20:42.900
And for that, I needed to A, extract some attributes from nested fields and B,


00:20:42.900 --> 00:20:44.100
parse dates and things like that.


00:20:44.100 --> 00:20:45.860
And I use Pylantic v2.


00:20:45.860 --> 00:20:48.980
And like, it was vastly faster with v2.


00:20:48.980 --> 00:20:51.540
It went from like, toodling, tiddling, what's the word I'm looking for?


00:20:51.540 --> 00:20:56.660
Twiddling your thumbs to like, it happens virtually instantly, right?


00:20:56.660 --> 00:20:57.620
And that's fantastic.


00:20:57.620 --> 00:21:00.580
And that'll be even more true when you have an order of magnitude


00:21:00.580 --> 00:21:02.620
to order the magnitude more data.


00:21:02.620 --> 00:21:03.460
- Yeah, for sure.


00:21:03.460 --> 00:21:04.780
Sebastian, how about you?


00:21:04.780 --> 00:21:06.820
What's the knock-on effect for FastAPI?


00:21:06.820 --> 00:21:08.660
- So I think one of the coolest things


00:21:08.660 --> 00:21:10.860
is that people won't have to change the code


00:21:10.860 --> 00:21:12.220
to get that performance benefit.


00:21:12.220 --> 00:21:14.140
It's just gonna be like a bump suddenly.


00:21:14.140 --> 00:21:16.580
And because of the new ways


00:21:16.580 --> 00:21:18.460
that Pydantic can handle the data,


00:21:18.460 --> 00:21:19.380
we're gonna be able to,


00:21:19.380 --> 00:21:21.180
there's something that needs to be done in FastAPI,


00:21:21.180 --> 00:21:25.460
but we're gonna be able to let the parsing of the data,


00:21:25.460 --> 00:21:28.740
let Pydantic handle that in the Rust side.


00:21:28.740 --> 00:21:32.580
So Pydantic will be able to just read the JSON bytes


00:21:32.580 --> 00:21:34.740
instead of reading them in the Python side


00:21:34.740 --> 00:21:35.780
and let Pydantic do that,


00:21:35.780 --> 00:21:37.860
and then Pydantic give the models back


00:21:37.860 --> 00:21:39.540
to the rest of the code of FastEPA.


00:21:39.540 --> 00:21:41.660
That alone will boost performance a lot,


00:21:41.660 --> 00:21:43.500
but the fact that it's being done in Rust,


00:21:43.500 --> 00:21:46.300
in the Rust side, it's just gonna be amazing.


00:21:46.300 --> 00:21:48.700
Like, one of the other things that I want to do


00:21:48.700 --> 00:21:51.380
that is on the plans is to let users define


00:21:51.380 --> 00:21:53.140
how they want to serialize data


00:21:53.140 --> 00:21:55.540
and not have like, this is just like by default,


00:21:55.540 --> 00:21:57.140
it's just like Pydantic models


00:21:57.140 --> 00:21:59.300
and it converts automatically to JSON.


00:21:59.300 --> 00:22:01.460
But I want to allow users to decide


00:22:01.460 --> 00:22:03.660
how to serialize the objects and the data


00:22:03.660 --> 00:22:04.580
so that they can--


00:22:04.580 --> 00:22:06.460
- Wait, like data classes or something like that?


00:22:06.460 --> 00:22:07.660
- Yeah, for example, they can say,


00:22:07.660 --> 00:22:08.820
oh, I don't want to serialize


00:22:08.820 --> 00:22:10.580
with the standard JSON serializer.


00:22:10.580 --> 00:22:12.260
I want to serialize with our JSON,


00:22:12.260 --> 00:22:15.940
which is like the Rust-based implementation


00:22:15.940 --> 00:22:16.900
to serialize JSON. - Ah, got it.


00:22:16.900 --> 00:22:18.860
- Or they can say, I want Pydantic


00:22:18.860 --> 00:22:20.220
to be the one that serializes this


00:22:20.220 --> 00:22:21.980
because I know that this is just a model


00:22:21.980 --> 00:22:22.980
that can handle that.


00:22:22.980 --> 00:22:24.860
They can also, and this is one of the things


00:22:24.860 --> 00:22:25.940
that I think is super cool,


00:22:25.940 --> 00:22:30.020
they can also create, they will be able to create a way to say,


00:22:30.020 --> 00:22:33.480
"I want to serialize this response to XML,"


00:22:33.480 --> 00:22:35.060
or something like that, or to YAML,


00:22:35.060 --> 00:22:37.560
and to let Python decouple the validation,


00:22:37.560 --> 00:22:40.200
but then do the serialization in a way that they can customize


00:22:40.200 --> 00:22:43.540
the whole thing without having to do it directly in the code.


00:22:43.540 --> 00:22:47.540
>> Maybe even some of these crazy stream buffer protocols.


00:22:47.540 --> 00:22:49.700
>> Yeah, like protocol buffers with


00:22:49.700 --> 00:22:53.360
gRPC or even message pack or a bunch of these things that


00:22:53.360 --> 00:22:57.760
There's no obvious way and there's no native way to have support for that,


00:22:57.760 --> 00:23:00.080
for reading the data and for exporting the data.


00:23:00.080 --> 00:23:02.880
And that's one of the things that I have in plans.


00:23:02.880 --> 00:23:06.880
I'm probably saying too much and then I'm going to account for all the things I'm recording.


00:23:06.880 --> 00:23:08.800
And now they're like, you know what, you promised this.


00:23:08.800 --> 00:23:10.000
You did promise it.


00:23:10.000 --> 00:23:12.160
Well, can I just come back on serialization for a minute?


00:23:12.160 --> 00:23:12.880
Yeah, please.


00:23:12.880 --> 00:23:19.280
Yeah, so I've worked from October, putting to one side the whole funding round in the


00:23:19.280 --> 00:23:21.920
middle of it, was working solidly on serialization.


00:23:21.920 --> 00:23:25.760
So we have, there's almost as much code in Pydantic Core now for serialization


00:23:25.760 --> 00:23:26.880
as there is for validation.


00:23:26.880 --> 00:23:27.320
Yeah.


00:23:27.320 --> 00:23:27.520
Wow.


00:23:27.520 --> 00:23:32.120
We can serialize directly to, to JSON using the same underlying library


00:23:32.120 --> 00:23:33.920
that, or JSON uses using Serdy.


00:23:33.920 --> 00:23:38.720
But one, and also we can, you can customize how your serialization goes


00:23:38.720 --> 00:23:42.500
on a per field basis rather than on a per type basis, which is like incredibly


00:23:42.500 --> 00:23:46.440
powerful, but we also allow you to effectively serialize to Python.


00:23:46.440 --> 00:23:51.120
So not just what used to be the dict method, but basically do JSONable Python.


00:23:51.320 --> 00:23:55.100
So you effectively set the mode when serializing to Python to JSON, and you


00:23:55.100 --> 00:23:58.980
will only get the like, whatever it is, seven primitive JSON types in Python,


00:23:58.980 --> 00:24:02.040
which is super valuable if you want your output to be XML, because then, you know,


00:24:02.040 --> 00:24:06.140
your XML encoder only needs to bother, needs to take in dictionaries, lists,


00:24:06.140 --> 00:24:11.200
ints, floats, none, bool, rather than whatever complex data you have.


00:24:11.200 --> 00:24:15.880
So there's an, yeah, I'm like super proud of lots of the advantages of serialization.


00:24:15.880 --> 00:24:20.300
My 45 minute talk earlier, I was able to touch about half of the big new features,


00:24:20.300 --> 00:24:23.420
which kind of talks about quite how much has changed.


00:24:23.420 --> 00:24:24.940
- Yeah, that's really exciting.


00:24:24.940 --> 00:24:27.020
- I think we definitely, I was saying earlier,


00:24:27.020 --> 00:24:28.460
if I had known how long it was gonna take,


00:24:28.460 --> 00:24:30.220
I would never have set out on this journey.


00:24:30.220 --> 00:24:33.060
So the best thing about it is I didn't think


00:24:33.060 --> 00:24:34.020
about how long it was gonna take


00:24:34.020 --> 00:24:35.980
because we didn't try and do a bit more.


00:24:35.980 --> 00:24:38.460
We tried to do everything, or I tried to do everything.


00:24:38.460 --> 00:24:40.140
And that's how it's disadvantaged.


00:24:40.140 --> 00:24:41.940
It's taken longer than we had hoped, but here we are.


00:24:41.940 --> 00:24:43.260
- But here you are, you're pretty much here.


00:24:43.260 --> 00:24:44.780
That's really good, that's really good.


00:24:44.780 --> 00:24:47.260
And so when you think about performance, right,


00:24:47.260 --> 00:24:49.780
obviously the 22 times faster is awesome.


00:24:49.780 --> 00:24:51.740
The FastAPI speed up is awesome.


00:24:51.740 --> 00:24:57.380
But if you do something like SQL model and FastAPI or beanie and FastAPI,


00:24:57.380 --> 00:25:00.940
you're getting on both ends, you're getting that beanie or the.


00:25:00.940 --> 00:25:04.220
I'd ended up with the beanie integration and the fast.


00:25:04.220 --> 00:25:05.980
So you, you're kind of putting.


00:25:05.980 --> 00:25:08.300
Hydanek in both those layers.


00:25:08.300 --> 00:25:11.780
And so those speed ups are like twice as good or something like that.


00:25:11.780 --> 00:25:12.140
Yeah.


00:25:12.140 --> 00:25:12.380
Right.


00:25:12.380 --> 00:25:16.020
I think you, well, they're probably, yeah, they're like, they're the same


00:25:16.020 --> 00:25:17.780
relatively, but more in absolute terms.


00:25:17.780 --> 00:25:18.220
Yeah.


00:25:18.220 --> 00:25:18.580
Yeah.


00:25:18.580 --> 00:25:19.380
Yeah, absolutely.


00:25:19.540 --> 00:25:23.740
So yeah, I think it's, you know, the fact that so many things have been built upon


00:25:23.740 --> 00:25:28.900
Pydantic means you've just sped up a bunch of projects without them doing too much.


00:25:28.900 --> 00:25:29.060
Yeah.


00:25:29.060 --> 00:25:30.180
We get the, like the win.


00:25:30.180 --> 00:25:32.620
It's like CPython itself getting faster, helps everyone.


00:25:32.620 --> 00:25:35.980
This is like the next layer down, but we, you know, as a dependency of lots of


00:25:35.980 --> 00:25:39.620
packages, we get to speed up lots of the community with one package, like


00:25:39.620 --> 00:25:41.380
one person devoting a year to it.


00:25:41.380 --> 00:25:44.260
Does this surprise you to see all these projects coming out?


00:25:44.260 --> 00:25:47.780
Like here's another project based on Pydantic plus, you know, name your


00:25:47.780 --> 00:25:48.700
other thing that it's integrated with.


00:25:48.700 --> 00:25:49.300
It's been crazy.


00:25:49.300 --> 00:25:51.960
particularly in the machine learning space where, you know,


00:25:51.960 --> 00:25:56.000
Langchain, who are one of the big names right now in these big


00:25:56.000 --> 00:25:59.280
language models, large language models, all based on Pydantic,


00:25:59.280 --> 00:25:59.560
right?


00:25:59.560 --> 00:26:00.000
Yeah.


00:26:00.000 --> 00:26:03.240
You were saying, I think, on Twitter that OpenAPI use a bunch


00:26:03.240 --> 00:26:04.080
of FastAPI, right?


00:26:04.080 --> 00:26:04.800
OpenAI?


00:26:04.800 --> 00:26:10.420
Sorry, OpenAI, not OpenAPI. Marvin, I think, from Prefect,


00:26:10.420 --> 00:26:14.040
is built on Pydantic again. So the wave of machine learning


00:26:14.040 --> 00:26:17.120
stuff seems to have leveraged Pydantic, a whole lot, DockerA


00:26:17.120 --> 00:26:18.800
being another big example.


00:26:18.920 --> 00:26:21.320
some for Elastic and some other things as well.


00:26:21.320 --> 00:26:27.480
This portion of Talk Python to Me is brought to you by Influx Data,


00:26:27.480 --> 00:26:29.480
the makers of InfluxDB.


00:26:29.480 --> 00:26:35.480
InfluxDB is a database purpose-built for handling time series data at a massive scale


00:26:35.480 --> 00:26:37.240
for real-time analytics.


00:26:37.240 --> 00:26:42.440
Developers can ingest, store, and analyze all types of time series data, metrics, events,


00:26:42.440 --> 00:26:44.600
and traces in a single platform.


00:26:44.600 --> 00:26:46.680
So, dear listener, let me ask you a question.


00:26:46.680 --> 00:26:51.720
how would boundless cardinality and lightning fast SQL queries impact the way that you develop


00:26:51.720 --> 00:26:57.720
real-time applications? InfluxDB processes large time series data sets and provides low latency


00:26:57.720 --> 00:27:02.760
SQL queries, making it the go-to choice for developers building real-time applications


00:27:02.760 --> 00:27:08.200
and seeking crucial insights. For developer efficiency, InfluxDB helps you create IoT,


00:27:08.200 --> 00:27:13.960
analytics, and cloud applications using time-stamped data rapidly and at scale. It's


00:27:13.960 --> 00:27:19.640
It's designed to ingest billions of data points in real time with unlimited cardinality.


00:27:19.640 --> 00:27:24.680
InfluxDB streamlines building once and deploying across various products and environments from


00:27:24.680 --> 00:27:27.400
the edge on premise and to the cloud.


00:27:27.400 --> 00:27:31.760
Try it for free at talkpython.fm/influxdb.


00:27:31.760 --> 00:27:34.800
The link is in your podcast player show notes.


00:27:34.800 --> 00:27:38.720
Thanks to InfluxData for supporting the show.


00:27:38.720 --> 00:27:42.800
I'm sure one of the big things you're thinking going forward with FastAPI is like how do


00:27:42.800 --> 00:27:45.220
you guys work together and make this a seamless change.


00:27:45.220 --> 00:27:46.120
What else you got?


00:27:46.120 --> 00:27:47.000
What else you working on?


00:27:47.000 --> 00:27:48.520
What else do you see in the future?


00:27:48.520 --> 00:27:50.520
- I have a bunch of things.


00:27:50.520 --> 00:27:51.800
- Are they secret or can you tell us?


00:27:51.800 --> 00:27:53.200
- No, no, I can tell.


00:27:53.200 --> 00:27:54.640
Most of it I can tell.


00:27:54.640 --> 00:27:57.840
I just feel the accountability.


00:27:57.840 --> 00:27:59.440
But I can tell.


00:27:59.440 --> 00:28:01.680
So I have a bunch of projects.


00:28:01.680 --> 00:28:03.760
The funny thing is that in some way


00:28:03.760 --> 00:28:05.360
it's kind of a dependency graph


00:28:05.360 --> 00:28:07.320
of things that I should work on.


00:28:07.320 --> 00:28:09.520
So for example, I have this project generator


00:28:09.520 --> 00:28:12.880
for FastAPI to generate a project with a SQL database.


00:28:12.880 --> 00:28:14.760
I haven't updated it in a long time,


00:28:14.760 --> 00:28:16.080
and it uses SQLAlchemy.


00:28:16.080 --> 00:28:19.600
I built SQL model for that project to use it there,


00:28:19.600 --> 00:28:21.640
but I haven't updated it there, because first, I


00:28:21.640 --> 00:28:23.560
want to upgrade more things in SQL model.


00:28:23.560 --> 00:28:25.200
I want to finish the documentation,


00:28:25.200 --> 00:28:26.860
finish the story about migration.


00:28:26.860 --> 00:28:28.680
But then for the story about migration,


00:28:28.680 --> 00:28:30.760
I need Typer for SQL model.


00:28:30.760 --> 00:28:32.640
So I need to update things in Typer.


00:28:32.640 --> 00:28:35.520
And then for Typer, I want to add support for annotated,


00:28:35.520 --> 00:28:38.320
which is actually one of the big things, one of the recent big


00:28:38.320 --> 00:28:41.760
things in FastAPI is that now there's support for annotated.


00:28:41.760 --> 00:28:44.640
So annotated is this feature from Python.


00:28:44.640 --> 00:28:46.800
It's like standard Python typings.


00:28:46.800 --> 00:28:50.320
You import from typings, import annotated,


00:28:50.320 --> 00:28:53.000
and then you can use that to emit information


00:28:53.000 --> 00:28:55.120
to the types that you define for parameters.


00:28:55.120 --> 00:28:56.080
- Like what? I haven't used this.


00:28:56.080 --> 00:28:57.440
I love typing, I use it all the time,


00:28:57.440 --> 00:28:59.280
and here I'm learning more about typing.


00:28:59.280 --> 00:29:02.200
- The thing is, it exists there in the standard library,


00:29:02.200 --> 00:29:05.900
but it doesn't have like a canonical use in Python itself.


00:29:05.900 --> 00:29:09.180
it's there mainly for FastAPI and Pydantic to use it.


00:29:09.180 --> 00:29:10.780
You know, like, it's just that, like,


00:29:10.780 --> 00:29:13.580
I hadn't pushed for that before.


00:29:13.580 --> 00:29:16.740
But the thing is, you import from typings,


00:29:16.740 --> 00:29:19.140
import annotated, and then you create a function


00:29:19.140 --> 00:29:20.620
that takes like a username,


00:29:20.620 --> 00:29:24.000
and then this function will normally be of type string.


00:29:24.000 --> 00:29:26.140
So it will be, the parameter of the function


00:29:26.140 --> 00:29:28.540
will be username colon str.


00:29:28.540 --> 00:29:31.960
Now you can say username colon annotated,


00:29:31.960 --> 00:29:33.220
and then open square brackets,


00:29:33.220 --> 00:29:35.420
as if it was like a list or like a dict or something,


00:29:35.420 --> 00:29:37.420
open square brackets, and then the first thing


00:29:37.420 --> 00:29:39.140
that you put there, that's the actual type.


00:29:39.140 --> 00:29:41.380
So you will say, annotated string,


00:29:41.380 --> 00:29:44.020
and then you can pass additional metadata afterwards.


00:29:44.020 --> 00:29:45.860
And the additional metadata is the thing


00:29:45.860 --> 00:29:47.540
that you will use to tell FastAPI,


00:29:47.540 --> 00:29:49.340
this should be extracted from the query parameters


00:29:49.340 --> 00:29:51.220
or from the cookies or from headers.


00:29:51.220 --> 00:29:53.620
Before, and I kept to recently in FastAPI,


00:29:53.620 --> 00:29:55.460
the only way to do that was using


00:29:55.460 --> 00:29:57.220
the default value of the parameter.


00:29:57.220 --> 00:29:59.940
- Right, you would set the default to like a depends or--


00:29:59.940 --> 00:30:02.660
- Yeah, to depends or equals a cookie


00:30:02.660 --> 00:30:04.540
or equals header or something like that.


00:30:04.540 --> 00:30:07.060
And then FastAPI can take the information from that


00:30:07.060 --> 00:30:08.980
to give you the data in your function.


00:30:08.980 --> 00:30:11.460
But the thing is, if you call that function manually


00:30:11.460 --> 00:30:14.660
somewhere else, the editor and Python won't complain


00:30:14.660 --> 00:30:17.100
that you are not passing some parameter that is required.


00:30:17.100 --> 00:30:18.060
And then you're gonna end up


00:30:18.060 --> 00:30:19.560
with some strange value internally


00:30:19.560 --> 00:30:20.980
that is just for FastAPI.


00:30:20.980 --> 00:30:22.940
- Right, or the type checker complains,


00:30:22.940 --> 00:30:24.180
"You're not passing a depends."


00:30:24.180 --> 00:30:25.540
Like, "No, I'm passing a string.


00:30:25.540 --> 00:30:26.460
"That's what it's supposed to be."


00:30:26.460 --> 00:30:27.300
But that's-- - Yeah, exactly.


00:30:27.300 --> 00:30:28.140
- Something weird thing like that.


00:30:28.140 --> 00:30:29.020
- Exactly. - Yeah, okay.


00:30:29.020 --> 00:30:30.900
- So for those cases, having annotated,


00:30:30.900 --> 00:30:32.940
like all the type is exactly what it is.


00:30:32.940 --> 00:30:35.300
And if it has a default value, it's the actual default value,


00:30:35.300 --> 00:30:40.300
instead of some strange internal concept in FastAPI.


00:30:40.300 --> 00:30:44.060
And having support for that allows having much better support


00:30:44.060 --> 00:30:46.620
for typings, for editors, auto-completion, inline errors,


00:30:46.620 --> 00:30:49.740
all these things, reusing the same functions in other places.


00:30:49.740 --> 00:30:53.220
And it will also, having support for that in Typer


00:30:53.220 --> 00:30:55.500
will allow users to have the same function


00:30:55.500 --> 00:30:58.980
being used for FastAPI and Typer,


00:30:58.980 --> 00:31:00.740
having the custom metadata necessary


00:31:00.740 --> 00:31:02.700
for each one of the parameters for FastAPI


00:31:02.700 --> 00:31:04.180
and for a typer, and things like that.


00:31:04.180 --> 00:31:06.140
So it's something that is super powerful


00:31:06.140 --> 00:31:07.300
and super interesting.


00:31:07.300 --> 00:31:08.700
- I'm gonna come in on annotated


00:31:08.700 --> 00:31:09.980
'cause I'm excited about it too.


00:31:09.980 --> 00:31:11.980
So, in Pydantic V2, we use annotated


00:31:11.980 --> 00:31:13.620
for all of our custom types.


00:31:13.620 --> 00:31:15.740
So for example, positive int type


00:31:15.740 --> 00:31:17.260
is just annotated of int,


00:31:17.260 --> 00:31:19.700
and then we use the annotated types package,


00:31:19.700 --> 00:31:23.400
which is some reusable metadata for annotated.


00:31:23.400 --> 00:31:26.860
So we would use, like, positive int is annotated of int,


00:31:26.860 --> 00:31:28.380
and then greater than zero.


00:31:28.380 --> 00:31:31.340
And what's even cooler is that will be used


00:31:31.340 --> 00:31:33.740
by Pydantic, of course.


00:31:33.740 --> 00:31:36.300
Hypothesis is going to get support for that really soon.


00:31:36.300 --> 00:31:38.460
So it will only pass a positive value in


00:31:38.460 --> 00:31:40.700
if it sees greater than zero there.


00:31:40.700 --> 00:31:42.460
And then Typer, I guess, could--


00:31:42.460 --> 00:31:44.100
even if it's still based on click,


00:31:44.100 --> 00:31:46.460
it can go and take that greater than and infer it


00:31:46.460 --> 00:31:48.180
as it must be greater than zero.


00:31:48.180 --> 00:31:50.700
So I think it was one of the things that typing guys,


00:31:50.700 --> 00:31:52.260
when they first created Annotated,


00:31:52.260 --> 00:31:55.260
hoped was going to build a rich network of libraries


00:31:55.260 --> 00:31:56.940
that interchanged metadata.


00:31:56.940 --> 00:31:58.780
It's taken a bit longer than they expected,


00:31:58.780 --> 00:32:00.060
but we're getting there.


00:32:00.060 --> 00:32:02.420
- I hear the two of you are kind of doing that a little bit, right?


00:32:02.420 --> 00:32:02.940
That's cool.


00:32:02.940 --> 00:32:03.700
That's really cool.


00:32:03.700 --> 00:32:08.900
One of the areas where I feel like typing is a little janky is on ORMs and ODMs.


00:32:08.900 --> 00:32:13.420
When you define a class, you say, for example, it's like a SQLAlchemy column


00:32:13.420 --> 00:32:17.300
or it's a Beanie column or something like that.


00:32:17.300 --> 00:32:22.060
And the type is it's a string column, but really it's a string.


00:32:22.060 --> 00:32:23.220
It's not a string column.


00:32:23.220 --> 00:32:28.780
And so there's this weirdness of using types to kind of drive behavior.


00:32:29.020 --> 00:32:31.060
- That's a perfect case for using annotated.


00:32:31.060 --> 00:32:31.900
- That's what I was thinking, yeah.


00:32:31.900 --> 00:32:33.740
- What it doesn't do is the other case


00:32:33.740 --> 00:32:36.300
where there is a context where you'd want to get


00:32:36.300 --> 00:32:37.980
the column object of some sort


00:32:37.980 --> 00:32:40.300
rather than the integer in a row.


00:32:40.300 --> 00:32:41.940
So it does mean two different things,


00:32:41.940 --> 00:32:44.780
the kind of dot objects in the Django context,


00:32:44.780 --> 00:32:45.860
but yeah, absolutely.


00:32:45.860 --> 00:32:46.680
- Yeah.


00:32:46.680 --> 00:32:48.600
- It's there precisely to solve this kind of problem.


00:32:48.600 --> 00:32:50.040
- And it's also because like,


00:32:50.040 --> 00:32:52.300
currently as far as I remember, there's no way,


00:32:52.300 --> 00:32:54.520
so the thing is that this is all based


00:32:54.520 --> 00:32:55.820
on something called descriptors,


00:32:55.820 --> 00:32:58.420
and is that when you call, like, I don't know,


00:32:58.420 --> 00:33:03.100
class user.name is actually the attribute in the class.


00:33:03.100 --> 00:33:04.900
But when you create an instance of that user


00:33:04.900 --> 00:33:06.580
and then say user.name,


00:33:06.580 --> 00:33:08.780
that is the attribute on the actual instance.


00:33:08.780 --> 00:33:11.700
And the way that this ODMs or ORMs or these things work


00:33:11.700 --> 00:33:14.980
is that they have a special way to say like,


00:33:14.980 --> 00:33:16.620
when someone calls the actual class,


00:33:16.620 --> 00:33:17.540
this is a different thing


00:33:17.540 --> 00:33:20.420
than when someone calls an instance attribute.


00:33:20.420 --> 00:33:21.260
- Right.


00:33:21.260 --> 00:33:22.740
- And there's-- - It's sort of two behaviors


00:33:22.740 --> 00:33:23.580
- Yeah, yeah. - in the context, right?


00:33:23.580 --> 00:33:24.980
- And it's super powerful.


00:33:24.980 --> 00:33:26.180
That's how SQLAlchemy works.


00:33:26.180 --> 00:33:27.260
And it's super powerful


00:33:27.260 --> 00:33:29.480
because then all the queries and all the stuff


00:33:29.480 --> 00:33:32.600
is actually consistent with how Python works.


00:33:32.600 --> 00:33:34.940
And you can say greater than or equals to


00:33:34.940 --> 00:33:37.060
using Python syntax, which is great.


00:33:37.060 --> 00:33:38.740
But then currently, as far as I know,


00:33:38.740 --> 00:33:41.420
there's no way to define that with type annotations


00:33:41.420 --> 00:33:42.260
in a standard way.


00:33:42.260 --> 00:33:45.360
I think it's something that will probably be improvable,


00:33:45.360 --> 00:33:46.400
but I think there's currently no way.


00:33:46.400 --> 00:33:47.800
There will probably be a way at some point,


00:33:47.800 --> 00:33:51.000
but to be able to say, hey, this equal alchemy column


00:33:51.000 --> 00:33:54.280
is a column when it's accessed at the class level,


00:33:54.280 --> 00:33:55.960
but this is gonna be a string when it's accessed


00:33:55.960 --> 00:33:58.060
at the instance level.


00:33:58.060 --> 00:34:00.000
- A scope level in the annotated, you know.


00:34:00.000 --> 00:34:00.840
- Yeah, yeah, yeah, something like that.


00:34:00.840 --> 00:34:01.660
- The class is this and this,


00:34:01.660 --> 00:34:04.120
and the instance is that and that.


00:34:04.120 --> 00:34:05.280
That's really interesting.


00:34:05.280 --> 00:34:06.440
While we're talking types,


00:34:06.440 --> 00:34:08.840
and I know you both are really big fans


00:34:08.840 --> 00:34:11.640
'cause it's such a central part, both your libraries,


00:34:11.640 --> 00:34:13.120
what do you wanna see coming?


00:34:13.120 --> 00:34:15.080
It feels like this is an area of Python changing fast,


00:34:15.080 --> 00:34:17.880
but is there something like, if they could just...


00:34:17.880 --> 00:34:19.520
And I have another question on types otherwise


00:34:19.520 --> 00:34:20.760
after that, if I remember.


00:34:20.760 --> 00:34:22.440
- So I gave a talk at the Typing Summit


00:34:22.440 --> 00:34:24.040
asking for certain things.


00:34:24.040 --> 00:34:28.840
So now we're going to test my can I remember PEP numbers challenge, which I'm going to fail in, but


00:34:28.840 --> 00:34:37.320
 PEP 472 is that keyword args to... so one option would be to allow keyword arguments to get item,


00:34:37.320 --> 00:34:40.680
which would make annotated even more powerful because then you could use keyword arguments


00:34:40.680 --> 00:34:44.120
to describe the meaning of your metadata, rather than having to have these kind of


00:34:44.120 --> 00:34:49.560
identifier types like greater than. One of the big things that I hope we're going to persuade,


00:34:49.560 --> 00:34:52.840
so I think one of the things that's happened recently is that everyone gets that runtime


00:34:52.840 --> 00:34:54.760
use of type ints is a legitimate thing.


00:34:54.760 --> 00:34:55.920
They might not want to do it themselves,


00:34:55.920 --> 00:34:58.320
but they get that it's a legitimate thing to do.


00:34:58.320 --> 00:34:59.760
- How much pushback was there


00:34:59.760 --> 00:35:01.560
when you first came out with PyTandric there?


00:35:01.560 --> 00:35:03.360
- I think we were like the black sheep of Python.


00:35:03.360 --> 00:35:04.640
I was a black sheep of Python.


00:35:04.640 --> 00:35:05.720
- This is supposed to have no meaning.


00:35:05.720 --> 00:35:06.560
What are you doing?


00:35:06.560 --> 00:35:07.840
You're doing it wrong.


00:35:07.840 --> 00:35:09.560
- And I think nowadays that's changed


00:35:09.560 --> 00:35:10.920
and everyone gets it's a real thing.


00:35:10.920 --> 00:35:12.880
So for example, the hash of a union


00:35:12.880 --> 00:35:16.960
is independent of the order of the members of the union.


00:35:16.960 --> 00:35:19.240
That makes sense in the context of static typing


00:35:19.240 --> 00:35:21.760
where the union of int float is exactly the same


00:35:21.760 --> 00:35:23.440
as a union of float int.


00:35:23.440 --> 00:35:24.720
It turns out in static typing,


00:35:24.720 --> 00:35:26.440
particularly when you're doing coercion,


00:35:26.440 --> 00:35:29.000
there are some cases where that is not the case.


00:35:29.000 --> 00:35:31.560
And so it's really difficult right now


00:35:31.560 --> 00:35:34.920
that effectively when you, unions are fine on their own,


00:35:34.920 --> 00:35:37.040
but if you have a union say within a string,


00:35:37.040 --> 00:35:39.680
the capital string square brackets,


00:35:39.680 --> 00:35:41.320
it will, the order will be,


00:35:41.320 --> 00:35:44.360
match the order that the first time you called that,


00:35:44.360 --> 00:35:45.840
not what you actually call,


00:35:45.840 --> 00:35:48.480
unless you use lowercase string when it is the right order,


00:35:48.480 --> 00:35:50.000
except there's a PR open right now


00:35:50.000 --> 00:35:52.000
to break it on string too.


00:35:52.000 --> 00:35:53.600
So, string as well.


00:35:53.600 --> 00:35:56.880
So anyway, we are on lowercase list as well.


00:35:56.880 --> 00:36:00.800
Anyway, so things like that, where I do think that like,


00:36:00.800 --> 00:36:02.320
we'll see what happens on that particular case,


00:36:02.320 --> 00:36:06.320
but I feel like the voice of people doing runtime use of types,


00:36:06.320 --> 00:36:08.400
we're not the only people, are being heard better.


00:36:08.400 --> 00:36:11.680
And like, yeah, I think things are going to continue to improve.


00:36:11.680 --> 00:36:15.120
Yeah, there was a PEP that proposed an optimization for typing


00:36:15.120 --> 00:36:18.880
that kind of broke the runtime behaviors of it a little bit for both of y'all.


00:36:18.880 --> 00:36:24.320
Yeah, did in some edge cases, and that's going to be fixed soon by the successor, Pep.


00:36:24.320 --> 00:36:26.080
Absolutely. So that's really good.


00:36:26.080 --> 00:36:30.320
Generic alias is another thing that kills us internally in Pydantic.


00:36:30.320 --> 00:36:33.360
I won't go into all of the details of it, but yeah, we would...


00:36:33.360 --> 00:36:38.800
The high-level takeaway is that the typing community seemed happy with the idea


00:36:38.800 --> 00:36:41.680
that they might make a change to typing to make it easier for us.


00:36:41.680 --> 00:36:44.480
And I think that's also for the Pydantic team to engage better.


00:36:44.480 --> 00:36:46.240
And instead of spending ages...


00:36:46.240 --> 00:36:49.440
Problem is, right, like you have a problem, you see a solution in typing,


00:36:49.440 --> 00:36:53.040
you submit the PR, even if it gets accepted in a week, which it won't,


00:36:53.040 --> 00:36:56.880
you wait five years before we can remove the code that deals with the other case.


00:36:56.880 --> 00:37:00.560
So it's very tempting not to engage with typing, but just go and write the work around


00:37:00.560 --> 00:37:05.520
where we should be better Python citizens and go and submit the PR to CPython to try and fix it properly.


00:37:05.520 --> 00:37:07.520
Yeah, what's your wish list for typing?


00:37:07.520 --> 00:37:11.840
So, well, the first thing is like this thing that I have been trying to work on and like trying to do


00:37:11.840 --> 00:37:14.960
to have better ways to do the documentation of the APIs.


00:37:14.960 --> 00:37:17.600
That's also related to typing and to the annotations.


00:37:17.600 --> 00:37:19.280
Like, let's see if I can pull it off.


00:37:19.280 --> 00:37:23.280
The other thing is, it's actually not that necessarily related to the things


00:37:23.280 --> 00:37:24.800
that we have been talking about,


00:37:24.800 --> 00:37:28.720
but it's quite relevant for the data science and machine learning community.


00:37:28.720 --> 00:37:33.120
That is that there are many APIs for many libraries


00:37:33.120 --> 00:37:36.400
that decorate in some way some function,


00:37:36.400 --> 00:37:40.400
and then the function is expected to give some types of values


00:37:40.400 --> 00:37:45.680
to the body of the function internally, but to be able to receive different types of values.


00:37:45.680 --> 00:37:52.480
That sounds a bit abstract, but that's the core idea that is replicated across several libraries.


00:37:52.480 --> 00:37:57.120
And this will apply, for example, to Ray, the distributed machine learning or computing system,


00:37:57.120 --> 00:38:03.200
to Dask, to I think Dagster also uses something like that, Monad, this system for deploying


00:38:03.200 --> 00:38:07.200
workloads and machine learning, and a thing like that also uses these types of ideas.


00:38:07.920 --> 00:38:12.240
So there are many of these libraries that like, the way that they are designed is that you create


00:38:12.240 --> 00:38:17.040
some function, and then you're going to tell something to call this function. And then in


00:38:17.040 --> 00:38:21.520
the function, you say, I want to expect this value. And instead of you calling all the functions that


00:38:21.520 --> 00:38:25.920
will generate that value, you tell it like, hey, distributed system, blah, blah, blah,


00:38:25.920 --> 00:38:32.160
give me this value, execute this for me. But that means that you will have or no type annotations,


00:38:32.160 --> 00:38:37.280
or invalid type annotations, or red squiggly lines in some places, or no to completion or


00:38:37.280 --> 00:38:39.180
or auto-completion for the wrong things,


00:38:39.180 --> 00:38:41.180
just because there's currently no way


00:38:41.180 --> 00:38:43.740
to define this specific thing of saying,


00:38:43.740 --> 00:38:46.780
hey, this function after being decorated


00:38:46.780 --> 00:38:50.540
is gonna be able to receive a different type


00:38:50.540 --> 00:38:52.700
than what it's gonna give to internal.


00:38:52.700 --> 00:38:54.220
So I think that's something that,


00:38:54.220 --> 00:38:55.580
and it's probably quite challenging


00:38:55.580 --> 00:38:57.260
and a big thing to tackle,


00:38:57.260 --> 00:38:58.780
but it's something that is replicated


00:38:58.780 --> 00:39:00.460
across several libraries,


00:39:00.460 --> 00:39:01.540
in particular for these things


00:39:01.540 --> 00:39:04.620
that do distributed processing of data.


00:39:04.620 --> 00:39:07.260
I think that's something that will be great to improve.


00:39:07.260 --> 00:39:10.760
Does param spec fix some of that?


00:39:10.760 --> 00:39:18.800
Very close, but the param spec only does it for being able to sort of copy the params


00:39:18.800 --> 00:39:20.520
that come from one function to another.


00:39:20.520 --> 00:39:23.920
And actually I use all that for, for example, for asynchronous and for other things to be


00:39:23.920 --> 00:39:29.600
able to get like auto completion for the decorated function or for the generated function or


00:39:29.600 --> 00:39:30.600
things like that.


00:39:30.600 --> 00:39:35.280
And it will probably like the change will probably be somewhere around param spec to


00:39:35.280 --> 00:39:40.740
be able to say like, not just the param spec, but like this function will not only have


00:39:40.740 --> 00:39:46.220
the param spec, but will receive a modification like this of the parameters.


00:39:46.220 --> 00:39:48.820
Almost making param spec generic.


00:39:48.820 --> 00:39:51.260
All right.


00:39:51.260 --> 00:39:52.540
One more typing question.


00:39:52.540 --> 00:39:56.500
Do you all think typing is going too far with like the generic stuff?


00:39:56.500 --> 00:39:59.900
And is it going too much like C++ and C# and Java?


00:39:59.900 --> 00:40:02.300
Or is it still good?


00:40:02.300 --> 00:40:06.460
I think the way Python is growing is super interesting


00:40:06.460 --> 00:40:10.140
because we all have to agree that Python 3.12


00:40:10.140 --> 00:40:12.540
is not the same Python 2.7.


00:40:12.540 --> 00:40:14.260
It's quite different.


00:40:14.260 --> 00:40:15.660
And I think it's different in a good way.


00:40:15.660 --> 00:40:20.660
- The users are different and the focus of the runtime


00:40:20.660 --> 00:40:21.500
is different, yeah.


00:40:21.500 --> 00:40:23.700
- And the things that we can do with types now,


00:40:23.700 --> 00:40:27.540
and the fact that in Python we can access these types


00:40:27.540 --> 00:40:29.820
at runtime, which means, I don't know,


00:40:29.820 --> 00:40:32.220
I was always confused with the term runtime.


00:40:32.220 --> 00:40:33.540
It's like, what does that mean?


00:40:33.540 --> 00:40:35.540
I did like, when you execute Python,


00:40:35.540 --> 00:40:38.300
the same Python code can inspect and like see


00:40:38.300 --> 00:40:39.140
what are those types.


00:40:39.140 --> 00:40:40.620
That's what FastAPI and Python do.


00:40:40.620 --> 00:40:42.660
It's just like seeing like, what are those types?


00:40:42.660 --> 00:40:43.820
We can do that in Python.


00:40:43.820 --> 00:40:47.020
You cannot do that in things like TypeScript


00:40:47.020 --> 00:40:48.180
or you cannot do it in Java.


00:40:48.180 --> 00:40:49.660
You cannot do it in many other languages.


00:40:49.660 --> 00:40:51.540
You get access to this typing information


00:40:51.540 --> 00:40:53.460
to be able to do additional things with that,


00:40:53.460 --> 00:40:55.860
like validation, data serialization,


00:40:55.860 --> 00:40:57.340
documentation, all that stuff.


00:40:57.340 --> 00:41:00.540
So I think that's, to start, that's super powerful in Python.


00:41:00.540 --> 00:41:06.380
The language in Python for typings is not as powerful as, for example, TypeScript.


00:41:06.380 --> 00:41:09.500
There is just like so much stuff that you can do with that.


00:41:09.500 --> 00:41:12.380
Nevertheless, I feel that in Python it's just like,


00:41:12.380 --> 00:41:14.940
it's growing and it's growing organically.


00:41:14.940 --> 00:41:16.820
And like, we have growing pains, you know?


00:41:16.820 --> 00:41:18.100
Like, there are some things that are like,


00:41:18.100 --> 00:41:22.900
"Oh, this little thing here is slightly incorrectly named."


00:41:22.900 --> 00:41:26.460
But like, now there's a better way to do that in Python 3.10,


00:41:26.460 --> 00:41:30.340
so we don't care much about that slightly incorrect name, things like that.


00:41:30.340 --> 00:41:34.180
Yeah, I feel like there's some tensions of people who are on the mypy side


00:41:34.180 --> 00:41:40.060
and they want perfect validation of, I want to prove my code hangs together like a static compiler.


00:41:40.060 --> 00:41:44.100
And folks like you all who are like, we want to leverage typing


00:41:44.100 --> 00:41:46.900
to make it behave in interesting ways.


00:41:46.900 --> 00:41:49.780
And maybe that behavior expression doesn't exactly match


00:41:49.780 --> 00:41:53.180
what it looks statically like, but it is, everybody wants it,


00:41:53.180 --> 00:41:55.740
but it's, it might trip up mypy.


00:41:55.740 --> 00:41:57.860
I feel like there's this tension between those two things.


00:41:57.860 --> 00:41:59.860
That's kind of what I was thinking when I asked that question.


00:41:59.860 --> 00:42:02.860
I think there's a little bit of that, but at the same time,


00:42:02.860 --> 00:42:05.660
there's, it's much less than you could imagine.


00:42:05.660 --> 00:42:09.020
There are so many people that are so close to, you know,


00:42:09.020 --> 00:42:12.020
core mypy and these things that are actually very excited


00:42:12.020 --> 00:42:13.460
about the things that we are doing.


00:42:13.460 --> 00:42:17.700
So, you know, like, it's actually quite friendly, all the communication.


00:42:17.700 --> 00:42:20.900
It's just that there is some people that just don't really care about


00:42:20.900 --> 00:42:22.900
runtime types, and that's fine.


00:42:22.900 --> 00:42:27.700
But I feel like it's much more closer together


00:42:27.700 --> 00:42:30.140
and much more stronger, the relationship, I think.


00:42:30.140 --> 00:42:31.140
Yeah, yeah, it's great.


00:42:31.140 --> 00:42:33.620
Yeah, I think actually we've gone in the...


00:42:33.620 --> 00:42:35.580
Typing's got better for someone who's not...


00:42:35.580 --> 00:42:39.020
Like, it's actually got less verbose, cleaner, easier to understand.


00:42:39.020 --> 00:42:41.820
You don't have to import union, you can do pipe operator.


00:42:41.820 --> 00:42:44.100
You don't have to import list from typing,


00:42:44.100 --> 00:42:46.420
you can use list, which makes complete sense.


00:42:46.420 --> 00:42:48.020
Any is an unfortunate one,


00:42:48.020 --> 00:42:51.980
but I also understand why the any function would not make sense.


00:42:51.980 --> 00:42:54.220
I give up, I just I can't deal with this part.


00:42:54.220 --> 00:42:55.220
So yeah.


00:42:55.220 --> 00:42:57.660
No, in general, I think it's got much better.


00:42:57.660 --> 00:43:03.580
I do think that the interchange between runtime, there's a PEP open now to add to data class


00:43:03.580 --> 00:43:06.180
transforms a converter function.


00:43:06.180 --> 00:43:07.740
I forget exactly how it works.


00:43:07.740 --> 00:43:13.460
But I think that is awareness in the static typing space that the data gets converted


00:43:13.460 --> 00:43:16.100
when you construct something that looks like a data class.


00:43:16.100 --> 00:43:18.420
So no, I think I think it's really positive.


00:43:18.420 --> 00:43:20.620
I think we're incredibly lucky that we're,


00:43:20.620 --> 00:43:22.380
like I say, TypeScript is the other,


00:43:22.380 --> 00:43:26.260
is in some ways the best untyped language typing system.


00:43:26.260 --> 00:43:27.820
But the fact that they're not available at runtime


00:43:27.820 --> 00:43:29.700
means we're killing it, I think.


00:43:29.700 --> 00:43:32.220
I spoke to someone who maintains a library


00:43:32.220 --> 00:43:35.660
that does type analysis at runtime in TypeScript,


00:43:35.660 --> 00:43:38.460
and all his types are strings.


00:43:38.460 --> 00:43:40.940
And they're valid TypeScript, but they're strings.


00:43:40.940 --> 00:43:43.540
And that's, you know, he was saying that doesn't matter,


00:43:43.540 --> 00:43:44.620
and it's all fine.


00:43:44.620 --> 00:43:46.900
I tend to feel like it probably does a bit.


00:43:46.900 --> 00:43:48.900
We're really lucky to have them at runtime.


00:43:48.900 --> 00:43:49.980
Then you go to the other end,


00:43:49.980 --> 00:43:51.540
where I've been writing a lot of Rust.


00:43:51.540 --> 00:43:53.700
I am like, Rust's great, it has many advantages,


00:43:53.700 --> 00:43:55.340
but if you want to just get something done


00:43:55.340 --> 00:43:57.620
and not have to think too hard about what the types are,


00:43:57.620 --> 00:43:58.460
it's really nice.


00:43:58.460 --> 00:43:59.780
I write a lot of Python that's untyped


00:43:59.780 --> 00:44:02.060
when I'm just trying to get something to work.


00:44:02.060 --> 00:44:04.500
I'm not a like, everything must have a type on it


00:44:04.500 --> 00:44:05.460
kind of person.


00:44:05.460 --> 00:44:06.940
So no, I think we're in a really great place,


00:44:06.940 --> 00:44:08.160
and I think most of the advantages


00:44:08.160 --> 00:44:09.660
are actually cleaning it up.


00:44:09.660 --> 00:44:14.260
So the new six something, 649,


00:44:14.260 --> 00:44:16.700
the new generics syntax,


00:44:16.700 --> 00:44:18.420
to me, 695.


00:44:18.420 --> 00:44:20.780
(laughing)


00:44:20.780 --> 00:44:22.020
There are two types of people in the world.


00:44:22.020 --> 00:44:24.220
There are people who know the numbers of their peps


00:44:24.220 --> 00:44:26.720
and there's everyone saying.


00:44:26.720 --> 00:44:30.740
That for me cleans up generics, right?


00:44:30.740 --> 00:44:32.700
Yes, it's a fundamental change to the language.


00:44:32.700 --> 00:44:35.580
Yes, it makes the syntax or function look a bit more


00:44:35.580 --> 00:44:38.380
like Rust or something, but if you look at it


00:44:38.380 --> 00:44:40.020
independently of our experience,


00:44:40.020 --> 00:44:43.520
it's a heck of a lot more elegant than importing Typefra.


00:44:43.520 --> 00:44:44.360
- Yeah, yeah.


00:44:44.360 --> 00:44:48.820
And let me ask you one that's purely theoretical, because I don't think it'll get adopted,


00:44:48.820 --> 00:44:52.060
but we have int pipe none, we have optional of int.


00:44:52.060 --> 00:44:55.700
A lot of languages have question mark for nullable types.


00:44:55.700 --> 00:44:56.700
Like it could be int.


00:44:56.700 --> 00:44:57.700
You could even say like int.


00:44:57.700 --> 00:44:58.700
I'm not sure.


00:44:58.700 --> 00:44:59.700
Is it an int?


00:44:59.700 --> 00:45:00.700
It could be an int.


00:45:00.700 --> 00:45:01.700
It might be nullable.


00:45:01.700 --> 00:45:02.700
I don't know, right?


00:45:02.700 --> 00:45:03.700
Or use int.


00:45:03.700 --> 00:45:04.700
It's an int.


00:45:04.700 --> 00:45:05.700
You just know.


00:45:05.700 --> 00:45:06.700
There's no question mark.


00:45:06.700 --> 00:45:08.780
And those types, what are your thoughts about like null coalescine, you don't care?


00:45:08.780 --> 00:45:13.300
I'm really happy with the new situation and not having the optional that isn't optional.


00:45:13.300 --> 00:45:14.400
that's been a problem for a long time,


00:45:14.400 --> 00:45:16.180
so not needing to use optional


00:45:16.180 --> 00:45:19.400
is being able to use pipe none is great.


00:45:19.400 --> 00:45:22.200
I actually think one of the things that's gonna happen,


00:45:22.200 --> 00:45:25.600
particularly with the advent of the match syntax


00:45:25.600 --> 00:45:27.480
and with increased use of type dict,


00:45:27.480 --> 00:45:30.040
we're gonna need a new union type


00:45:30.040 --> 00:45:32.760
that operates much more like an enum in Rust.


00:45:32.760 --> 00:45:34.780
So basically a union that keeps track


00:45:34.780 --> 00:45:38.480
of which member of the enum you have an instance of.


00:45:38.480 --> 00:45:40.040
I keep meaning to build a package


00:45:40.040 --> 00:45:41.500
to demonstrate what I mean,


00:45:41.500 --> 00:45:42.460
and I haven't got around to it,


00:45:42.460 --> 00:45:45.100
Like, if you have a union of type dicts,


00:45:45.100 --> 00:45:46.680
which is a legitimate thing to do,


00:45:46.680 --> 00:45:48.720
it's effectively impossible without starting


00:45:48.720 --> 00:45:50.480
to do effectively validation to work out


00:45:50.480 --> 00:45:51.560
which member you're on.


00:45:51.560 --> 00:45:53.400
So I think we need, and it would be really neat


00:45:53.400 --> 00:45:55.060
if you could use a match expression


00:45:55.060 --> 00:45:57.320
to process each branch of your union.


00:45:57.320 --> 00:45:58.160
- Sebastian?


00:45:58.160 --> 00:45:59.200
- You already said everything.


00:45:59.200 --> 00:46:00.480
(laughing)


00:46:00.480 --> 00:46:03.580
- No, but like, you know, like, I feel that way.


00:46:03.580 --> 00:46:05.580
I was saying that, like, I feel Python is just, like,


00:46:05.580 --> 00:46:08.200
growing and, like, the typing system is growing.


00:46:08.200 --> 00:46:10.080
I feel it's growing in a very healthy way


00:46:10.080 --> 00:46:14.080
because it's not like just some academics


00:46:14.080 --> 00:46:16.080
hidden in some corner somewhere saying,


00:46:16.080 --> 00:46:17.080
like, this is how it should be done.


00:46:17.080 --> 00:46:20.080
- I did my thesis on this type system and here we are.


00:46:20.080 --> 00:46:21.080
- And then like everyone should just use it.


00:46:21.080 --> 00:46:24.080
It's just like a lot of hearing everyone


00:46:24.080 --> 00:46:26.080
and just receiving the feedback from everyone


00:46:26.080 --> 00:46:29.080
and just like growing in the ways that it should grow.


00:46:29.080 --> 00:46:30.080
I think that's amazing.


00:46:30.080 --> 00:46:34.080
I think like we are, you know, it's like a kind of renaissance


00:46:34.080 --> 00:46:36.080
of like typing in Python


00:46:36.080 --> 00:46:37.080
and like how we can build all these things.


00:46:37.080 --> 00:46:38.080
I think that's amazing.


00:46:38.080 --> 00:46:39.080
- I think it absolutely is.


00:46:39.080 --> 00:46:39.920
It absolutely is.


00:46:39.920 --> 00:46:41.400
All right, I think we're pretty much out of time.


00:46:41.400 --> 00:46:43.600
We've used up all the various places we've escaped to


00:46:43.600 --> 00:46:45.280
at a shutting down conference here.


00:46:45.280 --> 00:46:46.560
Final question for you both.


00:46:46.560 --> 00:46:47.760
Just, you know, what's your big takeaway?


00:46:47.760 --> 00:46:49.400
What's the experience like here at PyCon?


00:46:49.400 --> 00:46:51.620
Like, how's it been 2023?


00:46:51.620 --> 00:46:53.040
- For me, it's been amazing.


00:46:53.040 --> 00:46:55.160
It's my first PyCon in the US.


00:46:55.160 --> 00:46:56.000
- Oh, it is?


00:46:56.000 --> 00:46:58.000
- Yeah, like I have never been in a PyCon in the US.


00:46:58.000 --> 00:47:00.040
I have been in PyCons in like many other places,


00:47:00.040 --> 00:47:01.200
but not in the US.


00:47:01.200 --> 00:47:03.920
And like, I got to see, I got to put faces


00:47:03.920 --> 00:47:06.880
to so many handles in Twitter and GitHub.


00:47:06.880 --> 00:47:08.440
I got to meet you in person.


00:47:08.440 --> 00:47:09.900
- Yeah, you as well, it's great.


00:47:09.900 --> 00:47:12.600
- And like a bunch of other people that I only knew,


00:47:12.600 --> 00:47:14.320
you know, just like on the internet.


00:47:14.320 --> 00:47:15.840
A bunch of core developers and like,


00:47:15.840 --> 00:47:17.000
that's so cool, they are so cool.


00:47:17.000 --> 00:47:18.520
Like I knew they were super cool,


00:47:18.520 --> 00:47:20.520
but just like, you know, talking on Twitter


00:47:20.520 --> 00:47:23.200
and like then seeing in person, that's amazing.


00:47:23.200 --> 00:47:25.200
- I really, that's my favorite part of the whole conference.


00:47:25.200 --> 00:47:27.960
It's just the people and the getting together.


00:47:27.960 --> 00:47:31.240
- Definitely, I think I attended like two talks.


00:47:31.240 --> 00:47:34.480
So I was just on the hallways talking to everyone.


00:47:34.480 --> 00:47:35.520
- You feel the hallway traffic.


00:47:35.520 --> 00:47:38.040
- Yeah, yeah, I was all the way on the hallway traffic.


00:47:38.040 --> 00:47:39.200
- Awesome, well that's great.


00:47:39.200 --> 00:47:40.240
- Yeah, I absolutely love it.


00:47:40.240 --> 00:47:42.520
I remember Sebastian and I joined the language summit


00:47:42.520 --> 00:47:45.200
remotely two years ago, the year when there was no PyCon.


00:47:45.200 --> 00:47:48.160
And the most interesting bit of the like four hour Zoom call


00:47:48.160 --> 00:47:49.600
was the five minutes between talks


00:47:49.600 --> 00:47:50.760
when people just chatted.


00:47:50.760 --> 00:47:53.420
And I remember then thinking how cool PyCon must be


00:47:53.420 --> 00:47:55.200
to have that same group of people


00:47:55.200 --> 00:47:57.320
like in a room rather than on a Zoom call.


00:47:57.320 --> 00:47:58.940
So, no, I love it.


00:47:58.940 --> 00:48:00.960
I think it's, I've really enjoyed it.


00:48:00.960 --> 00:48:02.240
Last year was my first year.


00:48:02.240 --> 00:48:03.280
This year is even more fun.


00:48:03.280 --> 00:48:04.200
Yeah, I really enjoy it.


00:48:04.200 --> 00:48:06.040
- Awesome, yeah, it's been great to meet you both in person.


00:48:06.040 --> 00:48:07.440
- Of course, meeting you has been the best bit of all.


00:48:07.440 --> 00:48:08.280
- Thank you very much.


00:48:08.280 --> 00:48:09.280
No, no, it's been really great


00:48:09.280 --> 00:48:10.480
to spend some time with you all here


00:48:10.480 --> 00:48:12.820
and thanks for coming on the podcast.


00:48:12.820 --> 00:48:15.000
Part two now here to wrap things up.


00:48:15.000 --> 00:48:16.640
So it's, thanks for taking the time


00:48:16.640 --> 00:48:18.840
and congrats both on the success of your projects.


00:48:18.840 --> 00:48:19.840
They're amazing.


00:48:19.840 --> 00:48:20.680
- Thanks so much.


00:48:20.680 --> 00:48:21.500
- Thank you very much.


00:48:21.500 --> 00:48:23.200
Thanks for having us and thanks for seeing us.


00:48:23.200 --> 00:48:24.040
- Yeah, bye guys.


00:48:24.040 --> 00:48:26.880
This has been another episode of Talk Python to Me.


00:48:26.880 --> 00:48:28.320
Thank you to our sponsors.


00:48:28.320 --> 00:48:29.680
Be sure to check out what they're offering.


00:48:29.680 --> 00:48:31.280
It really helps support the show.


00:48:31.280 --> 00:48:32.880
Take some stress out of your life.


00:48:32.880 --> 00:48:35.080
Get notified immediately about errors


00:48:35.080 --> 00:48:37.040
and performance issues in your web


00:48:37.040 --> 00:48:38.720
or mobile applications with Sentry.


00:48:38.720 --> 00:48:43.320
Just visit talkpython.fm/sentry and get started for free.


00:48:43.320 --> 00:48:46.760
And be sure to use the promo code, talkpython, all one word.


00:48:46.760 --> 00:48:50.040
InfluxData encourages you to try InfluxDB.


00:48:50.040 --> 00:48:52.240
InfluxDB is a database purpose-built


00:48:52.240 --> 00:48:53.960
for handling time series data


00:48:53.960 --> 00:48:56.860
at a massive scale for real-time analytics.


00:48:56.860 --> 00:49:00.680
Try it for free at talkpython.fm/influxdb.


00:49:00.680 --> 00:49:02.000
Want to level up your Python?


00:49:02.000 --> 00:49:03.800
We have one of the largest catalogs


00:49:03.800 --> 00:49:06.040
of Python video courses over at Talk Python.


00:49:06.040 --> 00:49:08.080
Our content ranges from true beginners


00:49:08.080 --> 00:49:11.040
to deeply advanced topics like memory and async.


00:49:11.040 --> 00:49:13.700
And best of all, there's not a subscription in sight.


00:49:13.700 --> 00:49:16.520
Check it out for yourself at training.talkpython.fm.


00:49:16.520 --> 00:49:18.160
Be sure to subscribe to the show,


00:49:18.160 --> 00:49:21.120
open your favorite podcast app, and search for Python.


00:49:21.120 --> 00:49:22.240
We should be right at the top.


00:49:22.240 --> 00:49:25.120
You can also find the iTunes feed at /itunes,


00:49:25.120 --> 00:49:27.280
the Google Play feed at /play,


00:49:27.280 --> 00:49:31.360
and the Direct RSS feed at /rss on talkpython.fm.


00:49:31.360 --> 00:49:33.980
We're live streaming most of our recordings these days.


00:49:33.980 --> 00:49:35.120
If you want to be part of the show


00:49:35.120 --> 00:49:37.400
and have your comments featured on the air,


00:49:37.400 --> 00:49:39.280
be sure to subscribe to our YouTube channel


00:49:39.280 --> 00:49:41.880
at talkpython.fm/youtube.


00:49:41.880 --> 00:49:43.280
This is your host, Michael Kennedy.


00:49:43.280 --> 00:49:44.460
Thanks so much for listening.


00:49:44.460 --> 00:49:45.640
I really appreciate it.


00:49:45.640 --> 00:49:47.640
Now get out there and write some Python code.


00:49:47.640 --> 00:49:50.220
(upbeat music)


00:49:50.220 --> 00:50:05.220
[Music]

