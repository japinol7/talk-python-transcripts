WEBVTT

00:00:00.000 --> 00:00:04.800
We've spoken previously about security and software supply chains, and we're back at it

00:00:04.800 --> 00:00:09.440
on this episode. We're diving in again with Charlie Coggins. Charlie works at a software

00:00:09.440 --> 00:00:15.440
supply chain company and is on the episode to give us an insider's look and a defender's

00:00:15.440 --> 00:00:21.120
perspective on how to keep our Python apps and infrastructure safe. This is Talk Python to Me,

00:00:21.120 --> 00:00:43.520
episode 457, recorded January 24th, 2024. Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:43.520 --> 00:00:48.240
This is your host, Michael Kennedy. Follow me on Mastodon, where I'm @mkennedy, and follow the

00:00:48.240 --> 00:00:54.720
podcast using @talkpython, both on mastodon.org. Keep up with the show and listen to over seven

00:00:54.720 --> 00:01:00.960
years of past episodes at talkpython.fm. We've started streaming most of our episodes live on

00:01:00.960 --> 00:01:06.640
YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about

00:01:06.640 --> 00:01:12.640
upcoming shows and be part of that episode. This episode is brought to you by Sentry. Don't let

00:01:12.640 --> 00:01:20.080
those errors go unnoticed. Use Sentry like we do here at Talk Python. Sign up at talkpython.fm/sentry.

00:01:20.080 --> 00:01:25.680
And it's brought to you by Mailtrap, an email delivery platform that developers love. Use their

00:01:25.680 --> 00:01:31.200
email sandbox to inspect and debug emails in staging, dev, and QA environments before sending

00:01:31.200 --> 00:01:38.720
them to recipients in production. Try Mailtrap for free at talkpython.fm/mailtrap. Hey, Charlie,

00:01:38.720 --> 00:01:44.160
welcome to Talk Python To Me. Hi, Michael. Great to have you here. We have corresponded back and

00:01:44.160 --> 00:01:49.680
forth about security things. And now, are you here to scare us? Is that what's going to happen?

00:01:49.680 --> 00:01:55.280
It's going to seem that way. There are threats everywhere, especially when you start looking.

00:01:55.280 --> 00:02:00.320
And that's the problem. You look, you'll find them. If you're not looking, you might get

00:02:00.320 --> 00:02:05.920
affected without even knowing it. Yeah, but that's true. But we're also going to come with

00:02:05.920 --> 00:02:11.520
some tools and techniques and tips on how to avoid security problems with your Python code.

00:02:11.520 --> 00:02:18.560
Yes, absolutely. Yeah. I think it's especially concerning. That certainly catches my attention

00:02:18.560 --> 00:02:25.760
that if you mess with somebody's software, like the software builders, the developers,

00:02:25.760 --> 00:02:30.640
it gets shipped to however many users are on the other side of that equation, right? It's not like

00:02:30.640 --> 00:02:37.600
I just took over some teenager's gaming PC and now what can I do? It's like, I took over, name

00:02:37.600 --> 00:02:42.960
your big web app, and now we're going to start shipping some stuff around. All right. That's

00:02:42.960 --> 00:02:49.440
where the multiplicative aspect of this gets more concerning than just standard personal computer

00:02:49.440 --> 00:02:58.560
safety, right? Oh, absolutely. A single developer can have very broad impacts. Maybe they publish

00:02:58.560 --> 00:03:04.480
one package, but that one package could be included in hundreds, thousands of other packages as a

00:03:04.480 --> 00:03:11.680
dependency. And then everyone using those packages could be affected. Whether the code is good and

00:03:11.680 --> 00:03:16.560
works as intended or poorly written and has bugs and vulnerabilities. Yeah. It's malicious.

00:03:16.560 --> 00:03:21.920
It's not to say there's any chance of there being a problem with Pydantic, but just to make your

00:03:21.920 --> 00:03:26.640
point, if you go to like Pydantic or request or something like that, a lot of these have

00:03:26.640 --> 00:03:34.800
used by projects, right? And this Pydantic is used by 315,000 people, not people, software

00:03:34.800 --> 00:03:39.760
projects that themselves have users, right? And so that's the kind of stuff that I'm thinking

00:03:39.760 --> 00:03:44.640
about when I said that multiplicative effect, right? It's a big multiplier, not just a couple.

00:03:44.640 --> 00:03:49.920
Oh yeah. Yeah, for sure. Yeah. Now, before we dive into our main topic, of course,

00:03:49.920 --> 00:03:54.640
tell people a bit about yourself. All right. Well, my name is Charles Coggins. I usually go by

00:03:54.640 --> 00:04:01.280
Charlie and I'm a Python developer. I'm a software developer, but not through the traditional sense.

00:04:01.280 --> 00:04:08.320
I don't have a computer science degree. I didn't come to this straight out of school. I got my

00:04:08.320 --> 00:04:16.400
first taste of programming long enough ago, back in the '80s, in 1987. My dad got a computer for

00:04:16.400 --> 00:04:24.320
us and I was messing around on there with some games, always with games, right? When at the time

00:04:24.320 --> 00:04:29.680
it was basic, it was this bowling game that my brother and I would play. And I saw that I could

00:04:29.680 --> 00:04:34.080
look at the code, I could look at the source. And I went in there and modified it a bit to make it

00:04:34.080 --> 00:04:38.640
so that I would always win whenever I played them. But then-

00:04:38.640 --> 00:04:40.240
How long did it take him to catch on?

00:04:40.240 --> 00:04:46.320
Oh, he figured out pretty quickly. And he was in there too, changing ball speed and how often he

00:04:46.320 --> 00:04:53.280
could get a gutter or make him get a gutter. But yeah, I took a class or two in high school and

00:04:53.280 --> 00:04:59.600
college, but I was an electrical engineering major and then went to work for the government

00:04:59.600 --> 00:05:07.360
doing something that wasn't even really that. So I spent 10 years working for the government before

00:05:07.920 --> 00:05:17.680
they stood up the US Cyber Command and decided or figured out that they needed to hire 6,000 new

00:05:17.680 --> 00:05:23.280
developers to fill the positions. And there weren't that many available in the industry,

00:05:23.280 --> 00:05:29.280
let alone those who could pass the clearances and work in that environment. So they looked to

00:05:29.280 --> 00:05:33.440
people already working in the government and I raised my hand. I said, "Yes, yes, I want to

00:05:33.440 --> 00:05:38.080
cross-train. I'll be a developer." And so they trained me.

00:05:38.080 --> 00:05:41.120
What did they teach you for language in that program?

00:05:41.120 --> 00:05:49.280
We started with C, C++, and then there was some Python. So I went through a couple of boot camps

00:05:49.280 --> 00:05:54.640
and a lot of self-learning, self-teaching. Python's the one that really clicked for me.

00:05:54.640 --> 00:05:56.480
It just made sense in my head.

00:05:56.480 --> 00:06:01.760
Yeah, of course. If you're learning to do cybersecurity stuff, you know, a lot of times

00:06:01.760 --> 00:06:07.760
I'd be happy to tell people like, "Ah, you don't really need to learn C or Rust or Java." If you

00:06:07.760 --> 00:06:14.080
just know Python, you're probably 90% of the time golden. But if you're trying to do cybersecurity,

00:06:14.080 --> 00:06:19.600
a lot of times it's about the machine level stuff, right? Understanding things like C and

00:06:19.600 --> 00:06:24.880
pointers and buffer overflows and all of that kind of stuff is where you actually kind of need to be.

00:06:24.880 --> 00:06:29.920
And they taught us all that as well. In fact, we learned assembly language as well,

00:06:29.920 --> 00:06:32.880
and that one really didn't fit in my brain.

00:06:32.880 --> 00:06:38.400
You're like, "I want to become an assembly language programmer."

00:06:38.400 --> 00:06:41.280
I mean, yeah, that's a whole different breed.

00:06:41.280 --> 00:06:48.080
Yeah, it sure is. And it used to be, I remember when I first got into programming, I was doing

00:06:48.080 --> 00:06:54.080
some C, C++, and inline assembly was something people would do a lot to optimize. A lot like

00:06:54.080 --> 00:06:59.760
people might do Cython or Numba or something like that to make Python fast. Like, "We'll find this

00:06:59.760 --> 00:07:02.880
little part and we'll rewrite it in this way." And be like, "We're just going to do inline

00:07:02.880 --> 00:07:08.720
assembly." I'm like, "That just doesn't seem like worthwhile. I don't need that much performance.

00:07:08.720 --> 00:07:09.600
We're going to not do that."

00:07:09.600 --> 00:07:20.480
Fun. So now you're working at Phylum. Is it Python-focused or just software security?

00:07:20.480 --> 00:07:28.480
It's not Python-focused. In fact, the company primarily develops with Rust, as you were

00:07:28.480 --> 00:07:35.680
mentioning. We've got some excellent Rust developers at our company, and I think that's

00:07:35.680 --> 00:07:42.000
what's attracted a lot of them is that that is the primary language we use. But we also have some

00:07:42.000 --> 00:07:48.720
developments in Python. And when I came on board, I got assigned to work on our integrations.

00:07:48.720 --> 00:07:58.000
So like GitHub integrations, GitLab, pre-commit hooks, things like that. And so I was able to

00:07:58.000 --> 00:08:04.080
kind of architect it the way I thought best. And because I love Python, I made it all in Python and

00:08:04.080 --> 00:08:07.360
exposed it through Docker containers.

00:08:07.360 --> 00:08:18.080
Are you doing direct integration with Rust, like Py03? Or is it more just issuing commands out?

00:08:18.080 --> 00:08:23.440
The Rust elements that our company works on, like our API, the command line interface,

00:08:24.480 --> 00:08:30.080
a lot of the backend, it's just written straight Rust. And then the Python is just plain Python.

00:08:30.080 --> 00:08:33.840
There's no interface between the two, really.

00:08:33.840 --> 00:08:38.160
Yeah. Okay. Consuming APIs and Docker containers and stuff like that.

00:08:38.160 --> 00:08:44.720
Right, right, right. Although I am interested in the Py03, and I think there's room to

00:08:44.720 --> 00:08:47.600
bridge the two languages at our company.

00:08:48.640 --> 00:08:54.720
I mean, for sure, people are adopting Rust for the performance foundations of Python.

00:08:54.720 --> 00:08:57.360
It's pretty interesting.

00:08:57.360 --> 00:09:03.600
Yeah, yeah. I've been at the company almost two years now. I keep saying it's what I'm

00:09:03.600 --> 00:09:08.080
going to learn next, is Rust. And I felt like I would just kind of absorb it by going through

00:09:08.080 --> 00:09:13.520
code reviews and the people on my team. It hasn't happened yet. I can kind of understand what's

00:09:13.520 --> 00:09:16.880
going on by reading it, but I just, yeah, I need to jump in.

00:09:16.880 --> 00:09:19.440
Deaf in, deaf, okay, got it. Those are the same. Okay, got it.

00:09:19.440 --> 00:09:20.000
Yeah, yeah.

00:09:20.000 --> 00:09:26.480
No, it's interesting. Okay. Well, we're not here to talk about Rust, although I do think

00:09:26.480 --> 00:09:31.520
it's becoming one of those things that is sort of, I don't know, if you need to be a little

00:09:31.520 --> 00:09:37.520
one level deeper in the Python space, that used to be C, and now it's, I think it's pretty solidly

00:09:37.520 --> 00:09:40.720
moving to be Rust, right? There's a lot of popular things,

00:09:40.720 --> 00:09:44.320
gigantic, for example, I pulled up earlier, where that's the foundation,

00:09:44.320 --> 00:09:46.800
but that also seems to be where the momentum is.

00:09:46.800 --> 00:09:52.400
Yeah. The oxidation of Python libraries is a real thing. I mean, look at Ruff.

00:09:52.400 --> 00:10:02.080
Yeah. Ruff. I just heard about how Granian, I think it was, which is a new, similar to

00:10:02.080 --> 00:10:08.720
G-Unicorn and MicroWSGI is a Rust-based async server. It goes on and on.

00:10:10.800 --> 00:10:15.760
This portion of Talk Python to Me is brought to you by OpenTelemetry support at Sentry.

00:10:15.760 --> 00:10:21.600
In the previous two episodes, you heard how we use Sentry's error monitoring at Talk Python,

00:10:21.600 --> 00:10:26.240
and how distributed tracing connects errors, performance and slowdowns and more

00:10:26.240 --> 00:10:31.920
across services and tiers. But you may be thinking, our company uses OpenTelemetry,

00:10:31.920 --> 00:10:37.520
so it doesn't make sense for us to switch to Sentry. After all, OpenTelemetry is a standard,

00:10:37.520 --> 00:10:42.240
and you've already adopted it, right? Well, did you know, with just a couple of lines of code,

00:10:42.240 --> 00:10:48.480
you can connect OpenTelemetry's monitoring and reporting to Sentry's backend. OpenTelemetry

00:10:48.480 --> 00:10:53.440
does not come with a backend to store your data, analytics on top of that data, a UI,

00:10:53.440 --> 00:10:58.160
or error monitoring. And that's exactly what you get when you integrate Sentry with your

00:10:58.160 --> 00:11:04.960
OpenTelemetry setup. Don't fly blind, fix and monitor code faster with Sentry. Integrate your

00:11:04.960 --> 00:11:09.440
OpenTelemetry systems with Sentry and see what you've been missing. Create your Sentry account

00:11:09.440 --> 00:11:16.640
at talkpython.fm/sentry-telemetry. And when you sign up, use the code TALKPYTHON, all caps,

00:11:16.640 --> 00:11:21.040
no spaces. It's good for two free months of Sentry's business plan, which will give you

00:11:21.040 --> 00:11:26.880
20 times as many monthly events as well as other features. My thanks to Sentry for supporting

00:11:26.880 --> 00:11:33.840
Talk Python to me. All right, well, let's talk about software security, though. You know, like,

00:11:33.840 --> 00:11:37.520
we touched on it a little bit with the multiplicative aspect of like why software

00:11:37.520 --> 00:11:44.800
developers should care. But maybe let's start with some ways in which viruses might get on

00:11:44.800 --> 00:11:49.920
your computer from a software perspective. Not from like, "Oh, you know, I found this cool app

00:11:49.920 --> 00:11:53.680
on BitTorrent and normally it's paid, but this one's free." It's like, "Hmm, maybe don't install

00:11:53.680 --> 00:11:58.000
that." But, you know, not that kind of advice, right? But, you know, specifically for software

00:11:58.000 --> 00:12:02.880
developers. Right, right. So for software developers, I think the primary

00:12:03.280 --> 00:12:10.640
vector, you know, for malicious code running in your environment or really any developer

00:12:10.640 --> 00:12:15.520
environment along the way, it doesn't just have to be your system. It could be your CI/CD servers

00:12:15.520 --> 00:12:21.120
and your runners. It's going to be software dependencies, third-party code, right?

00:12:21.120 --> 00:12:26.080
Code from strangers on the internet, right? That's really what it boils down to.

00:12:26.080 --> 00:12:32.720
They just, Charlie, they're just here to help out. They're just giving you the code to help out.

00:12:32.720 --> 00:12:37.840
They have no bad intentions. Right, right. Except for that one. That one over there, don't take it.

00:12:37.840 --> 00:12:48.960
Yeah. And it's hard to tell, you know, what's good, what's bad. And I think we all rely on

00:12:48.960 --> 00:12:54.880
third-party code. I mean, I think it's a rare company, rare project that writes everything

00:12:54.880 --> 00:13:04.000
from scratch on their own without any dependencies. So that's a vector for sure, is allowing code from

00:13:04.000 --> 00:13:11.440
strangers on the internet to run. I think like the name of the game, right, for attackers and

00:13:11.440 --> 00:13:17.360
threat actors is arbitrary code execution. Like that's the key phrase, arbitrary code execution.

00:13:17.360 --> 00:13:23.760
If I can get arbitrary code execution with this vulnerability, then I've won. I can attack your

00:13:23.760 --> 00:13:29.200
score of nine or above. So right there. Yeah, exactly. And that's for vulnerabilities. That's

00:13:29.200 --> 00:13:35.040
just, you know, poorly written code or code with bugs. But forget about vulnerabilities. I mean,

00:13:35.040 --> 00:13:40.960
if you're an attacker, you're a threat actor, you've already got the perfect means to run

00:13:40.960 --> 00:13:46.240
arbitrary code, to gain arbitrary code execution on a developer system. That's with third-party

00:13:46.240 --> 00:13:53.360
dependencies. Open source software is just the perfect target for writing malware.

00:13:53.600 --> 00:13:56.000
You're slipping malware into packages.

00:13:56.000 --> 00:14:01.520
Now, when people hear this, we've talked about it enough. It actually came as quite a surprise

00:14:01.520 --> 00:14:07.680
a few years ago. People theoretically knew that it could happen, but that it was happening is that

00:14:07.680 --> 00:14:14.880
packages on package stores like PyPI and NPM and so on got published vulnerabilities that people

00:14:14.880 --> 00:14:19.200
could then install and make part of theirs. But there's a whole software supply chain, right?

00:14:19.200 --> 00:14:23.040
Maybe talk us through some of the different elements that make that up. Only one of which

00:14:23.040 --> 00:14:29.040
is these libraries, right? That's right. That's right. So the software supply chain is, it's

00:14:29.040 --> 00:14:35.280
really, it's using third-party code securely, as well as securing the end-to-end development process.

00:14:35.280 --> 00:14:43.360
So that process is, you know, very broadly broken into three phases. You've got the source phase,

00:14:43.360 --> 00:14:49.440
that's, you know, source control management systems, and then actual, actually coding,

00:14:49.440 --> 00:14:54.320
developers coding on their systems, you know, committing to repositories.

00:14:54.320 --> 00:15:02.080
Yeah. You know, you mentioned the dependencies like pip install this or that. There's also,

00:15:02.080 --> 00:15:09.920
for many of the really popular IDs and editors, there's a whole massive array of variants,

00:15:09.920 --> 00:15:14.240
levels of trusted plugins or extensions, right? As well.

00:15:14.240 --> 00:15:19.760
That's right. Yeah. Like Visual Studio Code. That's what I use for my IDE. You know, it's got

00:15:19.760 --> 00:15:27.120
an extensive extension ecosystem. Just about anything you want to do. I get a little pop-up

00:15:27.120 --> 00:15:31.200
when I open a new project and it says, "Oh, I recognize you're using a YAML file. Do you want

00:15:31.200 --> 00:15:35.760
to download this extension that will lint YAML files?" Right? Like, there's an extension for that.

00:15:35.760 --> 00:15:42.800
Yeah. I got one for CVEs. It was like rainbow CSV syntax highlighter. So then I'm like,

00:15:42.800 --> 00:15:47.600
"You know what? That's not really made by a trusted company. It's probably fine.

00:15:47.600 --> 00:15:54.720
But I don't need my CSV files highlighted so much so that I'm willing to just like run

00:15:54.720 --> 00:15:57.040
arbitrary code from a stranger on the internet."

00:15:57.040 --> 00:15:58.000
That's right.

00:15:58.000 --> 00:16:04.160
Right. And, you know, I use both PyCharm and VS Code and they both,

00:16:04.160 --> 00:16:08.640
especially PyCharm, has sort of a warning that says, "This is untrusted. It's a third-party

00:16:08.640 --> 00:16:12.480
thing. Are you sure you want it?" Like, you know, that's a pretty light warning.

00:16:12.480 --> 00:16:17.280
And also they're not the same, right? Is it installed by a million people

00:16:17.280 --> 00:16:22.960
used every day or is it for you the fourth person to use it? And it hasn't, you know,

00:16:22.960 --> 00:16:28.080
had the experience of people going, "Why is it called opening a network socket? What's it doing?"

00:16:28.080 --> 00:16:29.600
You know, something like that.

00:16:31.360 --> 00:16:36.720
Yeah. Yeah. That's another entry point that you got to be careful about.

00:16:36.720 --> 00:16:40.640
All right. Well, I cut you off. We're only in like square one of maybe nine.

00:16:40.640 --> 00:16:47.280
Yeah. Yeah. Square one, source code, and then there's the build phase. That's where

00:16:47.280 --> 00:16:50.720
you take the code, you take the commits that have gone into source control,

00:16:50.720 --> 00:16:57.040
and you build something with it, right? This usually happens in, you know, your CI/CD systems,

00:16:57.600 --> 00:17:05.760
GitHub, GitHub's and GitLabs of the world. And it's at that point where, you know,

00:17:05.760 --> 00:17:12.640
your third-party dependencies get included and wrapped up into your artifacts, right?

00:17:12.640 --> 00:17:20.560
Which brings us to the third stage of the software supply chain, which is the package and deploy

00:17:20.560 --> 00:17:27.360
phase. That's where you're creating your artifacts and making them available to the world to use.

00:17:28.000 --> 00:17:33.440
Could be anything. It could be a wheel for a library that other parts of your company use

00:17:33.440 --> 00:17:39.840
to build software. It could be some app you ship. It could actually be a website, an API,

00:17:39.840 --> 00:17:40.480
who knows, right?

00:17:40.480 --> 00:17:43.840
Yeah. A Docker container. Yeah.

00:17:43.840 --> 00:17:44.880
Yeah. Yeah, exactly.

00:17:44.880 --> 00:17:50.000
And then by the time you get to that, you know, the end of the supply chain and, you know,

00:17:50.000 --> 00:17:55.760
the products or the packaged product that people are going to see and use and work with,

00:17:57.040 --> 00:18:02.960
you know, you've baked in so many elements at that point, you know, from your third-party

00:18:02.960 --> 00:18:13.280
dependencies to, you know, any other external resources that are getting called. So there's

00:18:13.280 --> 00:18:16.800
lots of points along the way that it's possible to...

00:18:16.800 --> 00:18:23.040
And one of the things that can be sneaky is, you know, it doesn't happen that often in Python,

00:18:23.040 --> 00:18:29.440
but you're shipping like a Windows or a Mac app. There's a digital signature roof of,

00:18:29.440 --> 00:18:33.760
we're going to sign this with our trusted certificate. So it doesn't even give you

00:18:33.760 --> 00:18:38.880
any warnings. Like, look, this is, it's signed by the company. It is trusted. Here you go.

00:18:38.880 --> 00:18:45.520
Pick it. Right. And somewhere upstream from that, there's an issue like with packages or other

00:18:45.520 --> 00:18:50.480
things. Well, that issue is now that that problem is signed and verified as well.

00:18:50.480 --> 00:18:57.200
Yeah. Yeah. You know, so you mentioned code signing, the research team at our company,

00:18:57.200 --> 00:19:03.840
I mean, they're amazing, amazing group there. They're always finding new and novel attacks.

00:19:03.840 --> 00:19:11.280
And when they found just this past week, involved something kind of cool where the attacker had

00:19:11.280 --> 00:19:19.280
bundled up a valid Microsoft binary, had been signed by Microsoft, but they bundled it with

00:19:19.280 --> 00:19:27.200
the DLL that was malicious. It was named something to be expected. Right. So when you run the

00:19:27.200 --> 00:19:35.200
executable on the binary, you know, you could see that there's this Microsoft signs application

00:19:35.200 --> 00:19:39.760
looking for permissions, looking to continue. And you think, oh yeah, great. Signed by Microsoft,

00:19:39.760 --> 00:19:45.680
no problem. But then it uses this technique called like DLL search order hijacking

00:19:47.120 --> 00:19:53.920
technique. Right. So if you have a DLL that's being called by the application more locally

00:19:53.920 --> 00:20:00.480
than not, it's looking for the same directory. Yeah. It'll look like looking for the name of

00:20:00.480 --> 00:20:06.240
the DLL in the same directory first, basically is what's happening. Right. Right. It shipped

00:20:06.240 --> 00:20:13.600
their bad DLL with a good binary. So you pick something in system 32 that's got like a real

00:20:13.600 --> 00:20:20.560
common name, like VC runtime, whatever, dot DLL, or, you know, some of the standard ones,

00:20:20.560 --> 00:20:25.280
but then you completely reprogram it and stick it in there with that app. Or maybe not completely

00:20:25.280 --> 00:20:30.240
because you need the app to not crash, but you give it some extra boost when it does something.

00:20:30.240 --> 00:20:36.320
Right. Yeah. Yeah. In this case, they had just copied all the files needed for execution into

00:20:36.320 --> 00:20:42.160
a new directory, including the known good binary, the known bad DLL, and then, you know,

00:20:42.160 --> 00:20:45.920
it had everything it needed in that directory to run. And it looked like it was legitimate.

00:20:45.920 --> 00:20:51.040
Right. A lot of the OS dependent, a lot of these OS checks are on the executable,

00:20:51.040 --> 00:20:56.800
the system libraries that they use. Right. Right. Right. You'll see like this, this executable is

00:20:56.800 --> 00:21:01.440
downloaded from the internet to show you want to run it. Like that doesn't say this executable,

00:21:01.440 --> 00:21:06.400
which you trust is maybe possibly using a library that you downloaded. Like it doesn't say that.

00:21:06.400 --> 00:21:11.440
Right. Yeah. Cause we could never get work done if there was that level of checking all over the

00:21:11.440 --> 00:21:19.120
place. This is an updated somewhere. This portion of talk Python to me is brought to you by Mailtrap.

00:21:19.120 --> 00:21:23.360
We're going to keep this super short. So please pay attention or you'll miss it. Mailtrap is an

00:21:23.360 --> 00:21:29.280
email delivery platform that developers love. An email sending solution with industry best analytics,

00:21:29.280 --> 00:21:36.960
SMTP, and email APIs and SDKs for major programming languages with 24/7 human support. What makes

00:21:36.960 --> 00:21:42.560
them unique is their email sandbox. Use email sandbox to inspect and debug emails in staging

00:21:42.560 --> 00:21:48.880
dev and QA environments before sending them to recipients in production. Try Mailtrap for free

00:21:48.880 --> 00:21:56.720
at talkpython.fm/mailtrap. That's kind of the space that we're talking about, right? We've got

00:21:56.720 --> 00:22:04.240
editors, we've got libraries that you use, CI/CD pipelines, containers are super interesting as

00:22:04.240 --> 00:22:10.720
well, and all the tools to go with those. So let's talk through some of the posts that you've

00:22:10.720 --> 00:22:15.680
written and also just selected about some of these things and maybe starting to the front of that

00:22:15.680 --> 00:22:23.360
list there with lock files. Yeah. Okay. So yes, I wrote a blog post. I guess it's looking at the

00:22:23.360 --> 00:22:28.480
date on your screen. It looks like it was over a year ago now. And probably seems like yesterday,

00:22:28.480 --> 00:22:34.080
but no. Yeah, that's right. 2022 it was. So I'm sure the landscape has changed since then a bit,

00:22:34.080 --> 00:22:41.200
and maybe there's some new players out there. But yeah, I think one thing you can do as a

00:22:41.200 --> 00:22:48.640
developer, a big one I would recommend is use lock files for your dependencies, right? And

00:22:50.560 --> 00:22:59.200
what's a lock file? Well, it's the fully resolved set of dependencies that are used

00:22:59.200 --> 00:23:09.440
by your application, your package. And if nothing else, you should know what's going into your code,

00:23:09.440 --> 00:23:16.080
right? Not just your direct code. Yeah, exactly. That's a bit of a challenge, right? And I think

00:23:17.120 --> 00:23:23.840
I'll admit when I first got into Python, I didn't do this that well. And to me, it felt like probably

00:23:23.840 --> 00:23:28.880
the biggest issue I might run into is instability in my app, right? Like for example, if I don't

00:23:28.880 --> 00:23:34.000
pin a dependency, some new thing comes out, I reinstall it on a new computer, maybe it gets an

00:23:34.000 --> 00:23:38.800
upgraded version, and there's some library that doesn't work, right? I mean, there's been certainly

00:23:38.800 --> 00:23:43.840
popular libraries that just said, we're having a major version change and we're fixing the mistakes

00:23:43.840 --> 00:23:48.080
we made 10 years ago, and these three functions are changing or whatever, right? That would break

00:23:48.080 --> 00:23:55.200
it. But it could also be there's now a malicious version of library X, that's version two. But if

00:23:55.200 --> 00:24:00.240
you pinned it on version one, even though it's bad, you're still not getting the bad one, at least

00:24:00.240 --> 00:24:09.120
for a while, right? Absolutely, yes. So I think I gotta look it up. I always forget. PEP 665.

00:24:09.680 --> 00:24:16.960
Okay. Yeah, PEP 665. It's a rejected PEP, unfortunately, but it was written by Brett

00:24:16.960 --> 00:24:22.160
Cannon, some others. I know you've had Brett on the show a number of times. I love the stuff he

00:24:22.160 --> 00:24:27.600
does. He really understands all of this. And it's kind of a shame this was rejected, but this PEP

00:24:27.600 --> 00:24:38.000
tried to create a standard lock file format for Python. And if you look into the PEP a little

00:24:38.000 --> 00:24:43.760
bit, there's some motivation about why you'd want to do this and four big reasons. And the third one

00:24:43.760 --> 00:24:50.400
is one I really key on, which is that lock files allow for reproducibility. And reproducibility is

00:24:50.400 --> 00:24:55.520
just more secure. I'm quoting here from the PEP, it says, "When you control exactly what files are

00:24:55.520 --> 00:25:00.400
installed, you can make sure no malicious actor is attempting to slip nefarious code into your

00:25:00.400 --> 00:25:05.760
application, i.e. some supply chain attacks. By using a lock file, which always leads to

00:25:05.760 --> 00:25:12.320
reproducible installs, we can avoid certain risks entirely." And I mean, that's the name of the game.

00:25:12.320 --> 00:25:21.760
That's what our company focuses on, which is avoiding those risks by ensuring you know which

00:25:21.760 --> 00:25:26.240
dependencies you're using and you're knowing that those dependencies are benign or good,

00:25:26.240 --> 00:25:27.600
doing no harm.

00:25:27.600 --> 00:25:34.640
Even if there's something that happens, usually it's going to happen to a popular library because

00:25:34.640 --> 00:25:39.520
you're using it, hence probably other people are using it other than type of squatting,

00:25:39.520 --> 00:25:46.240
which we can talk about. But if you pin your dependencies, chances are these things only

00:25:46.240 --> 00:25:49.840
stick around for a little while. It's not like, "Oh, they discovered it had been there for eight

00:25:49.840 --> 00:25:54.720
months." It's like, "Oh my gosh, we heard about it. A few people got it and then we got rid of it."

00:25:54.720 --> 00:25:55.040
Right?

00:25:55.040 --> 00:25:55.360
Yes.

00:25:55.360 --> 00:26:00.400
The folks at PyPA are pretty excellent. So it's to some degree a timing issue as well.

00:26:00.400 --> 00:26:06.640
Yes. Vulnerabilities are different, right? That's what a lot of people focus on. A lot of the

00:26:06.640 --> 00:26:13.040
tooling exists to discover vulnerabilities in your dependencies, which is good to know about those,

00:26:13.040 --> 00:26:19.760
but those exist for a long time, right? You have CVEs for known vulnerabilities and they end up in

00:26:19.760 --> 00:26:25.280
these databases and they're there for years. And if you're using old dependencies or maybe

00:26:25.280 --> 00:26:30.000
transitive dependencies are using old ones and you're stuck on it, then you're going to be

00:26:30.000 --> 00:26:32.960
exposed to those vulnerabilities. But what's different about-

00:26:32.960 --> 00:26:39.520
Examples. Sorry. Examples of those include the WebP library not too long ago, right? That was

00:26:39.520 --> 00:26:45.680
baked into Python and then also OpenSSL, right? So people discovered issues in those. Those are

00:26:45.680 --> 00:26:50.240
baked into different aspects of Python or some of the libraries. And it's like, well, all of a

00:26:50.240 --> 00:26:54.880
sudden there's this fire drill, which is different than somebody going, "I'm going to sneak a thing

00:26:54.880 --> 00:26:58.800
into the library system." Right. And then it is a timing matter. So

00:26:58.800 --> 00:27:05.120
malicious dependencies, that's a whole other story. Because if a malicious package is discovered,

00:27:05.120 --> 00:27:11.040
there's not a CVE created for it. The package is just taken off of the registry. You report it to

00:27:11.040 --> 00:27:17.920
good people at PyPI and they'll review the submission and take it down. I've done a few

00:27:17.920 --> 00:27:24.320
of those myself and they're really fast, but there's still a window of time where

00:27:24.320 --> 00:27:29.280
that malicious package, that malicious dependency is up and available. And that's-

00:27:29.280 --> 00:27:31.600
Yeah. I do think pinning your dependency-

00:27:31.600 --> 00:27:32.800
Often all that's needed.

00:27:32.800 --> 00:27:36.960
Yeah, exactly. I do think having a pinned dependency there is worthwhile. Because if you

00:27:36.960 --> 00:27:42.160
make a commit, your CI runs, et cetera, et cetera, right? The chances that you just bump the version

00:27:42.160 --> 00:27:48.880
to this malicious thing is pretty low. Yeah, exactly. So yeah. And having version

00:27:48.880 --> 00:27:52.720
ranges is not enough. You need to have explicit versions.

00:27:53.520 --> 00:27:55.440
Let's talk more about these lock files then.

00:27:55.440 --> 00:28:03.600
There's actually a bunch of choices these days. And Brett's PEP tried to make it less of a choice.

00:28:03.600 --> 00:28:09.520
Say, "Well, it doesn't matter if you use hatch or pip or poetry or whatever, the outcome is the same."

00:28:09.520 --> 00:28:14.720
And for reasons that I haven't learned enough about, I don't know why that didn't work. But

00:28:14.720 --> 00:28:18.320
let's talk about what's out there now. Because there's a couple options at this point.

00:28:19.040 --> 00:28:24.320
Sure. I think the... Yeah. So most Python developers are going to be most familiar with

00:28:24.320 --> 00:28:36.000
pip, right? That's the standard. And pip has requirements files. And they're unique in the

00:28:36.000 --> 00:28:43.040
lock file world because they can be named anything, right? Most other lock files have a defined name.

00:28:43.040 --> 00:28:47.440
We're talking about Rust earlier. They're the gold standard for a lot of this stuff. And

00:28:48.320 --> 00:28:53.120
they're very clear. They have cargo.lock. That's their lock file. You can't name it anything else.

00:28:53.120 --> 00:28:58.720
Its contents are well-defined. It is what it is. But in Python with pip,

00:28:58.720 --> 00:29:04.480
I mean, you could name it whatever you want. You know, dev requirements.txt. You could name it

00:29:04.480 --> 00:29:08.720
cargo.lock, but it can contain Python dependencies in it.

00:29:08.720 --> 00:29:10.320
Surprise. I'm not Rust.

00:29:10.320 --> 00:29:16.640
Basically, you can just put more or less arbitrary commands that are sent to pip

00:29:16.640 --> 00:29:19.760
in any text file, right? Which is more or less what it is. Yeah.

00:29:19.760 --> 00:29:25.920
Yeah. Any command line option you can feed the pip, you can put in a requirements file.

00:29:25.920 --> 00:29:30.320
It's cool because you can import by saying -r some other file.

00:29:30.320 --> 00:29:31.200
Yes. Yes.

00:29:31.200 --> 00:29:32.480
But it's also not...

00:29:32.480 --> 00:29:33.600
Get the hierarchy that way.

00:29:33.600 --> 00:29:34.800
Yeah. Yeah.

00:29:34.800 --> 00:29:42.960
So there are some tools available to turn those loose requirements files,

00:29:42.960 --> 00:29:49.120
the pip requirements files, into strict lock files, right? Where every entry is

00:29:49.120 --> 00:29:54.640
pinned to a specific version. And pip itself can do it with the pip freeze command.

00:29:54.640 --> 00:30:01.360
So that's the one most people know about. But that one's kind of not so great because it only

00:30:01.360 --> 00:30:07.120
freezes the packages for the environment that you ran pip freeze in. And maybe you're trying to

00:30:08.000 --> 00:30:13.360
publish your lock file for users of a different platform or system.

00:30:13.360 --> 00:30:17.520
The other thing that I don't like about it is you want to put just the things you actually

00:30:17.520 --> 00:30:24.560
use into your requirements file. Like I'm using HTTPX and Pydantic. That's it. But what it really

00:30:24.560 --> 00:30:29.040
installs when you run that is the transitive closure of all those things, which is fine.

00:30:29.040 --> 00:30:35.840
But you're not necessarily expressing that with just your requirements.txt, right?

00:30:35.840 --> 00:30:43.200
Right. Yeah. Yeah. Your two packages could balloon to 100 dependencies. And that's not uncommon. It's

00:30:43.200 --> 00:30:49.200
not even that bad. Like in the JavaScript ecosystem, the same handful of top level

00:30:49.200 --> 00:30:53.920
dependencies could have two orders of magnitude explosion where you end up with thousands.

00:30:53.920 --> 00:30:59.520
There's a really... Oh, gosh. I can't find it. You know what? I think it's on... I think I put

00:30:59.520 --> 00:31:02.720
it on the Python bites. But there's a really funny... I want to be able to pull this up for

00:31:02.720 --> 00:31:09.600
people so they can find it. There's a funny, funny thing that somebody did. Well, for some

00:31:09.600 --> 00:31:16.640
definition of funny. They put... Somebody created an npm package called everything.

00:31:16.640 --> 00:31:19.120
Yes. I saw this.

00:31:19.120 --> 00:31:26.320
Everything becomes too much. The npm package chaos of 2024. An npm user named PatrickJS

00:31:26.320 --> 00:31:32.080
launched a troll campaign with a package called everything, which depends on every package in npm.

00:31:32.080 --> 00:31:38.800
Yeah. Yeah. I think it's the npm's the largest package registry out there. So, it's already

00:31:38.800 --> 00:31:46.240
massive. I remember your early episodes, you would recount how many packages were on PyPI.

00:31:46.240 --> 00:31:49.520
I don't even know. Are we past half a million?

00:31:49.520 --> 00:31:53.680
Well, yeah. I remember it was a big deal. It got up to 100,000. And now it's probably,

00:31:53.680 --> 00:31:55.120
what? 400,000? 500,000?

00:31:55.120 --> 00:32:03.600
508,509 by rounding. Yeah. Half a million. Congratulations, world. Amazing.

00:32:03.600 --> 00:32:08.240
I just added two new ones last week. So, I guess I made a huge difference in that number.

00:32:08.240 --> 00:32:10.720
Nice.

00:32:10.720 --> 00:32:14.720
Yeah. So, basically, the PyPI is awesome and it does a bunch of great stuff. And one of the

00:32:14.720 --> 00:32:19.600
things I really like about working with PyPI is I don't need to teach people anything if they want

00:32:19.600 --> 00:32:24.400
to work with my project. I don't need to teach them like, "Oh, I know you love poetry, but I'm

00:32:24.400 --> 00:32:29.120
using a combination of the Hatch build backend with PDM." You're like, "What? I don't even know

00:32:29.120 --> 00:32:36.240
what those are." There's a lot of ways in which you work that are brought in with a lot of these

00:32:36.240 --> 00:32:39.600
tools here. So, PyPI is kind of like, it just kind of works, right?

00:32:39.600 --> 00:32:40.080
Yes.

00:32:40.080 --> 00:32:46.320
But having this transitive closure managed is not part of what it does, but it's super important

00:32:46.320 --> 00:32:51.120
because if I need to upgrade something, I can't just change my version number in my requirements

00:32:51.120 --> 00:32:55.680
because that doesn't affect its dependency possibly, right? It depends on what it said.

00:32:55.680 --> 00:32:59.360
So, I'm a huge fan of PyPI tools. This is actually what I do most of the time.

00:32:59.360 --> 00:33:07.120
Yes. PyPI tools is another one. It's great. I think it has this PyPI compile

00:33:07.120 --> 00:33:15.200
command that will take as an input, I think, just about any Python manifest type that's out there.

00:33:15.200 --> 00:33:23.840
So, you can do setup.py, requirements.txt. I'm forgetting the other ones.

00:33:23.840 --> 00:33:27.680
The pipenv.loc maybe.

00:33:27.680 --> 00:33:36.080
Setup.cfg, pyproject.toml. It just recognizes all the different ways people could express

00:33:36.080 --> 00:33:41.920
their loose requirements, the manifest files. Yeah. So, yeah.

00:33:41.920 --> 00:33:47.440
Yeah. I really like it. And you can say, "PyP compile upgrade," and it'll look at all the

00:33:47.440 --> 00:33:51.760
dependencies and upgrade them all as high as they can go. But what's nice about that is,

00:33:51.760 --> 00:33:56.480
you'll be working for a while, then you choose, "Well, let me just do a refresh on the dependencies

00:33:56.480 --> 00:34:00.720
right now and repin them and see how that works," and then just carry on with your business for a

00:34:00.720 --> 00:34:06.160
while, right? And it'll manage that transitive closure as well with actually a really nice

00:34:06.160 --> 00:34:10.640
lock file where it describes, "These are all the things in the lock file." And the reason that,

00:34:10.640 --> 00:34:14.480
for example, in your blog post, you say, "They're certified, this version," and it's there because

00:34:14.480 --> 00:34:19.360
you asked for it and because request needs it. If you're like, "Why is this in my virtual

00:34:19.360 --> 00:34:23.280
environment? Why do I have this weird thing that I don't know?" It'll tell you, "Here's why it's

00:34:23.280 --> 00:34:30.720
there." Yeah. Yeah. One of the downsides, though, I think pip tools has this issue. I know pip does,

00:34:30.720 --> 00:34:39.120
is that in determining that transitive dependency resolution, it is very possible,

00:34:39.120 --> 00:34:43.280
in fact, it usually happens that you have arbitrary code execution on your system, right?

00:34:43.280 --> 00:34:48.800
If you start with the two top-level dependencies, like you mentioned, and it lists dependencies,

00:34:48.800 --> 00:34:54.000
well, then it'll pull those in and it acquires the metadata from the wheel if that exists.

00:34:54.000 --> 00:34:58.560
But if it doesn't, it'll build the package just to get the metadata file,

00:34:58.560 --> 00:35:01.840
just to figure out which dependencies that needs. And so you end up-

00:35:01.840 --> 00:35:05.520
Are you saying I should set up a Docker container to execute this?

00:35:06.560 --> 00:35:07.840
Yeah. That's kind of what's happening.

00:35:07.840 --> 00:35:08.640
Maybe I should. Yeah.

00:35:08.640 --> 00:35:18.480
Yeah. Running in a sandbox is another option, right? That's what my company, Phylum, that's one

00:35:18.480 --> 00:35:26.400
of the solutions we offer. We have extensions for our CLI where you can wrap pip by just calling

00:35:26.400 --> 00:35:31.120
Phylum pip, and then everything runs in a sandbox. So that's another solution.

00:35:31.760 --> 00:35:37.440
Yeah. Yeah. Yeah. Because I mean, pip is a funny one because they even have a command line option

00:35:37.440 --> 00:35:42.640
called dry run, tac-tac dry run, which you would think, "Oh, nothing's going to happen on my

00:35:42.640 --> 00:35:43.600
system." It's just-

00:35:43.600 --> 00:35:45.760
Separate running code from strangers on the internet.

00:35:45.760 --> 00:35:52.480
But it does. Yes. Dry run, even using dry run for pip install and pip download commands

00:35:52.480 --> 00:35:57.920
will or has the possibility of downloading and running arbitrary code from strangers on the

00:35:57.920 --> 00:35:59.280
internet. Yeah.

00:35:59.280 --> 00:36:05.680
If we had, oh, like wheels came along far after pip, right? And we've got the source distributions

00:36:05.680 --> 00:36:11.120
and setup.py and all that kind of stuff. And so if wheels existed from day one, it very well

00:36:11.120 --> 00:36:16.480
may be the case that this is not a problem, right? But what is pip supposed to do? It has to

00:36:16.480 --> 00:36:18.960
evaluate this dynamic thing to figure out what it wants in a sense.

00:36:18.960 --> 00:36:25.920
Yes. Yes. Yeah. Yeah. Wheels are great because they have a metadata file in there that clearly

00:36:26.560 --> 00:36:32.160
lays out what the dependencies are. And there's no arbitrary code running when you install a wheel.

00:36:32.160 --> 00:36:39.440
It's just extracting and copying. A wheel is just a zip file. You extract that zip file and then

00:36:39.440 --> 00:36:46.960
copy the contents to various locations. But yes, as you said, because we've had source distributions,

00:36:46.960 --> 00:36:53.200
tarballs, and then even eggs before that, and probably never going to fully get rid of those,

00:36:54.480 --> 00:37:00.240
it just takes one. One dependency anywhere in your chain that is only distributed as a source

00:37:00.240 --> 00:37:07.360
distribution before now you're downloading and building a package just to get metadata to

00:37:07.360 --> 00:37:07.760
continue.

00:37:07.760 --> 00:37:11.680
And maybe you didn't actually choose that, right? It's the dependency of a dependency

00:37:11.680 --> 00:37:12.800
of a dependency.

00:37:12.800 --> 00:37:22.320
Absolutely. Yeah. Yeah. That's, yeah. Yeah. People often respond to some of the findings our company

00:37:22.320 --> 00:37:27.440
has where we'll post these malicious packages with all sorts of crazy names. And people will

00:37:27.440 --> 00:37:35.440
respond to say, why would I install that? Why would I ever install this random package that

00:37:35.440 --> 00:37:43.600
no one's heard of? It's like, well, you wouldn't. But it could be included in the transit dependencies.

00:37:43.600 --> 00:37:50.240
Right? If it gets added to a slightly more legitimate package or worked up the chain that

00:37:50.240 --> 00:37:55.040
way, then yes, eventually you'll be running it unknowingly.

00:37:55.040 --> 00:37:58.960
Yeah. I think there's two important things we should talk about this before we move on,

00:37:58.960 --> 00:38:03.520
because there are some interesting ways in which you might unknowingly, you might even try to do

00:38:03.520 --> 00:38:09.760
the right thing and you might actually shoot yourself in the foot by doing so. So number one,

00:38:09.760 --> 00:38:15.280
these super strict lock files are awesome when you're building an application. I want to ship

00:38:15.280 --> 00:38:19.840
talk, Python training out. It's got a strict API as it runs on this version. It uses that

00:38:19.840 --> 00:38:25.120
version of Pydantic, that version of Beanie and whatever. I want that to be fixed, fixed,

00:38:25.120 --> 00:38:30.640
zero flexibility until I decide to maybe a pip compile update or whatever I want a new one.

00:38:30.640 --> 00:38:36.560
However, if I was building a library that someone else was using, I would do them many headaches

00:38:36.560 --> 00:38:44.000
and a disservice to say, I depend on Pydantic 2.7.0. You're like, well, my other library needs

00:38:44.000 --> 00:38:51.200
Pydantic 8.8 and I can't use it and your library together. So you need the, it's a different story

00:38:51.200 --> 00:38:55.440
when you're building a library that others are going to consume than it is when you're building

00:38:55.440 --> 00:39:01.120
an application. And there was some disagreement, I guess, about the recommendation of pipenv for a

00:39:01.120 --> 00:39:06.160
while. And it's because I believe the pipenv is really focused on the application side. And it,

00:39:06.160 --> 00:39:10.080
I don't think it was made super clear that maybe it doesn't make as much sense for libraries.

00:39:10.080 --> 00:39:15.600
Right. So you want to speak to that a little? Yeah. Yeah. I'm an advocate for lock files for

00:39:15.600 --> 00:39:21.280
everyone. Right. Applications for sure, but also libraries and their developers. Right. Cause

00:39:21.280 --> 00:39:31.360
if when you distribute a library, sure. Loose dependencies is probably the way to go there.

00:39:31.360 --> 00:39:35.520
But library developers, people who want to contribute to your projects,

00:39:36.240 --> 00:39:42.560
the developers themselves, maybe you work on a team, having a lock file alongside

00:39:42.560 --> 00:39:47.840
your library is still going to be useful. Right. Like, yeah. Cause that way you can say everyone,

00:39:47.840 --> 00:39:52.320
if somebody makes a change or they report a bug or whatever, they're not bringing in a change from a

00:39:52.320 --> 00:39:58.400
different version of a dependency or like maybe something changed. Right. Yes. Yes. Yeah. And

00:39:58.400 --> 00:40:06.160
then, and it, plus it still allows you to start from a known good spot. And then maybe, maybe if

00:40:06.160 --> 00:40:13.280
you know you want to get the latest, then you can do it in a controlled environment,

00:40:13.280 --> 00:40:21.040
like a sandbox or maybe a CI in a throwaway runner that has no access to any secrets or

00:40:22.880 --> 00:40:30.480
sensitive. I hadn't really thought about having a specific requirements lock file type of thing

00:40:30.480 --> 00:40:34.800
for the libraries that I've been working on for the developers. Right. For people who want to

00:40:34.800 --> 00:40:40.080
contribute because it's just been like a loose requirement so that people that built against it

00:40:40.080 --> 00:40:43.520
aren't pinned into some very specific thing. But yeah, that makes a lot of sense. I think.

00:40:43.520 --> 00:40:48.400
Yeah. There's a, there's a link in that blog posts. It's kind of dated now, but it's from

00:40:48.400 --> 00:40:54.640
the folks who built yarn, you know, JavaScript ecosystem, but they had, they say it a lot more

00:40:54.640 --> 00:41:00.880
eloquently than I can. Yeah. That's the one. Lock files should be committed. On all projects. Yeah.

00:41:00.880 --> 00:41:05.600
It's, I mean, it's a bit old now, but they, they go down the lists and spell it out a lot more

00:41:05.600 --> 00:41:12.640
clearly than me about why libraries even can benefit from, from publishing a lock file.

00:41:12.640 --> 00:41:16.480
Yeah. People can check that out. That's cool. Yeah. And Java, that's the JavaScript package

00:41:16.480 --> 00:41:19.920
manager. So in JavaScript years, like a hundred years or something, it's been a couple of years.

00:41:19.920 --> 00:41:20.480
That's right.

00:41:20.480 --> 00:41:25.360
You got dog years, you got JavaScript years, JavaScript years just tick by like second,

00:41:25.360 --> 00:41:30.880
the second hand. Yeah. Yeah. All right. Cool. So I see we're making great progress here. Our

00:41:30.880 --> 00:41:35.760
list of things to talk about here. I've gone through three and I like 15 left. We'll have

00:41:35.760 --> 00:41:44.400
plenty of time. So yeah, let's see. So another one, another PEP I think we're talking about

00:41:44.400 --> 00:41:50.960
here is 517, a build system, independent format for source trees. I have no idea what this is.

00:41:50.960 --> 00:41:51.600
What is this?

00:41:51.600 --> 00:41:58.080
Yeah. Pep 517 and 518 kind of go together. This is, this was like the transition away from

00:41:58.080 --> 00:42:04.880
setup.py towards pyproject.toml. 518 is the one that specifies pyproject.toml

00:42:04.880 --> 00:42:12.880
kind of things that go in it. And then 517 is all about build systems and build backends.

00:42:13.600 --> 00:42:23.040
So like in your pyproject.toml and your build system key, you'll often see things like poetry

00:42:23.040 --> 00:42:31.440
core or flit or hatchling or these kinds of things. And so it's 517 is specifying what it means to be

00:42:31.440 --> 00:42:38.160
one of those build backends. It's really just defining two mandatory hooks. What does it mean

00:42:38.160 --> 00:42:44.080
to build wheel and build sdist? There's three optional hooks as well. And I think there's even

00:42:44.080 --> 00:42:49.920
another PEP that followed on from this that talks about building editable packages or-

00:42:49.920 --> 00:42:54.400
Right. The dash E equivalence.

00:42:54.400 --> 00:42:57.760
Yeah. Yeah, exactly. But really it just boils down to

00:42:57.760 --> 00:43:02.960
defining a way to build a wheel and build a source distribution.

00:43:02.960 --> 00:43:08.720
Yeah. And this is part of what opened up all the different choices we now have for package

00:43:08.720 --> 00:43:14.000
management and things like that, right? Because now there's a common way they can all work together.

00:43:14.000 --> 00:43:15.120
A little bit like WSGI.

00:43:15.120 --> 00:43:16.080
Yes. Yeah.

00:43:16.080 --> 00:43:19.760
Yeah. I've been using hatchling for my build backend recently and it's been working real

00:43:19.760 --> 00:43:20.480
nicely.

00:43:20.480 --> 00:43:27.600
Okay. Yeah. I was just looking at hatchling the other day and they've got- Yeah. Yeah.

00:43:27.840 --> 00:43:38.480
They're one of the build backends that offers build hooks, which- So prior to pyproject.toml

00:43:38.480 --> 00:43:45.840
and wheels and bdus_wheels and you go back to the source distributions and your setup.py files,

00:43:45.840 --> 00:43:51.200
where it's just Python code. You can be doing anything in your setup.py file,

00:43:52.160 --> 00:43:58.320
which runs when you install the package. Well, now we're starting to see methods to do the same

00:43:58.320 --> 00:44:02.480
thing in these more modern packaging or build backend. So like hatch has their

00:44:02.480 --> 00:44:11.920
build hooks, build system hooks where you can point it to, I think, yeah, just Python code and

00:44:11.920 --> 00:44:14.800
have it run as part of the build.

00:44:14.800 --> 00:44:19.120
Yeah. At least it only runs at build time, not install time. Right?

00:44:21.200 --> 00:44:25.920
I'm looking at the documentation now. Yeah. This is still new to me, but there might be

00:44:25.920 --> 00:44:28.880
hooks for install as well.

00:44:28.880 --> 00:44:34.480
Okay. While you're thinking about it, one of the things, I got a couple of questions I want to

00:44:34.480 --> 00:44:41.520
highlight from the audience here, but also one of the things that I think maybe was considered,

00:44:41.520 --> 00:44:47.600
I have no awareness of this, but if it wasn't, it would be excellent is what if the people at pip

00:44:47.600 --> 00:44:54.080
just pre-computed all that metadata from, at least for the common platforms that you would get,

00:44:54.080 --> 00:44:59.120
that pip needs to download, run setup.py and then throw it away just to get that data.

00:44:59.120 --> 00:45:05.280
Like for Mac, Windows, and Linux, if it would just go, okay, we're just going to, as you upload it,

00:45:05.280 --> 00:45:09.920
it would just kick off a job that does that on those three platforms and puts it in a JSON blob.

00:45:09.920 --> 00:45:11.520
It seems like that would be worthwhile.

00:45:12.800 --> 00:45:18.320
I'm fairly certain there's discussions already around that type of a solution and maybe even a

00:45:18.320 --> 00:45:24.800
 PEP for proposal for it, but yeah, getting away from having to build a package just to get metadata.

00:45:24.800 --> 00:45:31.760
You got packages that are downloaded billions of times with a B, it's insane.

00:45:31.760 --> 00:45:36.720
And if somebody could do that three times instead of a billion times,

00:45:36.720 --> 00:45:40.320
it would make it work faster and it would also make it safe. Right? I think it'd be great.

00:45:40.960 --> 00:45:47.600
All right. A couple of questions here. This one. So Tony on the audience says,

00:45:47.600 --> 00:45:53.280
pip compiles great for finding your transitive dependencies. One interesting thing that they've

00:45:53.280 --> 00:45:58.320
done is package up code with pants build, which supports locks files just to look through what

00:45:58.320 --> 00:46:01.040
code gets packaged up. Is this anything you've explored?

00:46:01.040 --> 00:46:05.840
I've heard of pants. I haven't looked into it myself yet.

00:46:06.880 --> 00:46:11.600
Okay. Yeah. So just use it like, okay, you're going to have to build this thing and give me

00:46:11.600 --> 00:46:15.760
a little manifest and whatnot. And then we can just look at that. That's cool. And then Tamir

00:46:15.760 --> 00:46:20.800
says, do you have a solution for taking already locked dependencies with you when you start a new

00:46:20.800 --> 00:46:26.320
app? I'm guessing, you know, maybe, yeah, I don't know. I guess maybe you've already got a project

00:46:26.320 --> 00:46:29.280
you're working on and you want to say like, I want this project to use that. Probably you could

00:46:29.280 --> 00:46:35.200
just copy the lock file. Right? Yeah. Yeah. If you, I mean, if you really, I mean, really,

00:46:35.200 --> 00:46:39.680
you're going to, if you start a new project or new application, you're going to, you're going

00:46:39.680 --> 00:46:44.800
to have new manifest file, you know, pyproject.toml, maybe you have the same dependencies,

00:46:44.800 --> 00:46:50.400
the top level dependencies or not, but the, the fully resolved set of dependencies that makes up

00:46:50.400 --> 00:46:56.400
your lock file that, that can very easily be different. So I'm not exactly sure how you just

00:46:56.400 --> 00:47:02.000
poured over one to another. One more bit from Tony. And this is something that I now remember

00:47:02.000 --> 00:47:07.760
from pants is this, if it just looks through your code and if you use the import statement,

00:47:07.760 --> 00:47:12.080
regardless of whether you've put it in your requirements files, it'll figure out what

00:47:12.080 --> 00:47:16.000
your requirements files should have been. If you were a bad developer, basically,

00:47:16.000 --> 00:47:22.640
that's cool. Just to see what it uses. Yeah. Nice. All right. On to the next thing,

00:47:22.640 --> 00:47:28.640
specify in PEP 5 1 8, specifying minimum build system requirements for Python projects.

00:47:28.640 --> 00:47:33.760
Yeah. This is pyproject.toml. This is the, this is the, the PEP for that.

00:47:33.760 --> 00:47:38.080
There's not much to it other than to say that they've settled on that name,

00:47:38.080 --> 00:47:42.560
rejected a bunch of other possibilities. And then they've got the, you know, the,

00:47:42.560 --> 00:47:46.720
the few entries that are required, like for your, your finding your build system.

00:47:46.720 --> 00:47:54.000
Yeah. You don't have to have a pyproject.toml for Python, but if you're building a Python library

00:47:54.000 --> 00:47:59.040
and you don't want to use setup.py, then you're much better off having a pyproject.toml, right?

00:47:59.040 --> 00:48:03.920
Yes. Yeah. Yeah. It's more in the library side that it, I mean, it's not that you can't use it

00:48:03.920 --> 00:48:09.520
on an application, but it's more required on the library side. Yeah. That's the thing. All right.

00:48:09.520 --> 00:48:14.560
So let's talk about some of the ways in which your packages might go wrong. We've already

00:48:14.560 --> 00:48:20.640
talked about typosquatting and we also talked about everything that's different. Yeah. But yeah,

00:48:20.640 --> 00:48:25.680
new typosquatting is, it is tricky. I think it's pretty well understood at this, this point,

00:48:25.680 --> 00:48:29.600
but maybe just tell people real quick to cover that base, you know?

00:48:29.600 --> 00:48:35.920
Sure. Type of typosquatting is, is, you know, publishing a package with a name that's similar,

00:48:35.920 --> 00:48:43.120
but not the same as, as a, as a existing known good package. Right. So like, instead of requests,

00:48:43.120 --> 00:48:49.680
maybe you, you get request without the S or, you know, one that gets me, cause I,

00:48:49.680 --> 00:48:54.880
cause I make the type of all the time was, is the cryptography package. Like, like if I, you know,

00:48:54.880 --> 00:48:59.440
if I put you on the spot, would you know how to spell cryptography? I always get the first couple

00:48:59.440 --> 00:49:04.960
of letters, you know, jumbled up a bit and, and there have been malicious packages published and

00:49:04.960 --> 00:49:13.280
then taken down with, with you know, spelled C-R-P-Y instead of C-R-Y-P, cryptography. Right.

00:49:13.280 --> 00:49:21.040
Yeah. But, but the idea is that, you know you, you can overlook a package cause it looks like a,

00:49:21.040 --> 00:49:25.040
it looks like a good one. It's not necessarily that you're going to, you're going to install

00:49:25.040 --> 00:49:30.160
it because you type it wrong. Although that is, that is, you know, one technique, right?

00:49:30.160 --> 00:49:37.120
The drive by installs where someone just bat fingers the package name. But really having a

00:49:38.400 --> 00:49:44.640
typo squatted package is going to allow these threat actors to be a little more stealthy

00:49:44.640 --> 00:49:50.480
in their inclusion of that package in, in legitimate code reviews and commits and

00:49:50.480 --> 00:49:55.200
dependencies of dependencies. Right. And so the other, the other thing that goes with

00:49:55.200 --> 00:50:00.720
typo squatting, I don't know if I had a link for you there yet is, is star jacking. So

00:50:00.720 --> 00:50:06.400
a lot of times if you're going to typo squat on a known good package, okay, there it is.

00:50:07.600 --> 00:50:13.200
You know, these, these, these threat actors, they just, they just straight up copy the known

00:50:13.200 --> 00:50:19.040
good project, right. It's just clone the repository and then change the package name.

00:50:19.040 --> 00:50:27.680
And, and then when they, when they post the package to PyPI, for instance, the metadata

00:50:27.680 --> 00:50:34.800
that goes with the package still exists, right. So on PyPI for a given package, you can see on

00:50:34.800 --> 00:50:42.480
the left-hand side, it shows like some, some statistics. If, if the URL was given to like a

00:50:42.480 --> 00:50:48.640
GitHub hosted project, for instance, it'll go in there and tell you how many stars.

00:50:48.640 --> 00:50:54.320
Right, right, right. That's actually a signal that it seems like it should be good, right. It'll have.

00:50:54.320 --> 00:51:01.280
Yeah. That's what star jacking is doing is just copying the metadata of a known good package.

00:51:02.320 --> 00:51:05.520
So that on first look, yeah, there you go. You can see.

00:51:05.520 --> 00:51:11.040
I did pull that pytest and it says statistics, GitHub statistics, 11,000 stars,

00:51:11.040 --> 00:51:13.760
2000 forks. Okay. This is legit. Let's install it.

00:51:13.760 --> 00:51:20.400
Right. So I could go clone pytest repository right now, change the name to pytest spelled P-I-T-E-S-T.

00:51:20.400 --> 00:51:25.120
And then, and then push the math version of testing. Yeah. And you're going to get these

00:51:25.120 --> 00:51:29.680
same statistics and you're going to get the same maintainers that you see if you scroll down a

00:51:29.680 --> 00:51:37.680
little bit in the, the metadata. Yeah. So you get the maintainers list, all of that metadata that

00:51:37.680 --> 00:51:45.120
you, you, you enter in your pyproject.toml or setup.py file gets read here on PyPI and just,

00:51:45.120 --> 00:51:48.640
just publish. So you can, you can fake people out, right?

00:51:48.640 --> 00:51:52.800
Yeah. That's actually really, okay. Well, there's a new terrifying thing that I hadn't thought about.

00:51:52.800 --> 00:51:58.160
Yeah. Yeah. So, so star jacking and typosquatting where you just take a known good package, clone

00:51:58.160 --> 00:52:04.240
it, and then maybe you, you make a change to you know, existing function, you know, the function

00:52:04.240 --> 00:52:09.200
does what it's supposed to do, but it also does some other stuff like ship off secrets from your,

00:52:09.200 --> 00:52:16.720
your CI server or you know, It could lay dormant and wait for some sort of production environment

00:52:16.720 --> 00:52:21.360
and grab some SSH keys or something terrible. Yeah. Yeah. Yeah. That's, that's, that's the

00:52:21.360 --> 00:52:26.080
other, the other dependency confusion. Okay. That's the next one you've got up.

00:52:26.080 --> 00:52:30.800
Yeah. This is the one we kind of talked, it's similar to what we talked about before with,

00:52:30.800 --> 00:52:34.800
I can't remember, but I said, there's, there's, we're going to come back to this. So here,

00:52:34.800 --> 00:52:40.160
here it is again, this is a dependency confusion where if you get the wrong version or the wrong

00:52:40.160 --> 00:52:46.640
name, it could actually, you try to be safe by having a white listed list or say, well, it's,

00:52:46.640 --> 00:52:52.080
it's, so this is one where it's the same, same package name, different source of where you

00:52:52.080 --> 00:52:59.920
acquire that package. So this is you'll, these attacks are mostly like companies, enterprises,

00:52:59.920 --> 00:53:07.280
yeah. Yeah. So it's an artifactory and we, we only put our stuff there and we're,

00:53:07.280 --> 00:53:12.160
we're going to call it like, you know, international company underscore data access.

00:53:12.160 --> 00:53:17.760
That's right. And, and it's, and it's, and it's tricky because if you don't know, like if you

00:53:17.760 --> 00:53:23.440
don't have your build system set up in a way, and then your CI server set up in a way to install

00:53:23.440 --> 00:53:28.480
your dependencies in the proper order, like excluding public registries first, and only

00:53:28.480 --> 00:53:34.080
looking for packages in your private registry, then it's very easy, especially with pip, which

00:53:34.080 --> 00:53:40.480
defaults to looking on PyPI, the public registry first, and then only falling back to your, your

00:53:40.480 --> 00:53:49.680
extra index URL specifications. Secondly, that if you, if someone had the knowledge or just guessed

00:53:49.680 --> 00:53:54.080
at the package name that you had published on your internal registry, and then they made their

00:53:54.080 --> 00:53:58.480
own package, the same name, but put it on PyPI, that's the one that's going to get installed.

00:53:58.480 --> 00:54:06.320
And there was like a whole series of, you know, bug bounties that were claimed over this back a

00:54:06.320 --> 00:54:11.120
few years ago, because people just went around, you know, guessing at internal package names,

00:54:11.120 --> 00:54:14.480
or maybe they used to work there or new people. Yeah. Yeah. Yeah.

00:54:14.480 --> 00:54:19.760
Just to share your requirements at TXT with me. Right. Right. Right. Right.

00:54:19.760 --> 00:54:28.400
You know, it's, it's kind of, it's extra sneaky because it only affects people. It only affects

00:54:28.400 --> 00:54:33.600
people who are going out of their way to be more secure, right? They're going out of their way to

00:54:33.600 --> 00:54:38.320
say, we're only going to, we're going to actually set up a whole server and we're going to whitelist

00:54:38.320 --> 00:54:43.280
a bunch of stuff. You can only ask for the names of the things on this server and, ah, you know.

00:54:43.280 --> 00:54:50.240
Yes. And that, that might still work if you limit it to your internal registry only, or a mirror,

00:54:50.240 --> 00:54:53.760
perhaps, of, of the, the public registries.

00:54:53.760 --> 00:54:59.200
What do you think about that? It's pretty easy to create your own internal copy,

00:54:59.200 --> 00:55:02.720
download a bunch of extra ones and mirror them locally and say like,

00:55:02.720 --> 00:55:06.000
these are the ones that are pre-approved at our company. Nothing else.

00:55:06.000 --> 00:55:12.160
Yeah. Yeah. I, I, I've worked in a environment where that's exactly what we did. And,

00:55:12.160 --> 00:55:17.040
I think there is merit to that. You just have to know that anything you're mirroring

00:55:17.040 --> 00:55:21.360
to the trusted internal network is in fact secure. You know?

00:55:21.360 --> 00:55:27.520
Yeah. Yeah, for sure. I think, you know, it doesn't really make sense except for a few,

00:55:27.520 --> 00:55:31.040
very rare cases to say you cannot use external dependencies.

00:55:31.040 --> 00:55:31.440
Right. Right.

00:55:32.080 --> 00:55:36.640
You're just saying what we want is to not build software, but while the rest of the world does,

00:55:36.640 --> 00:55:42.080
you know, because that's part of the magic. We just saw there's over half a million libraries

00:55:42.080 --> 00:55:47.840
you can choose from. When you say we have zero of those, you're really, really constraining

00:55:47.840 --> 00:55:51.120
the type of software and the velocity at which you can build.

00:55:51.120 --> 00:55:58.800
Yeah. Yeah. It reminds me of, there's that line, you know, like, why, why do you rob banks?

00:55:58.800 --> 00:56:00.080
Because they have the money.

00:56:00.080 --> 00:56:03.120
Because that's where the money is. Right. It's like, well, why do attackers,

00:56:03.120 --> 00:56:08.560
why are attackers going after open source software now? Like, well, that's, that's where

00:56:08.560 --> 00:56:13.280
it's easiest to get arbitrary code to run. That's where developers are. That's what.

00:56:13.280 --> 00:56:17.520
That's what to be fair though. It's not only, it's not only right. There's SolarWinds,

00:56:17.520 --> 00:56:22.400
which really had almost nothing to do with open source, but it had to do with CI/CD systems and

00:56:22.400 --> 00:56:28.640
other sneakiness. Right. Yeah. Yeah. And got into places that, you know, instead of getting into

00:56:28.640 --> 00:56:32.560
libraries, you get into the build system and you just give it a little extra, a little extra include

00:56:32.560 --> 00:56:39.360
tag there, bringing that deal out. Like you said, right. So dependency and confusion is sneaky

00:56:39.360 --> 00:56:44.480
because you're asking for a local version off a local server. It doesn't exist on PyPI, but if it

00:56:44.480 --> 00:56:49.760
could be made to exist on PyPI, all of a sudden that gets installed. That's potentially, that's

00:56:49.760 --> 00:56:50.080
not good.

00:56:50.080 --> 00:56:54.000
Potentially. Yeah. Yeah. It's, it's, that's, that's how it works in all the, in all the default

00:56:54.000 --> 00:56:59.840
cases. And it's, it's pretty tricky actually to, to exclude, to do it in the correct order and

00:56:59.840 --> 00:57:01.680
exclude those public registries.

00:57:01.680 --> 00:57:08.080
Yeah. What's what I do to help this is I just, I just run the UUID command to get one of those

00:57:08.080 --> 00:57:13.920
16 digit arbitrary X things. And I just name all my libraries that, and so it's like, oh, you have

00:57:13.920 --> 00:57:21.200
the F3DC. That's the API one. That's right. That's that, right. No one is going to do this.

00:57:21.200 --> 00:57:26.320
It's such a safe space. I tell you. All right. Onto the next one.

00:57:26.320 --> 00:57:27.040
That, that would work.

00:57:27.040 --> 00:57:32.720
Expired author domains. This is super sneaky.

00:57:32.720 --> 00:57:41.600
Yeah. Yeah. So this is one, you know, it, it might be less of a factor now. I think,

00:57:41.600 --> 00:57:47.040
I think it was just earlier this month that PyPI enforced two factor authentication for

00:57:47.040 --> 00:57:57.280
all their users. But a lot of sites and, you know, even PyPI, I think before this month,

00:57:57.280 --> 00:58:03.360
have, you know, password reset features where if, if you lose access to your account or you

00:58:03.360 --> 00:58:08.560
forget your password, just, you know, send me an email, reset your password. But it's,

00:58:08.560 --> 00:58:14.400
it's, it's very possible that people, you know, years ago submitted a package. They,

00:58:14.400 --> 00:58:20.240
they don't maintain it anymore. They submitted it under an old email account that has expired.

00:58:20.240 --> 00:58:26.720
Right. Maybe they had some domain. Yeah. Special doesn't work that well for Gmail or Outlook.

00:58:26.720 --> 00:58:33.600
You had a custom domain and as would be awesome. Have your own, you know,

00:58:33.600 --> 00:58:39.520
Michael@talkpython.fm that kind of thing. Yeah. Yeah. Say you, you win the lottery and,

00:58:39.520 --> 00:58:44.240
and you know, decide to put your job. Yeah. Then you let your domain expire and

00:58:44.240 --> 00:58:51.280
well, maybe there's still a linkage for the talk Python domain to PyPI. And then I go and

00:58:51.280 --> 00:58:58.640
buy that domain and, you know, request password server. Yeah. Yeah. And then now I, now I can

00:58:58.640 --> 00:59:06.000
publish new versions of the packages there. Yeah. Yeah. It's not good. Yeah. Yeah. So I don't really

00:59:06.000 --> 00:59:10.640
know what to do about that one, but there's an amazing, amazing joke that I found on Mastodon.

00:59:10.640 --> 00:59:19.040
Somebody posted, sit here. It's a two big red buttons. Think Ren and Stimpy or whatever. And

00:59:19.040 --> 00:59:23.600
one of the red buttons says, admit to yourself that your dream is dead. The other one says,

00:59:23.600 --> 00:59:30.880
pay $12 for domain renewal. Right. I mean, it's funny, but there's plenty of people who will get

00:59:30.880 --> 00:59:34.800
a domain and I totally go. And then it's like, you know what? I haven't done anything with that

00:59:34.800 --> 00:59:38.960
for like five years. I'm not paying another 12 bucks, but if they had set up an account under

00:59:38.960 --> 00:59:44.240
that, right, this is what you're talking about. Yeah. Yeah, exactly. Yep. That's why you got to

00:59:44.240 --> 00:59:51.120
buy your domains for that a hundred year renewal period. Exactly. Take out that loan. You get your

00:59:51.120 --> 00:59:57.360
domain. All right. We're getting short on time here. I want to, let me, let's just go through.

00:59:57.360 --> 01:00:02.240
I'll just list off a few real quick. Maybe we do lighten round. Okay. Okay. Unverifiable dependency.

01:00:02.240 --> 01:00:11.280
Okay. These are for specifying dependencies that are not necessarily published to PyPI, right? So

01:00:11.280 --> 01:00:19.920
that maybe you're pointing to a GitHub repository. You know, pip calls these VCS project URLs. You

01:00:19.920 --> 01:00:24.960
know, if you, if you look in there, their help output. Yeah. It's like pip installed Git plus

01:00:24.960 --> 01:00:30.960
HTTP to a thing that has a project. And that, and that thing, it can point to a repository.

01:00:30.960 --> 01:00:37.760
Maybe it points to a tag. Maybe it points to a branch. None of that is stable, right? Like you,

01:00:37.760 --> 01:00:43.920
the tag could change out from under you or the code that's related to that tag could change

01:00:43.920 --> 01:00:48.720
out from under you. The code at the branch you're pointing to could change while the name remains

01:00:48.720 --> 01:00:52.640
the same. So, you know, those are, those are, those are risky for that reason, right? If you're

01:00:52.640 --> 01:00:57.440
not pinning to a very specific version or a very specific hash, right. If you're going to point to

01:00:57.440 --> 01:01:02.960
a repository or a Git URL. Yeah. Make sure it's true. I've gotten to feel a lot of times like

01:01:02.960 --> 01:01:07.600
the hash is maybe a little bit redundant given the immutability of PyPI. But if you're pointing

01:01:07.600 --> 01:01:12.400
at something like this, then maybe all of a sudden you really do want that. For sure. Yeah. Okay.

01:01:12.400 --> 01:01:21.840
Repo jacking. Yeah. This is similar to the expired author domain, right? So if someone was,

01:01:21.840 --> 01:01:27.280
you know, pointing to one of those Git dependencies, a VCS project URL as pip calls it,

01:01:27.280 --> 01:01:33.920
and you know, that account went dormant or expired, relinquished, whatever,

01:01:33.920 --> 01:01:40.560
and someone else took it over, then yeah, they can now, they can now dictate what's there. Yeah.

01:01:40.560 --> 01:01:46.800
Yeah, exactly. People are requiring. All right. And then maybe last bit, get a chance to talk a

01:01:46.800 --> 01:01:53.360
bit about your Phylum CI project. I do want to point out really quick though, that Phylum was

01:01:53.360 --> 01:01:58.880
a sponsor of the show a while ago, but this is not a sponsored episode. This is just, you and I had

01:01:58.880 --> 01:02:03.920
been talking prior to that actually, and decided to like put the show together. So just to be clear,

01:02:03.920 --> 01:02:09.280
but let's talk about this, what this project you guys got anyway. Yeah. Yeah. So you can pip install

01:02:09.280 --> 01:02:16.400
Phylum right now, or like I prefer PipX, PipX install Phylum. Yeah. I love PipX. It's awesome.

01:02:16.640 --> 01:02:19.600
Yeah, me too. Yeah. I think I heard about it from you actually.

01:02:19.600 --> 01:02:27.360
So the circle goes. Yeah. Yes. Yes. So this package, it does two main things. One is it can,

01:02:27.360 --> 01:02:34.720
it'll expose us to entry points. One of them is called Phylum init, and that'll get you the Phylum

01:02:34.720 --> 01:02:44.400
command line interface written in Rust, but installed with Python. It'll get you the Phylum

01:02:44.400 --> 01:02:50.320
CLI locally. And then the other one is, it's called Phylum CI. That's just a catch all entry

01:02:50.320 --> 01:02:55.520
point. The thing that gets exposed through our Docker container to handle almost all of our

01:02:55.520 --> 01:03:03.520
integrations. So if you want to monitor your PRs on GitHub, for instance, we've got an integration

01:03:03.520 --> 01:03:08.800
for that. So the idea is basically that I could set this up in GitHub, a PR comes in, I could set

01:03:08.800 --> 01:03:16.240
up an action, Phylum will scan it for known mischievousness and make that part of the PR,

01:03:16.240 --> 01:03:21.680
or maybe even block it out, right? Yeah, exactly. It'll fail your build if you don't pass your

01:03:21.680 --> 01:03:28.960
default policy or established policy on any of your given lock files or manifests. We deal with

01:03:28.960 --> 01:03:33.920
manifests as well. And you mentioned GitHub. So even with GitHub, we went a step further. We have

01:03:33.920 --> 01:03:38.480
an app as well. So you don't even have to modify a workflow. You could just install a GitHub app and

01:03:38.480 --> 01:03:47.520
automatically monitor your repositories. But a lot of the other ecosystems don't have that. So we

01:03:47.520 --> 01:03:54.160
just provide Docker containers. I love the Docker container. So you use Docker run against your code

01:03:54.160 --> 01:04:03.680
or whatever. Yeah. And then there's even a pre-commit hook we expose as well. Nice.

01:04:04.000 --> 01:04:08.240
I genuinely don't know the answer to this question. Does this cost money?

01:04:08.240 --> 01:04:16.720
No. Anyone can sign up for free. There's a community edition where you can have up to

01:04:16.720 --> 01:04:21.120
five projects. Okay, cool. You guys have to eat. There must be some way you charge for something.

01:04:21.120 --> 01:04:26.720
Oh, exactly. Yeah. So there's the paid version, right? Which, you know, unlimited projects,

01:04:26.720 --> 01:04:31.280
you get access to group-based management. You know, there's a few extra features. It's a

01:04:31.280 --> 01:04:36.480
freemium model. A little more of a Teams, enterprise-y angle. Yeah. But for this audience,

01:04:36.480 --> 01:04:44.400
I would love if everyone just went that little extra step of securing their open source software

01:04:44.400 --> 01:04:47.680
and go with the free option. I'm not trying to sell you anything here. Just

01:04:47.680 --> 01:04:56.160
monitor your manifest, your lock files, make sure that you remain secure and not exposing

01:04:56.720 --> 01:05:01.280
your secrets. Because that's what we're finding now, is that developers are the new high-value

01:05:01.280 --> 01:05:06.400
targets. That's what attackers want to go after because we know that developers,

01:05:06.400 --> 01:05:12.640
they have the secrets. They've got the keys. We write the code that then gets run on the

01:05:12.640 --> 01:05:19.760
production server inside the firewalls. Yeah. We have all the access, all the secrets, all the

01:05:19.760 --> 01:05:26.560
keys. So, you know, if you can find a way to get arbitrary code from strangers to run on developer

01:05:26.560 --> 01:05:30.720
systems, you're going to have a much better chance. We have a good time. Yeah. We have a good time.

01:05:30.720 --> 01:05:37.040
I thought I mean having a bad time. Right. Yeah. Doing bad things. Okay. Let's not do that.

01:05:37.040 --> 01:05:40.800
Awesome. Well, excellent work. I think probably we'll kind of just leave it there. We're pretty

01:05:40.800 --> 01:05:46.880
much out of time for the rest of the stuff, but close it out for us, Charlie. People are, maybe

01:05:46.880 --> 01:05:51.200
both have a few new tools to work with, but also techniques, but maybe also a little freaked out.

01:05:51.200 --> 01:05:56.640
What do you tell them? I recommend everyone to restrict their use of dependencies to lock files.

01:05:56.640 --> 01:06:04.560
And then carefully gate, regard the inclusion of new lock files or updates of existing ones,

01:06:04.560 --> 01:06:10.320
or sorry, dependencies in those lock files with careful analysis. Don't allow arbitrary code to

01:06:10.320 --> 01:06:14.480
run anywhere in your development process and give filing a try. You know, we've got the free

01:06:14.480 --> 01:06:20.880
community edition. We will provide that analysis and ensure that you don't have malware running on

01:06:20.880 --> 01:06:25.920
your system through bad dependencies. Awesome. All right. Well, it's been very interesting and

01:06:25.920 --> 01:06:29.920
a lot of new things to think about. So thanks for being here. Thank you, Michael. Yep. See you later.

01:06:29.920 --> 01:06:35.920
This has been another episode of Talk Python to Me. Thank you to our sponsors. Be sure to check

01:06:35.920 --> 01:06:40.560
out what they're offering. It really helps support the show. Take some stress out of your life. Get

01:06:40.560 --> 01:06:45.520
notified immediately about errors and performance issues in your web or mobile applications with

01:06:45.520 --> 01:06:52.400
Sentry. Just visit talkpython.fm/sentry and get started for free. And be sure to use the promo

01:06:52.400 --> 01:06:59.040
code Talk Python, all one word. Mailtrap, an email delivery platform that developers love. Use their

01:06:59.040 --> 01:07:04.560
email sandbox to inspect and debug emails in staging, dev, and QA environments before sending

01:07:04.560 --> 01:07:11.120
them to recipients in production. Try Mailtrap for free at talkpython.fm/mailtrap. Want to level

01:07:11.120 --> 01:07:16.080
up your Python? We have one of the largest catalogs of Python video courses over at Talk Python.

01:07:16.080 --> 01:07:21.520
Our content ranges from true beginners to deeply advanced topics like memory and async. And best

01:07:21.520 --> 01:07:26.480
of all, there's not a subscription in sight. Check it out for yourself at training.talkpython.fm.

01:07:26.480 --> 01:07:31.600
Be sure to subscribe to the show. Open your favorite podcast app and search for Python.

01:07:31.600 --> 01:07:36.880
We should be right at the top. You can also find the iTunes feed at /itunes, the Google Play feed

01:07:36.880 --> 01:07:43.840
at /play, and the Direct RSS feed at /rss on talkpython.fm. We're live streaming most of

01:07:43.840 --> 01:07:48.080
our recordings these days. If you want to be part of the show and have your comments featured on the

01:07:48.080 --> 01:07:54.240
air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube. This is your host,

01:07:54.240 --> 01:07:58.240
Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and

01:07:58.240 --> 01:08:14.640
write some Python code. [Music]

01:08:14.640 --> 01:08:19.720
[Music]

01:08:19.720 --> 01:08:23.160
[ better right now ]

