WEBVTT

00:00:00.001 --> 00:00:04.960
A couple weeks ago, Charlie Marsh and the folks at Astral made another big splash with a major

00:00:04.960 --> 00:00:11.440
release of UV called UV Unified Python Packaging, which has many far-reaching features. We had to

00:00:11.440 --> 00:00:16.400
have Charlie on the show to give us an inside look into this development. Let's get to it.

00:00:16.400 --> 00:00:21.200
This is Talk Python to Me, episode 476, recorded September 3rd, 2024.

00:00:21.840 --> 00:00:24.080
Are you ready for your host, Darius?

00:00:24.080 --> 00:00:28.080
You're listening to Michael Kennedy on Talk Python to Me.

00:00:28.080 --> 00:00:31.440
Live from Portland, Oregon, and this segment was made with Python.

00:00:31.440 --> 00:00:39.840
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:39.840 --> 00:00:45.360
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:00:45.360 --> 00:00:50.160
both accounts over at fosstodon.org. And keep up with the show and listen to over

00:00:50.160 --> 00:00:55.360
nine years of episodes at talkpython.fm. If you want to be part of our live episodes,

00:00:55.360 --> 00:00:59.680
you can find the live streams over on YouTube. Subscribe to our YouTube channel over at

00:00:59.680 --> 00:01:03.760
talkpython.fm/youtube and get notified about upcoming shows.

00:01:03.760 --> 00:01:08.800
This episode is sponsored by Posit Connect from the makers of Shiny.

00:01:08.800 --> 00:01:13.280
Publish, share, and deploy all of your data projects that you're creating using Python.

00:01:13.280 --> 00:01:19.440
Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quattro, Reports, Dashboards, and APIs.

00:01:20.000 --> 00:01:24.800
Posit Connect supports all of them. Try Posit Connect for free by going to talkpython.fm/posit.

00:01:24.800 --> 00:01:33.600
And it's also brought to you by us over at Talk Python Training. Did you know that we have over

00:01:33.600 --> 00:01:40.320
250 hours of Python courses? Yeah, that's right. Check them out at talkpython.fm/courses.

00:01:40.320 --> 00:01:43.520
Charlie, welcome back to Talk Python to Me. How are you doing?

00:01:43.520 --> 00:01:47.200
I'm good. Thanks so much for having me back. It's always a pleasure to be on here.

00:01:47.200 --> 00:01:53.440
Well, you are certainly making waves in the Python space these days with all of your projects

00:01:53.440 --> 00:01:58.400
and their fastness. I think you're known as the fast Python guy these days.

00:01:58.400 --> 00:02:01.520
Oh, that's not fast enough. We got to use something from Astral.

00:02:01.520 --> 00:02:05.040
The fast Python tooling guy, maybe. Yeah.

00:02:05.040 --> 00:02:11.040
Yeah, exactly. Exactly. So interesting. We spoke, I think you've been on twice before. Is that right?

00:02:11.040 --> 00:02:12.640
We talked about Ruff once.

00:02:12.640 --> 00:02:18.400
Came on once to talk about Ruff, and then I came on in March shortly after we did the first public

00:02:18.400 --> 00:02:25.280
release of UV. Right, right. And UV at that time, I'll let you tell people what UV is, but for those

00:02:25.280 --> 00:02:32.880
who know, it was kind of in the, it has pip-like features. And now it's got another layer to the

00:02:32.880 --> 00:02:37.440
onion or another shell to it. And that's actually why I invited you back because there's a lot of

00:02:37.440 --> 00:02:41.680
interesting things to talk about there. Yeah. Maybe like several more layers too.

00:02:41.680 --> 00:02:50.800
Okay, well, let's hear about them. So first of all, I guess, not everyone, believe it or not,

00:02:50.800 --> 00:02:58.640
not everyone listened to that first Ruff interview, R-U-F-F interview and those kinds of things. So I

00:02:58.640 --> 00:03:05.200
suppose maybe quick introductions to you, Astral, how'd you get to where you are?

00:03:05.200 --> 00:03:13.360
Totally. Yeah, yeah, yeah. So I've been working on Python tooling full-time for a little under

00:03:13.360 --> 00:03:19.920
two years at this point. And my journey, I've been writing Python professionally for a long time,

00:03:19.920 --> 00:03:27.600
but my journey with Python tooling started with Ruff, which is a very fast Python linter,

00:03:27.600 --> 00:03:35.120
code formatter and code transformation tool. And the sort of foundational idea of Ruff was

00:03:35.280 --> 00:03:41.200
can we make really fast Python tooling? And so Ruff is written in Rust, but you don't need to

00:03:41.200 --> 00:03:45.760
have Rust installed or know anything about Rust to use it. You can just install it with pip or

00:03:45.760 --> 00:03:52.560
with whatever you're using. And that whole sort of story for me started from just working with

00:03:52.560 --> 00:04:00.160
Python a lot and asking if we could build sort of different Python tooling by using languages like

00:04:00.160 --> 00:04:06.080
Rust. So the first version of Ruff was very minimal, but it's grown from then to have,

00:04:06.080 --> 00:04:11.920
I don't know, maybe something like 800 plus rules. If you've used tools like Lake Eight or Pylint in

00:04:11.920 --> 00:04:17.760
the past, Ruff can do similar things. So discover issues with your code without running it. It can

00:04:17.760 --> 00:04:23.440
also fix them automatically. And then if you've used tools like Black in the past for code

00:04:23.440 --> 00:04:26.880
formatting, Ruff can do a similar thing too, where it automatically formats your code.

00:04:27.520 --> 00:04:31.440
So that was how I first got started in Python tooling. And also how I first ended up on

00:04:31.440 --> 00:04:34.960
Talk Python was people were very interested in this when it came out.

00:04:34.960 --> 00:04:41.840
And I think it broke a lot of people's minds in the sense that it really changed what was possible.

00:04:41.840 --> 00:04:48.480
Maybe an analogy. So if you have unit tests, but to run the unit test takes 30 minutes,

00:04:48.480 --> 00:04:53.280
there's no one who doesn't just want to kill time. Who's going to say, I made a small change.

00:04:53.280 --> 00:04:58.800
Let me run the test and see how that change did. But if the test run in 50 milliseconds,

00:04:58.800 --> 00:05:03.920
you could just set up a thing to just run the test every time code changes and just have a

00:05:03.920 --> 00:05:09.280
green, red, white. And I feel like Ruff did that for linting and formatting.

00:05:09.280 --> 00:05:15.680
Like for me, for example, I have it just run Ruff on, if I ask, I use PyCharm,

00:05:15.680 --> 00:05:19.760
ask PyCharm to reformat the code. It just, it uses Ruff to do that. Or, and you can check the

00:05:19.760 --> 00:05:23.520
box to just say, run it when I hit save, because you won't notice a difference. You know what I

00:05:23.520 --> 00:05:27.600
mean? Yeah. Yeah. I think that's been one of the really interesting things about working on

00:05:27.600 --> 00:05:32.480
tooling with the focus on performance has been like, if you build things that are way,

00:05:32.480 --> 00:05:36.560
way faster than what currently exists, like not just like a little bit, but like significantly

00:05:36.560 --> 00:05:41.920
faster, the ergonomics of the tool just change a lot. So maybe, maybe things that you only ran

00:05:41.920 --> 00:05:46.720
in CI before you can now run locally and maybe things that you now run locally, you can run.

00:05:46.720 --> 00:05:52.080
Yeah. On save as opposed to on, you know, on commit or on explicit command. So that's been a

00:05:52.080 --> 00:05:58.720
big part of you know, what we've seen with Ruff. And, you know, the other big piece apart from

00:05:58.720 --> 00:06:03.040
performance that we've been, that I think we sort of accidentally made a lot of progress on with

00:06:03.040 --> 00:06:10.080
Ruff was just trying to make things simpler by bundling more stuff together. So Ruff can do like

00:06:10.080 --> 00:06:14.960
a lot of different things. And so you don't need as many to chain together as many tools to get the

00:06:14.960 --> 00:06:19.360
kind of setup that you might want to have in your Python projects. And so, you know, a lot of the

00:06:19.360 --> 00:06:23.520
things we've built, you know, with Ruff and with UV, they've had these kind of dual goals of,

00:06:23.520 --> 00:06:28.400
you know, being much faster, you know, hopefully bringing in some interesting new features and

00:06:28.400 --> 00:06:34.240
functionality, but also trying to reduce a little bit of the, you know, the fragmentation and

00:06:34.240 --> 00:06:38.640
tooling and make it easier for people, especially, you know, for newcomers who are writing Python for

00:06:38.640 --> 00:06:44.400
the first time to kind of get started. And we have, you have announcements. I have things to

00:06:44.400 --> 00:06:49.600
discuss with you about them, about making that even easier. So that's why some of the big features

00:06:49.600 --> 00:06:54.720
of UV, right. For example, what if I don't have Python? Not a problem. So that's pretty, that's

00:06:54.720 --> 00:06:59.920
pretty exciting, I think. Yeah. Yeah. And we'll get into that, but I do want to just take a, not

00:06:59.920 --> 00:07:06.000
get too far past it because even though this episode is not about Ruff, two things. One,

00:07:06.000 --> 00:07:11.760
a theme of Astrals is we're going to take some tools or some kind of concept that's been around

00:07:11.760 --> 00:07:17.600
for a long time, redo it in Rust, but also not just, well, we ported over the code, but you know,

00:07:17.600 --> 00:07:21.600
rethink some of the algorithms and some of the assumptions. And I think that's also a lot of

00:07:21.600 --> 00:07:26.400
what makes it faster, like the way UV works with caching and things like that. Yep. And there's

00:07:26.400 --> 00:07:32.240
been a lot of excitement and positivity about that, but I think there's also been a little

00:07:32.240 --> 00:07:38.400
suspicion of, well, wait a minute. If, if we write this in Rust, is it really for Python people,

00:07:38.400 --> 00:07:43.040
by Python people? Like what's, what's your take? I don't, I have, I have some thoughts that are,

00:07:43.040 --> 00:07:47.440
I don't see it as a negative, but I think, I think it's interesting just to discuss,

00:07:47.440 --> 00:07:53.520
you know, where does Rust actually belong here? Yeah. I mean, I think like the way I view it is

00:07:53.520 --> 00:08:00.640
that you know, just like Python itself is, is implemented in C, like it makes some sense for

00:08:00.640 --> 00:08:05.600
like the underlying tooling that people are using to be written in a different language. If it means

00:08:05.600 --> 00:08:11.600
that you can ultimately build, you know, tools that are better, you know, at least on, on some

00:08:11.600 --> 00:08:16.880
metrics that people care about. So like for me, I sometimes view what we're doing as, you know,

00:08:16.880 --> 00:08:22.080
like we put all this investment into this tooling. We write all this stuff in Rust, which, you know,

00:08:22.080 --> 00:08:27.120
in theory incurs some costs for us. Maybe, you know, maybe we move a little bit more slowly,

00:08:27.120 --> 00:08:32.960
maybe it's harder. And in doing so, we kind of like give all these people who are running these

00:08:32.960 --> 00:08:38.560
commands, you know, hundreds of times a day, a big boost in how they work. And they can keep

00:08:38.560 --> 00:08:43.440
writing Python, but have a better and better experience writing Python. So, you know, I don't

00:08:43.440 --> 00:08:48.240
think it actually really says anything personally. I don't really think it says anything about Python

00:08:48.240 --> 00:08:52.960
that we write the tooling in Rust. Cause you know, we get, sometimes people will criticize

00:08:52.960 --> 00:08:56.480
Python for that, but like, you know, different languages are useful and good for different

00:08:56.480 --> 00:09:01.920
things. And Python is an incredibly productive language. It's like growing more and more every

00:09:01.920 --> 00:09:07.520
year. People love writing it. But maybe it's not the best language to write, you know, a super high

00:09:07.520 --> 00:09:11.760
performance package manager. And that's totally fine. Cause like, we're going to do that. And

00:09:11.760 --> 00:09:16.320
everyone who's writing Python can benefit from it and can leverage it. Yeah. I do think that

00:09:16.320 --> 00:09:23.280
one interesting piece here that I got, you know, we got a lot of skepticism around early on was like,

00:09:23.280 --> 00:09:27.120
you know, how can people in the Python community like contribute to this if it's not written in

00:09:27.120 --> 00:09:32.720
Python? You know, how do you like have a sustainable contributor base? And the interesting

00:09:32.720 --> 00:09:37.680
thing for me is like, I actually think we've had a really strong contributor base over time. Like

00:09:37.680 --> 00:09:42.560
we have, I don't know, like somewhere between four and 500 contributors total, maybe in Rust.

00:09:42.560 --> 00:09:46.800
You know, most of those are like one or two small, you know, one or two commits, maybe just one or

00:09:46.800 --> 00:09:51.360
two time committers. You know, but a lot of people have come to Rust and said, you know, I want to

00:09:51.360 --> 00:09:55.600
learn Rust. I come from the Python ecosystem. There's a part of this that's sort of native to

00:09:55.600 --> 00:09:59.360
what I know, which is the Python language, the Python semantics. And it's an entry point for

00:09:59.360 --> 00:10:04.320
me to learn Rust, you know, from other people who come from Python. So, you know, I think there is

00:10:04.320 --> 00:10:09.600
certainly a cost to engaging and a cost for contributors because most, you know, most of

00:10:09.600 --> 00:10:17.600
our users don't know Rust. But I don't think it's as steep as people would expect. And I think,

00:10:17.600 --> 00:10:22.240
you know, over time we have been able to grow a pretty healthy contributor base, like many people

00:10:22.240 --> 00:10:26.880
who have never written Rust before. Yeah, I agree. And I was thinking the same thing that you

00:10:26.880 --> 00:10:32.640
pointed out that Python itself is written in C. Right. Generally speaking, of course, there's

00:10:32.640 --> 00:10:37.760
multiple runtimes and so on and so on. But CPython, the one that we generally use is written

00:10:37.760 --> 00:10:43.760
in C. And I mean, I don't see why there should be an allegiance to C over Rust or anything. And a

00:10:43.760 --> 00:10:49.440
lot of the data science tools are written in C or Fortran even, you know, something really wild

00:10:49.440 --> 00:10:54.480
like that. And Python is a way to kind of expose them and make them more accessible, more useful,

00:10:54.480 --> 00:11:00.240
make people more productive on top of those, that's a native code. Yeah, yeah. A third example

00:11:00.240 --> 00:11:04.960
would be Jupyter, JupyterLab, Jupyter Notebook, all those things. When you talk to the contributors of

00:11:04.960 --> 00:11:10.960
those projects, they're down in TypeScript and JavaScript most of their day. So the data science

00:11:10.960 --> 00:11:15.600
folks don't have to write TypeScript and JavaScript. They just work in the tooling that's on the front

00:11:15.600 --> 00:11:20.320
end. And so it's, you know, it's kind of like, to me, it's kind of like, let's take one for the

00:11:20.320 --> 00:11:24.560
team. Yeah. We'll do this. So we all benefit, but you don't have to, you don't have to do it.

00:11:24.560 --> 00:11:30.800
I actually think it's one of the kind of, one of the real strengths of Python is the

00:11:30.800 --> 00:11:35.280
interoperability around like native code and extension modules. It's like a big,

00:11:35.280 --> 00:11:41.280
it's actually like a big part of Python and it's a big part of why Python has succeeded.

00:11:42.400 --> 00:11:46.080
And I think that will actually become more, I mean, this is sort of like going off on a tangent

00:11:46.080 --> 00:11:50.080
a little bit, but I think that will become a bigger and bigger part of like what Python looks

00:11:50.080 --> 00:11:56.160
like and what it looks like to work with Python. Because, you know, and I think Rust can actually

00:11:56.160 --> 00:12:00.560
play an interesting role here because at least from my perspective, like I do not have a systems

00:12:00.560 --> 00:12:05.360
programming background. Like I've not, I've definitely not written any C professionally.

00:12:06.560 --> 00:12:13.600
I don't think I've ever really written any C++. And Rust was my first sort of foray into that

00:12:13.600 --> 00:12:19.920
kind of programming. And I think at least for me personally, I found it much more accessible.

00:12:19.920 --> 00:12:25.040
And so I think Rust and Python actually have this interesting story where Rust to some degree

00:12:25.040 --> 00:12:30.480
is this kind of like superpower low level layer that you can drop into and then expose with a

00:12:30.480 --> 00:12:35.840
Python CLI forever in a consume. So anyway, my prediction is I think that will only become more

00:12:35.840 --> 00:12:40.080
and more of a part of what Python looks like. And that's actually, I think it's actually a good

00:12:40.080 --> 00:12:45.680
thing. Yeah, I do too. I do too. Jake out in the audience, Jake Callahan, who says, and another

00:12:45.680 --> 00:12:50.080
comment, "Great timing. I just released a video on these changes yesterday." So that's awesome.

00:12:50.080 --> 00:12:54.720
But said, "The progress made in Ruff and UV sensor introductions clearly demonstrates that

00:12:54.720 --> 00:13:00.480
there's a strong contributor base, even when it's based on Rust, right?" Yeah. Yeah. I think another

00:13:00.480 --> 00:13:03.920
thing that it- I'm not trying to dismiss that it's hard to learn Rust because I actually think

00:13:03.920 --> 00:13:08.160
it is pretty hard to learn Rust. And I think the learning curve is pretty steep. But I think the

00:13:08.160 --> 00:13:12.160
thing we found is there are people who are interested and who want to do it. Sure. Sure.

00:13:12.160 --> 00:13:18.560
Agreed. I think another thing that it shows, regardless of Rust or not, is if it's your

00:13:18.560 --> 00:13:25.360
full-time job and there's funding and a team, rather than part-time work, it can go many times

00:13:25.360 --> 00:13:30.480
faster towards the goal than before. I'm sure you've felt that way. Yeah. I mean, we're in a

00:13:30.480 --> 00:13:37.920
very unique, I mean, not completely unique, but fairly unique position whereby we can fund people

00:13:37.920 --> 00:13:44.720
full-time to work on this stuff. And it's actually just kind of wild to look at how much, not to sort

00:13:44.720 --> 00:13:49.200
of talk up our own work, but just how much you can accomplish in a relatively short period of time

00:13:49.200 --> 00:13:54.880
with that level of when people are kind of unlocked to work in that way and work on those kinds of

00:13:54.880 --> 00:14:02.000
problems. So just thinking, it's like the amount of time we've been able to put into Ruff and UV

00:14:02.000 --> 00:14:06.640
is sort of hard to fathom for some open source projects. It's like, wow, that's incredible.

00:14:06.640 --> 00:14:11.600
But from the perspective of a company, it's actually quite reasonable. And in fact, not even

00:14:11.600 --> 00:14:17.280
like that much. So I think it's pretty, like the leverage that you have with open source,

00:14:17.280 --> 00:14:22.320
like when people are able to invest in it and really focus on it is pretty amazing because

00:14:23.120 --> 00:14:26.640
we work on these things, we improve these things and they ship out to, I don't know,

00:14:26.640 --> 00:14:32.160
millions of users or whatever it is, and really can provide a huge boost to the ecosystem.

00:14:32.160 --> 00:14:35.760
So yeah, I mean, being able to work on this stuff full-time, that was actually something that I

00:14:35.760 --> 00:14:41.360
decided pretty early on with Ruff was the project was growing more and more popular. And I was like,

00:14:41.360 --> 00:14:46.720
I don't know if I can keep up with this if I don't work on it full-time. And so I'm at least going

00:14:46.720 --> 00:14:52.080
to see where that goes. And if it's possible. - It's possible, right? And here you are.

00:14:52.080 --> 00:14:57.120
- I mean, it is, but yeah, it's like, I mean, I just feel like I just have a lot of respect for

00:14:57.120 --> 00:15:02.480
people who, you know, commit significant amounts of their time to open source alongside everything

00:15:02.480 --> 00:15:08.000
else because yeah, it's, I mean, it's an amazing thing, but it's also very challenging and it's-

00:15:08.000 --> 00:15:10.080
- Oh, it definitely is. - It's 24/7.

00:15:10.080 --> 00:15:17.040
- Well, I think it's really positive that there's a group of people putting their full effort into,

00:15:17.600 --> 00:15:22.720
especially the UV side of things. That's going to make a dent.

00:15:22.720 --> 00:15:27.440
- Yeah, I mean, I think the other thing that's been cool about, you know, building this as a

00:15:27.440 --> 00:15:34.240
company is that we've been able to bring in a lot of people from like outside of Python to come and

00:15:34.240 --> 00:15:39.600
work on Python tooling. And I think that's like a really healthy thing for the ecosystem because

00:15:39.600 --> 00:15:44.560
not only are these people, you know, I think like really talented and really great, but they also

00:15:44.560 --> 00:15:48.800
bring like very different ideas and experiences. And so we have a lot of cross-pollination on the

00:15:48.800 --> 00:15:54.400
team. The team's kind of a mix of people who fall everywhere on the spectrum of like, or axes,

00:15:54.400 --> 00:15:58.320
I guess, probably not a spectrum of like how much Rust experience, how much Python experience they

00:15:58.320 --> 00:16:03.040
have. You know, some of them have mostly worked in like TypeScript and the JavaScript ecosystem. So

00:16:03.040 --> 00:16:06.880
that was sort of an intentional thing for me when thinking about like building a team to work on

00:16:06.880 --> 00:16:12.160
this stuff was I want to have like some people on the team who are like super deep Python experts.

00:16:12.160 --> 00:16:16.000
And I want to have some people who like bring a totally different perspective to the problems.

00:16:16.000 --> 00:16:20.880
So that's been another like very cool piece of putting together a team to work on this stuff.

00:16:20.880 --> 00:16:26.320
- I think that's a great perspective. This portion of Talk Python to Me is brought to you by Posit,

00:16:26.320 --> 00:16:32.880
the makers of Shiny, formerly RStudio, and especially Shiny for Python. Let me ask you

00:16:32.880 --> 00:16:37.280
a question. Are you building awesome things? Of course you are. You're a developer or data

00:16:37.280 --> 00:16:42.480
scientist. That's what we do. And you should check out Posit Connect. Posit Connect is a way

00:16:42.480 --> 00:16:47.680
for you to publish, share, and deploy all the data products that you're building using Python.

00:16:47.680 --> 00:16:52.960
People ask me the same question all the time. Michael, I have some cool data science project

00:16:52.960 --> 00:16:58.080
or notebook that I built. How do I share it with my users, stakeholders, teammates? Do I need to

00:16:58.080 --> 00:17:05.120
learn FastAPI or Flask or maybe Vue or ReactJS? Hold on now. Those are cool technologies, and I'm

00:17:05.120 --> 00:17:09.600
sure you'd benefit from them, but maybe stay focused on the data project. Let Posit Connect

00:17:09.600 --> 00:17:14.080
handle that side of things. With Posit Connect, you can rapidly and securely deploy the things

00:17:14.080 --> 00:17:20.960
you build in Python. Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Ports, Dashboards,

00:17:20.960 --> 00:17:26.720
and APIs. Posit Connect supports all of them. And Posit Connect comes with all the bells and

00:17:26.720 --> 00:17:32.080
whistles to satisfy IT and other enterprise requirements. Make deployment the easiest

00:17:32.080 --> 00:17:36.880
step in your workflow with Posit Connect. For a limited time, you can try Posit Connect for free

00:17:36.880 --> 00:17:44.880
for three months by going to talkpython.fm/posit. That's talkpython.fm/POSIT. The link is in your

00:17:44.880 --> 00:17:49.280
podcast player show notes. Thank you to the team at Posit for supporting Talk Python.

00:17:49.280 --> 00:17:56.080
One thing before we move on is talk about UV proper. Closing the loop here. You mentioned

00:17:56.080 --> 00:18:04.080
those rules, those 800 Lint rules. And this resource you have over at docs.ashville.sh/ruf/rules

00:18:04.080 --> 00:18:10.560
is awesome. So even if you don't use Ruff, you know, you care about say PEP8 naming or something,

00:18:10.560 --> 00:18:15.920
you get a warning from Flake 8 or whatever, and it says, "Under function name." Like,

00:18:15.920 --> 00:18:21.680
what is this error, right? What is this thing? And then you've got each one of these rules has a,

00:18:21.680 --> 00:18:26.480
what is this? Why is it bad? How should you change it? Here's the bad version. Here's the

00:18:26.480 --> 00:18:30.960
good version. And so on. And I think this is just a really good resource. I know you all put a ton

00:18:30.960 --> 00:18:34.160
of time and energy into it. - I appreciate you calling that out. Yeah, it takes a lot of time.

00:18:34.160 --> 00:18:38.320
I mean, once you cover all the rules, maintaining it incrementally is slightly easier. But,

00:18:38.320 --> 00:18:41.840
you know, when we started this, we had a few hundred rules. And so, you know,

00:18:41.840 --> 00:18:45.840
it was a lot of contributors who contributed us getting to full coverage here.

00:18:45.840 --> 00:18:50.000
- It's almost like the Wikipedia of Lint rules or something.

00:18:50.000 --> 00:18:55.200
- How to Python, yeah. Yeah, I guess maybe one thing I'll say is like, we have a lot of rules,

00:18:55.200 --> 00:18:59.440
but you don't have to use them all. And like the default rule set is actually pretty small.

00:18:59.440 --> 00:19:03.600
So even when I work on projects, I don't necessarily enable all of the rules. I typically

00:19:03.600 --> 00:19:07.760
enable like a couple of subsets. So I just think sometimes it can be intimidating to imagine 800

00:19:07.760 --> 00:19:12.400
rules being applied over your code base. So, you know, the default rule set is pretty small. It

00:19:12.400 --> 00:19:17.040
covers things like unused imports, you know, things that are pretty common and relatively

00:19:17.040 --> 00:19:20.720
unobjectionable. And then we have all these different categories for ways that you can

00:19:20.720 --> 00:19:24.640
kind of level up the level of coverage. - Yeah. I take pretty much the defaults

00:19:24.640 --> 00:19:30.560
as well on all my projects, except for wider lines of code, more columns.

00:19:30.560 --> 00:19:34.000
- Yeah. Yeah. - On a 32 inch monitor,

00:19:34.000 --> 00:19:38.480
80 columns is just a little corner. - We actually took that out of the defaults.

00:19:38.480 --> 00:19:40.000
- Did you? Oh, beautiful. - Yeah.

00:19:40.000 --> 00:19:45.040
- I don't need a rough dot toml or whatever it was I was putting in there for a configuration.

00:19:45.040 --> 00:19:48.320
- Yeah. - Because the thinking there is like,

00:19:48.320 --> 00:19:53.360
if you have long lines, they should generally be handled by a formatter, not a linter. So by default,

00:19:53.360 --> 00:19:57.920
we don't enforce that. Yeah. - Okay. Interesting. And then the single

00:19:57.920 --> 00:20:01.600
quotes versus double quotes, which we discussed on GitHub, I remember. I think we talked about

00:20:01.600 --> 00:20:02.800
last time. - Yeah, probably.

00:20:02.800 --> 00:20:05.760
- Maybe as well. Yeah. - I talked about that with everyone.

00:20:05.760 --> 00:20:12.240
- Yeah. And Miguel also agrees here. Amazing docs. The rules are top-notch. Nice work.

00:20:12.240 --> 00:20:15.200
- I appreciate that. - Okay. So I know we're going to talk

00:20:15.200 --> 00:20:19.760
EV, but Kushar does have a good question out there. And I don't know if speak to it or don't

00:20:19.760 --> 00:20:26.720
speak to it. Are there plans for Ruff to become a Pylance alternative? So a language server of some

00:20:26.720 --> 00:20:29.440
sort. Is this anything that you're willing to talk about?

00:20:29.440 --> 00:20:34.000
- I would say, I mean, yeah, I think that's like an interesting thing that we'll consider. It's

00:20:34.000 --> 00:20:39.840
not something that we are committed to doing or committed not to doing, like building a language

00:20:39.840 --> 00:20:45.760
server. I would say that's probably like a few steps away from where we are today. Because before

00:20:45.760 --> 00:20:52.000
we would build a language server, we would probably build something like a type checker,

00:20:52.000 --> 00:20:56.640
like something that could deal with type inference and better understand the relationships between

00:20:56.640 --> 00:21:01.040
different parts of your code. I view that as like, it's not strictly a prerequisite to building a

00:21:01.040 --> 00:21:03.680
language server, but I view that as like a little bit more of a path.

00:21:03.680 --> 00:21:08.080
- More mypy. - Yeah, more mypy. I think there's

00:21:08.080 --> 00:21:12.400
like a lot of interesting stuff around building a, well, first of all, of course, there's like

00:21:12.400 --> 00:21:18.240
building a type checker, but there's also building what I would call like a type aware linter. Like

00:21:18.240 --> 00:21:22.240
you could imagine that Ruff itself could actually get a lot more powerful if it could do all sorts

00:21:22.240 --> 00:21:26.640
of type inference. Like we have some rules that are only supposed to activate on dictionaries

00:21:26.640 --> 00:21:32.240
and we do some sort of bad local type inference and heuristics to figure out if we think a variable

00:21:32.240 --> 00:21:38.000
is a dictionary. Like if you call not get on it, it might be a dictionary, right? So if we knew,

00:21:38.000 --> 00:21:41.600
there's just a lot of interesting things we could do. We could build a much better tool. So it's not

00:21:41.600 --> 00:21:46.560
just about building a type checker. It's also about how can we build a much better linter and

00:21:46.560 --> 00:21:50.320
sort of like set of tools. But yeah, we're thinking about that a lot. There's a lot of

00:21:50.320 --> 00:21:56.560
discussion happening about that, both internally and publicly on the repo and the Discord. We're

00:21:56.560 --> 00:22:01.120
thinking a lot about sort of type inference and how to evolve Ruff in that direction. So yeah,

00:22:01.120 --> 00:22:05.280
language server may be something we can do eventually. It's obviously a huge undertaking

00:22:05.920 --> 00:22:11.440
and we want to make sure that like anything we decide to build, we feel a lot of conviction,

00:22:11.440 --> 00:22:16.000
that it can be great because it doesn't necessarily make sense for us to try and build

00:22:16.000 --> 00:22:20.000
something that we think is like 5% better than what's out there. It's very hard to get users to

00:22:20.000 --> 00:22:24.560
switch to something that's 5% better. So when we look at the opportunity set, we're kind of thinking

00:22:24.560 --> 00:22:30.480
about where can we have a big impact? What do users really want? Cross-referenced against where do we

00:22:30.480 --> 00:22:33.920
think there's opportunity to build something that would be an improvement in ways that users care

00:22:33.920 --> 00:22:38.000
about? So yeah, very interesting. Not something we're focused on right now, the language or piece

00:22:38.000 --> 00:22:41.600
at least. Yeah. You guys are going to need at least a few weeks to get to that, huh?

00:22:41.600 --> 00:22:43.120
We're going to need a few weeks to get to language server.

00:22:43.120 --> 00:22:49.760
All right. Ivan out there in the audience says, "Excellent tool. Ruff and UV have changed my life."

00:22:49.760 --> 00:22:50.640
I've talked about Ruff.

00:22:50.640 --> 00:22:51.760
That's very nice.

00:22:51.760 --> 00:22:57.120
Yeah. UV, maybe a quick summary for what it is and then we could talk about your post,

00:22:57.120 --> 00:23:01.120
which adds layers of features and capabilities as we...

00:23:01.120 --> 00:23:01.760
Yeah, totally.

00:23:02.640 --> 00:23:08.640
So I came on the show back in March and we talked a bit about what UV was at the time.

00:23:08.640 --> 00:23:11.680
We released UV in mid-February, so that was a couple of weeks after.

00:23:11.680 --> 00:23:20.800
And UV is our Python packaging tool. And it's built under a lot of the same

00:23:20.800 --> 00:23:30.080
design goals as we had for Ruff. So we wanted it to be extremely fast. We wanted it to try and

00:23:30.080 --> 00:23:34.560
bundle a few more things together so that you could use fewer tools to work with Python and

00:23:34.560 --> 00:23:39.840
be productive with Python. And we wanted it to be really easy to adopt. That was another principle

00:23:39.840 --> 00:23:47.680
that we've thought about a lot. So when we released UV in February, it was framed as a PIP

00:23:47.680 --> 00:23:55.120
alternative. So the idea was if you've used pip before, pip install, pip uninstall, or tools like

00:23:55.120 --> 00:24:00.640
PIP compile or pip sync, it should be really familiar to you. So the API that we started with

00:24:00.640 --> 00:24:07.840
was UV pip install, UV pip uninstall, UV pip compile. And it was meant to mirror the pip API.

00:24:07.840 --> 00:24:13.600
And the idea there was we wanted it to hopefully be immediately obvious to people how this tool

00:24:13.600 --> 00:24:18.240
works and what it does, and also, I guess, to some degree, what it doesn't do. So we released

00:24:18.240 --> 00:24:27.600
that in February, and it grew extremely fast. It's just the adoption, both in terms of raw

00:24:27.600 --> 00:24:32.000
numbers and just the companies that we talk to that are using it very quickly. A lot of people

00:24:32.000 --> 00:24:37.440
were using it. I consider it a big success. I'm really happy with how that went. But it was also,

00:24:37.440 --> 00:24:42.800
I think, a pretty small... It was sort of a small portion of what we wanted to build for packaging.

00:24:43.680 --> 00:24:49.840
Ultimately, we weren't trying to build just a faster PIP. I think that's a really good starting

00:24:49.840 --> 00:24:57.360
point for a couple of reasons. One, much easier for people to adopt. Two, it required us to build

00:24:57.360 --> 00:25:02.560
a lot of the fundamental pieces that you need for Python packaging. In order to build a PIP

00:25:02.560 --> 00:25:08.400
alternative, we had to be able to resolve Python dependencies, install Python packages,

00:25:08.400 --> 00:25:12.480
understand virtual environments, manipulate all those things. We had to implement a bunch of

00:25:12.480 --> 00:25:17.840
standards around introspecting, build distributions and source distributions and virtual

00:25:17.840 --> 00:25:23.840
environments. So we had to invest in all these things that I view as fundamental primitives

00:25:23.840 --> 00:25:28.080
of working with Python packaging. But the ultimate goal for us was always,

00:25:28.080 --> 00:25:32.800
we want to build something that's a single static binary that you download and install,

00:25:32.800 --> 00:25:37.600
that just gives you everything you need to be productive with Python. And from that perspective,

00:25:37.600 --> 00:25:42.080
a pip alternative is pretty low level. And we wanted to build something that was a little bit

00:25:42.080 --> 00:25:46.960
more high level, something that can install Python for you, something that can manage the

00:25:46.960 --> 00:25:51.600
virtual environment for you, something where you just do run this file and it figures out the

00:25:51.600 --> 00:25:54.880
dependencies, installs them, it creates the environments and it runs this file in the

00:25:54.880 --> 00:25:58.960
environment. That is what we wanted to build. So that's what we've been building up to over

00:25:58.960 --> 00:26:01.440
the past couple of months. Yeah. Amazing. Of course,

00:26:01.440 --> 00:26:07.760
you've got to have the UV pip features as a foundation, right? Because even if you don't,

00:26:07.760 --> 00:26:12.640
kind of like we talked earlier, even if you don't expose it directly as a CLI thing,

00:26:12.640 --> 00:26:16.720
that from a project management perspective, it's needed, right?

00:26:16.720 --> 00:26:23.920
Yeah. And it's part of meeting people where they are to a certain degree. Everyone has workflows

00:26:23.920 --> 00:26:29.120
that are built around PIP. Even people that have other packaging workflows, often those

00:26:29.120 --> 00:26:33.680
workflows are actually built around pip commands. And like I said, I view those as a little bit low

00:26:33.680 --> 00:26:37.920
level. With PIP, the operations are kind of like, install this package into this environment,

00:26:37.920 --> 00:26:42.720
as opposed to here are my dependencies, make sure the world is in sync with my dependencies.

00:26:42.720 --> 00:26:47.840
That's what I would consider to be a little bit more high level. So we built and released that

00:26:47.840 --> 00:26:54.560
PIP interface in February. And since then, it's basically been hammered by users. So it's just

00:26:54.560 --> 00:26:59.280
gotten better and better, right? Because they find problems with it and then report them and it just

00:26:59.280 --> 00:27:03.920
gets better. It gets faster. It gets more feature complete. So we've had a few months to kind of

00:27:03.920 --> 00:27:08.320
improve it and build on top of it too. Yeah. That's one of the benefits of such,

00:27:08.320 --> 00:27:14.080
it taking, they can hold so much and people using it so much as they hit the little edge cases all

00:27:14.080 --> 00:27:18.080
the time and it gets smoothed out quick. Yeah. A lot of edge cases. Yeah. I bet.

00:27:18.080 --> 00:27:26.560
Yeah. But it's super fun set of problems to work on, by the way, and really different from Ruff

00:27:26.560 --> 00:27:35.600
too. Yeah. Ruff is more like a compiler. I would say we have a parser and a lexer,

00:27:35.600 --> 00:27:42.640
all that kind of stuff. And with UV, it's a lot more, how do we do IO really fast? We have a lot

00:27:42.640 --> 00:27:46.880
of networking. We're reading and writing from disk a lot. There's a lot of interfacing with

00:27:46.880 --> 00:27:54.080
standards, a lot of interfacing with the registry, everything's async. So it's just a very different

00:27:54.080 --> 00:27:58.480
set of problems. And it's fun to get to kind of work on both of them because they're just really

00:27:58.480 --> 00:28:02.480
different. Yeah. I'm sure they're both fun projects and there's some really good ideas

00:28:02.480 --> 00:28:09.520
and questions in the audience, but we're not ready for them. So I think when we spoke back in March,

00:28:09.520 --> 00:28:16.560
one of the things we discussed is how you structured the CLI API in a way to leave space.

00:28:16.560 --> 00:28:23.840
So for example, it's not UV install package, it's UV pip install package. And it's not UV

00:28:23.840 --> 00:28:29.760
compile --update for dependence. It's UV pip file or whatever the command is. I have it

00:28:29.760 --> 00:28:34.800
alias to a couple of letters and I never think about it again, but something that you've left

00:28:34.800 --> 00:28:41.760
space in the CLI with these sub commands. And I think now we're starting to see why you left space.

00:28:41.760 --> 00:28:46.480
Yeah. That was pretty controversial at the time and users really hated it.

00:28:46.480 --> 00:28:53.280
I mean, they still used it, but it's so much better. A lot of people complained about it.

00:28:53.280 --> 00:28:59.760
I even found myself saying, "Maybe we should stop doing this. Maybe we should just give up."

00:28:59.760 --> 00:29:05.600
People were complaining and I was annoyed by it and stuff. But yeah, it's either a huge,

00:29:05.600 --> 00:29:09.200
obviously, it's either a terrible mistake or it was genius. I don't actually know.

00:29:09.200 --> 00:29:16.320
But what it did was, one effect, which I said before, was it immediately conveyed the rough

00:29:16.320 --> 00:29:20.480
shape of the commands, like UV pip install. And then if you've used pip install, you know that

00:29:20.480 --> 00:29:25.040
the next argument is a package name or a requirements file. But the other thing it did is

00:29:25.040 --> 00:29:34.000
it left space in the CLI for these new APIs that are first-class UV APIs. So instead of doing UV

00:29:34.000 --> 00:29:38.480
install when we released in February, it was UV pip install, which meant that today, this new set

00:29:38.480 --> 00:29:44.400
of APIs that we launched, let's see, two weeks ago, I think today. Scroll up. Is there a date?

00:29:44.400 --> 00:29:53.920
August 20th. So this new set of APIs that we released are UV lock, UV sync, UV run. They can

00:29:53.920 --> 00:30:00.720
all be top level because they're really the first-class UV workflows. The pip API, by the way,

00:30:00.720 --> 00:30:07.280
still 100% there and we're going to invest in it a lot and continue maintaining it because that is

00:30:07.280 --> 00:30:13.040
how most people use UV. And maybe eventually we want that to be less true. We hope more and more

00:30:13.040 --> 00:30:18.240
people use the new stuff, but we're going to keep building that. But for projects that can, we now

00:30:18.240 --> 00:30:23.760
have this new interface that if you can fit into it, it's just sort of more powerful and does more

00:30:23.760 --> 00:30:29.680
for you. So we saved space in the CLI exactly for this reason, which is we had a bunch of stuff we

00:30:29.680 --> 00:30:34.720
knew we wanted to build. And if we polluted, well, not polluted is the wrong word, but if we polluted

00:30:34.720 --> 00:30:36.960
the interface with UV install-

00:30:36.960 --> 00:30:38.560
Clogged. If you clogged it.

00:30:39.120 --> 00:30:44.400
Yeah. If we lost all that space to those existing commands, it would make things harder. So I think

00:30:44.400 --> 00:30:50.320
it's worked. It's done. It's had the intended effect for us. It kept the space open. It let

00:30:50.320 --> 00:30:56.560
people use it, conveyed how it works. And now they kind of exist alongside each other. And the pip API,

00:30:56.560 --> 00:30:59.920
you can kind of use them together in certain ways. And when you use them together, you sort of

00:30:59.920 --> 00:31:05.600
realize that the pip API is more low level. It's like the new APIs, you have a PyProject.toml file

00:31:05.600 --> 00:31:10.400
with your requirements in it, and you just run UV sync and it will resolve them, create a lock file,

00:31:10.400 --> 00:31:15.120
install them in a virtual environment. That's like one command. You could then modify the virtual

00:31:15.120 --> 00:31:20.000
environment. You could do UV pip install, blah, blah, blah, and start making edits to it. That

00:31:20.000 --> 00:31:24.160
kind of illustrates what I mean by it's like a low level pip APIs where you're kind of manually

00:31:24.160 --> 00:31:29.040
manipulating things versus these higher level APIs where you tell us what your dependencies are,

00:31:29.040 --> 00:31:30.800
and then we figure everything out for you.

00:31:30.800 --> 00:31:36.720
Yeah, that's excellent. Just one comment on the, it's too many words or it's too long or whatever.

00:31:36.720 --> 00:31:42.560
Like I hinted at before, I just have aliases for these. So for example, I just type PIR,

00:31:42.560 --> 00:31:49.200
and that means UV pip install dash R requirements dot TXT. And like, I don't care if it's UV pip

00:31:49.200 --> 00:31:52.800
that or it's pip install dash, like whatever. I don't want to type any of those. So it's just

00:31:52.800 --> 00:31:58.160
three PIRs, let's go. And I've got three or four of those, one to make virtual environments with

00:31:58.160 --> 00:32:03.920
UV and a couple of things like that. And one to compile the changes. And you look up for me,

00:32:03.920 --> 00:32:08.000
I look up the docs, I go, okay, well, here's how I'm going to shorten that to something I never

00:32:08.000 --> 00:32:10.000
think about again. So it doesn't matter.

00:32:10.000 --> 00:32:12.000
That's totally fine. Right. That's totally fine.

00:32:12.000 --> 00:32:16.480
But you do got to consider, I guess, the workflow for new people.

00:32:16.480 --> 00:32:16.880
Yeah.

00:32:16.880 --> 00:32:20.400
Maybe that's a good place to talk about the features here. So one of the things that really

00:32:20.400 --> 00:32:24.880
so there's a lot here. One of the things that even though it's number three on the list of

00:32:24.880 --> 00:32:33.120
four things is the Python command. So UV Python install UV Python list, all of those kinds of

00:32:33.120 --> 00:32:38.480
things. I mean, maybe we should start there because without that we don't have any Python.

00:32:38.480 --> 00:32:42.960
Although, yeah, so that runs sort of implicitly under some circumstances, right?

00:32:42.960 --> 00:32:47.440
Correct. Yeah. So part of what we wanted to do with this release was make UV

00:32:47.440 --> 00:32:53.280
sort of self bootstrapping, which sounds complicated. But the idea there is

00:32:53.280 --> 00:32:58.160
if you don't have Python installed, UV doesn't depend on Python. It's just a binary.

00:32:58.160 --> 00:33:03.120
So you download it. And then when you run a command like UV VM and you give us a Python

00:33:03.120 --> 00:33:06.800
version, if you don't have any Python installed, if you don't have that version installed,

00:33:06.800 --> 00:33:10.240
we will download and install it for you. So you can sort of seamlessly run these

00:33:10.240 --> 00:33:13.920
commands without worrying about how do I install Python? Where's my Python,

00:33:13.920 --> 00:33:18.400
et cetera, et cetera. Which means that we can achieve this really cool experience

00:33:18.400 --> 00:33:24.160
where the whole set of commands you need to create a Python application are like,

00:33:24.160 --> 00:33:29.680
you curl install UV and then you just run like UV init --Python. And we create a project

00:33:29.680 --> 00:33:32.800
for you. We download and install that version of Python. You can just start running things.

00:33:32.800 --> 00:33:36.080
You don't have to think about how do I install Python? How do I get it on my machine? Do I have

00:33:36.080 --> 00:33:40.080
the versions I need? Anything like that. So you can obviously turn this stuff off, right? And

00:33:40.080 --> 00:33:45.520
you can use your own... It also respect Pythons that you have on your machine already. But part

00:33:45.520 --> 00:33:50.160
of the goal was we wanted to get to this, I won't call it the holy grail, but this experience of you

00:33:50.160 --> 00:33:56.240
just download the binary, you do UV run and everything just works. So that was a big part

00:33:56.240 --> 00:34:03.680
of it. And if you look at the full list of things that we put in this release, there's a lot of

00:34:03.680 --> 00:34:08.320
stuff, right? There's four bullets of things that each of those could be a big release.

00:34:08.320 --> 00:34:14.720
One is the Python installation. One is we have this sort of tool install, kind of like PIPX.

00:34:14.720 --> 00:34:20.000
So if you want to install Ruff globally, you can do UV tool install Ruff and we'll install it for

00:34:20.000 --> 00:34:23.840
you. It'll get put in your path, everything like that. We have these project management APIs that

00:34:23.840 --> 00:34:27.920
I've hinted at a little bit throughout this conversation, like UV run, UV lock, UV sync.

00:34:27.920 --> 00:34:29.040
Yeah, we'll get into it.

00:34:29.040 --> 00:34:34.720
And we have this thing around script execution. So for a long time, I thought that these would

00:34:34.720 --> 00:34:41.200
actually all be separate releases, that we would do a staggered series of releases. And I was

00:34:41.200 --> 00:34:44.800
excited about that because, well, first of all, that's always fun. You kind of have a bunch of

00:34:44.800 --> 00:34:48.240
things and you're shipping one week, one week, one week, and everyone's like, "Oh my gosh,

00:34:48.240 --> 00:34:52.480
we're shipping so much stuff." But the thing we found was they're all kind of interconnected in

00:34:52.480 --> 00:34:57.520
subtle ways. And the project management and the tool API, they're just not as interesting if you

00:34:57.520 --> 00:35:02.480
don't have the Python. They are interesting, but the fact that we have the complete story of you

00:35:02.480 --> 00:35:06.720
do UV run and we install Python, we've resolved your dependencies, we install your dependencies,

00:35:06.720 --> 00:35:10.080
we run the command in the environment, that whole picture, everything's a little bit

00:35:10.080 --> 00:35:15.040
interconnected. So that's how this release came to be so much stuff, is we had this vision for

00:35:15.040 --> 00:35:19.920
what we wanted the full stories to be, and they all became somewhat interconnected. And in the end,

00:35:19.920 --> 00:35:25.040
they're all individually, I think, really powerful things, but they kind of come together to give

00:35:25.040 --> 00:35:29.200
this, what we want this Python experience to be. And we're not totally there yet. We're missing

00:35:29.200 --> 00:35:34.080
stuff for sure. But this was our attempt to capture kind of a couple of different workflows

00:35:34.080 --> 00:35:39.040
that are intertwined in different ways. Yeah, I see how they all interconnect,

00:35:39.040 --> 00:35:43.520
but they are also interesting on their own. Yes.

00:35:43.520 --> 00:35:47.680
The Python installation thing is interesting. And usable on their own, by the way.

00:35:47.680 --> 00:35:52.720
Yeah, exactly. They're all independently. You just had one of those, you'd be like,

00:35:52.720 --> 00:35:57.840
that's pretty cool. Okay, I like that. That's pretty cool. So let's talk just a bit more about

00:35:57.840 --> 00:36:04.160
the Python one. So there's analogies here to other tools that people may know, and the closest one

00:36:04.160 --> 00:36:09.840
for this would be pyenv, do you think? Yeah, probably. It's like, there are

00:36:09.840 --> 00:36:14.880
obviously differences, but that's a very popular one that a lot of people know.

00:36:14.880 --> 00:36:20.000
Yeah, yeah. I'm not saying they're identical, but it fulfills a role that a lot of people were

00:36:20.000 --> 00:36:25.600
solving with it. Now, when I tried to do IENV, I don't remember what I was doing wrong, but this

00:36:25.600 --> 00:36:33.760
was the early days of Apple Silicon. And maybe I had the Intel x64 version of Homebrew, but I had

00:36:33.760 --> 00:36:37.120
the build tools for ARM. I can't remember, but I could not get it.

00:36:37.120 --> 00:36:42.000
Trying to do something under Rosetta or something. Yeah, and I couldn't get it to install anything

00:36:42.000 --> 00:36:47.360
with pyenv, because it would download it, it would try to compile it, then there'd be some

00:36:47.360 --> 00:36:51.920
weird compiler bug. And I'm like, you know what, I'm not debugging the source of, I'm just not

00:36:51.920 --> 00:36:58.160
debugging this. I'm out. I'm just going to go download it. And also, I compile Python for some

00:36:58.160 --> 00:37:04.080
of the server stuff I'm doing, and it takes a while. It's not that fast. And when I get it from

00:37:04.080 --> 00:37:11.280
you guys, if I say, "UV Python install 3.12" or something, boom, I get it. In your standard style,

00:37:11.280 --> 00:37:16.000
it's fast. How is it fast? Yeah, so that comes down to a fundamental

00:37:16.000 --> 00:37:20.320
difference between what we're doing and what Py... I don't know if it's pyenv or pyenv,

00:37:20.320 --> 00:37:22.080
by the way. I think it's pyenv, by the way.

00:37:22.080 --> 00:37:24.320
Okay, so I'm just going to say that, because that's what it means too.

00:37:24.320 --> 00:37:26.240
Let's go with that. If I try to do the other, I will mess up.

00:37:27.120 --> 00:37:32.640
So the way that pyenv typically works is, it's a great tool. A lot of people use it.

00:37:32.640 --> 00:37:36.480
It's building Python from source. And there are trade-offs around this, but the idea is

00:37:36.480 --> 00:37:41.920
it'll build the version of Python that you need. What we're doing is we're building a top of

00:37:41.920 --> 00:37:48.560
project called Python Build Standalone, originally created by Greg Sork. And that's a project that

00:37:48.560 --> 00:37:54.080
we've started contributing to. So I think I did the last two releases maybe. But the idea here is

00:37:54.080 --> 00:37:59.920
we have these standalone, easily redistributable Python builds. And when we do a release,

00:37:59.920 --> 00:38:06.640
it will create Python builds for a bunch of Linux architectures for macOS, for Windows,

00:38:06.640 --> 00:38:11.680
on all the different Python versions. And it will also run a bunch of optimizations over it.

00:38:11.680 --> 00:38:16.880
So it'll do... These acronyms, it's not important that you understand them, but it can do link time

00:38:16.880 --> 00:38:22.880
optimization or LTO and profile guided optimization, PGO. So we build all the libraries-

00:38:22.880 --> 00:38:24.000
That's pretty impressive.

00:38:24.000 --> 00:38:29.120
Yeah, we do. That all happens in advance. So if you go to the releases page here,

00:38:29.120 --> 00:38:36.720
like scroll up a little bit and just click the latest release. You'll see all the... Yeah,

00:38:36.720 --> 00:38:43.280
like 773 artifacts. That's like 773 Python builds. So it's a lot of different Pythons.

00:38:43.280 --> 00:38:44.160
Yeah, yeah. It's a lot of different-

00:38:44.160 --> 00:38:46.320
Yeah, 773 different-

00:38:46.320 --> 00:38:51.520
So we build all this stuff. And then when you run Python install, we figure out the correct...

00:38:51.520 --> 00:38:54.800
See, we have like arm, we have all this stuff. So then we figure out the correct Python for

00:38:54.800 --> 00:38:56.240
your machine, we just download and unzip it.

00:38:56.240 --> 00:38:59.600
I see. The same way you get a wheel is the way you get this.

00:38:59.600 --> 00:39:03.360
Yeah. I mean, it's actually the same code pretty much under the hood for us. It's like

00:39:03.360 --> 00:39:08.640
we stream and unzip it down into disk. And that's great. It's super fast.

00:39:08.640 --> 00:39:14.880
It's also... They're already optimized. PyEnv by default does not compile with optimizations.

00:39:14.880 --> 00:39:18.320
You can compile with optimizations, but it's not what it does by default.

00:39:18.320 --> 00:39:23.280
So these will be noticeably faster than what you would get by default with PyEnv.

00:39:23.280 --> 00:39:28.400
There are some downsides. Some people like to build from source, right? They like to have

00:39:28.400 --> 00:39:32.720
effectively the full chain of reproducibility in the build. And now you're kind of trusting

00:39:32.720 --> 00:39:35.920
us to give you your Pythons. So that is a downside to some people.

00:39:35.920 --> 00:39:41.120
Yeah. But then the next thing you do is you pip install something that has a binary wheel anyway.

00:39:41.120 --> 00:39:47.120
Yeah. No, that is true. There are also a couple of quirks with these builds

00:39:48.000 --> 00:39:53.120
that we're working on a little bit. Some of it has to do with licensing, the fact that you want

00:39:53.120 --> 00:39:57.120
to have kind of a statically... You want to have a self-contained Python. And there are some things

00:39:57.120 --> 00:40:04.080
in there that require licensing changes. So it uses all... There are some slight deviations from

00:40:04.080 --> 00:40:08.240
what you would get with building from source from CPython. And those are documented in Python

00:40:08.240 --> 00:40:13.600
build standalone. But the general idea is we pre-build and pre-optimize these Pythons. And

00:40:13.600 --> 00:40:17.600
then we download them on demand and it makes it really fast.

00:40:17.600 --> 00:40:25.840
Awesome. When I go to python.org and download a DMG package or an MSI for Windows or whatever,

00:40:25.840 --> 00:40:30.560
it runs this installer process that takes a good long while. And Jake just pointed out

00:40:30.560 --> 00:40:33.840
similar experience I had. It says it took me less than two seconds to install 3.10.

00:40:33.840 --> 00:40:40.560
Same thing for 3.12. So what is... Are we missing anything compared to running a

00:40:40.560 --> 00:40:44.160
proper installer that seems to take 20 seconds even on a fast computer?

00:40:44.160 --> 00:40:48.640
I think those installers also have to do some operations from source,

00:40:48.640 --> 00:40:55.360
most likely, because they're not shipping... I could be wrong about that. I haven't looked at

00:40:55.360 --> 00:41:03.520
them closely. But Python in general, like Python.org, does not distribute these kind of

00:41:03.520 --> 00:41:09.440
pre-built binary distributions for all these different architectures. And there's interest

00:41:09.440 --> 00:41:16.640
in doing that. And I'm also interested in doing that. But there are some things that need to be

00:41:16.640 --> 00:41:22.880
decided, standards that potentially need to be set. So it's possible that eventually we can just

00:41:22.880 --> 00:41:31.280
grab these basically from python.org. I think our PyPy downloads come from python.org,

00:41:31.280 --> 00:41:37.200
if I'm not mistaken. PyPy, that is. Or it actually might come from pypy.org. Now I can't remember.

00:41:38.320 --> 00:41:43.120
Okay. Anyway, those come from some sort of official source. Yeah. Yeah. Yeah. Yeah.

00:41:43.120 --> 00:41:48.880
So, yeah. Maybe eventually. But for now, yeah, we're using Python build standalone and we've

00:41:48.880 --> 00:41:51.760
just been trying to grow our familiarity with the project too.

00:41:51.760 --> 00:41:56.720
Right. Okay. So let's give people a sense here. They do not have Python at all,

00:41:56.720 --> 00:42:01.920
or they can't count on having Python or the right version of Python. They can run a single shell

00:42:01.920 --> 00:42:08.560
command to get UV, which UV can then manage itself. They could pipx install the UV. Can you homebrew?

00:42:08.560 --> 00:42:09.920
Yeah. What other ways can I get?

00:42:09.920 --> 00:42:15.840
Yeah, you can get UV on your machine however you want. Like UV doesn't need to be in the virtual

00:42:15.840 --> 00:42:19.840
environment that it's manipulating. It can just be anywhere on your machine and it can operate

00:42:19.840 --> 00:42:22.480
on any environment. External tool sort of deal. Yeah.

00:42:22.480 --> 00:42:23.680
Yeah. Yeah. So once you have that.

00:42:23.680 --> 00:42:28.560
You can install it with pip. We have our own standalone installers that you can curl.

00:42:29.520 --> 00:42:33.600
It's on homebrew, right? You can install with pipx. You can install however you want.

00:42:33.600 --> 00:42:37.920
And then ultimately it can operate on any environment on your machine. So I actually

00:42:37.920 --> 00:42:42.160
don't recommend installing it in a virtual environment. I recommend installing it globally.

00:42:42.160 --> 00:42:43.040
Yeah. That's how I have it as well.

00:42:43.040 --> 00:42:44.480
Kind of working from there. Yeah.

00:42:44.480 --> 00:42:48.880
I believe I've pipx installed it because anything that falls into that category for me goes under

00:42:48.880 --> 00:42:50.400
pipx, at least for now. Yeah.

00:42:50.400 --> 00:42:52.000
We'll talk about that in a minute.

00:42:52.000 --> 00:42:57.040
I mean, one interesting thing is if you use our installers, like the curl installers,

00:42:57.040 --> 00:43:03.920
then you get access to self updates. So you can run UV self update and we will update to

00:43:03.920 --> 00:43:05.840
the latest version. That's right.

00:43:05.840 --> 00:43:08.320
Because I tried to try that. We can't really do that if you, yeah,

00:43:08.320 --> 00:43:11.840
you can't do that if you installed through a different package manager because we don't

00:43:11.840 --> 00:43:17.040
really know how it was installed. So if you install it through the installer, right, we

00:43:17.040 --> 00:43:21.280
write a receipt that we understand where we installed it and all that kind of stuff.

00:43:21.280 --> 00:43:23.440
Yeah. So that's one benefit,

00:43:23.440 --> 00:43:27.040
but it's not, you're not required to do that, of course.

00:43:27.040 --> 00:43:31.440
Sure. I ran into that when I, I just wanted to see what it would do. I ran a self update

00:43:31.440 --> 00:43:35.760
and it's, it said, you installed this from a package manager type thing. So go do that

00:43:35.760 --> 00:43:38.960
thing. But that's fine. I have automation for like all those things. So it's not a big deal.

00:43:38.960 --> 00:43:44.640
So to give people a sense, like once UV is on your system and in the path, you can say UV

00:43:44.640 --> 00:43:51.920
VNV --Python and put up some variation of a Python version. And if you have it, great,

00:43:51.920 --> 00:43:55.920
it'll use it right to create the virtual environment. If you don't have it, it will

00:43:55.920 --> 00:44:00.560
then do this two second download install deal. Assuming you have fiber and then create a virtual

00:44:00.560 --> 00:44:04.480
environment based on it. Right. Yep. That's right. And you can turn that off, but that is

00:44:04.480 --> 00:44:09.840
the default behavior. Yeah. That's awesome. And you can also pass a commands like a managed only,

00:44:09.840 --> 00:44:14.960
I think it is, or something like that, where you say, don't use the system Python, even.

00:44:14.960 --> 00:44:19.440
Yeah. Yeah. Only use the ones that UV will install or like only use the Pythons that

00:44:19.440 --> 00:44:22.640
are on my machine, ignore UVs, Pythons, or some customizations around that.

00:44:22.640 --> 00:44:24.880
Right. Like you could do the opposite. What an advantage that is.

00:44:24.880 --> 00:44:31.920
I will also say this version, by the way, this version format request thing is like so hard.

00:44:31.920 --> 00:44:37.760
Yeah. It's just like, you'd just be shocked like how much engineering work has gone into like

00:44:37.760 --> 00:44:42.240
understanding those requests and then discovering all the Pythons on your machine. And the

00:44:42.240 --> 00:44:47.040
discovering all the Pythons in your machine part problem, by the way, is a problem that like a

00:44:47.040 --> 00:44:54.080
bunch of tools have had to solve. And we've talked with like the VS Code team about fast Python

00:44:54.080 --> 00:44:58.160
discovery, because there's just like so many different places that it could be. And like

00:44:58.160 --> 00:45:04.320
on Windows, it's also like totally different than on Unix. So anyway, a lot of work has gone into

00:45:04.320 --> 00:45:11.520
that, but it's kind of like hilariously flexible now. Like you can say, yeah, you can say CPython

00:45:11.520 --> 00:45:15.840
greater than or equal to 3.12. Right. And then we'll look for CPython rather than PyPy or rather

00:45:15.840 --> 00:45:22.400
than GrailPy. So anyway, a lot of work went into that. What if I just say UV, VENV and I have no

00:45:22.400 --> 00:45:27.760
Python whatsoever? I think we would install the latest Python. Would you just go, yeah, just do

00:45:27.760 --> 00:45:33.520
an, a latest, like maybe a, an implicit --Python space three. Yeah. I think that would

00:45:33.520 --> 00:45:39.840
count as give me any Python from the list of downloads and then we sort by version. So I think

00:45:39.840 --> 00:45:43.680
you would effectively get the latest compatible version, but now you're kind of quizzing me a

00:45:43.680 --> 00:45:50.800
little bit. So I don't mean to be. I'm just kidding. All right. So we'll move on. I know

00:45:50.800 --> 00:45:55.680
there's so much more and we're, we don't have a ton of time to get it, but I just pulled up my,

00:45:55.680 --> 00:46:02.960
my warp terminal and I typed UV Python list and it shows me a bunch of options for arm 64 for MacOS

00:46:02.960 --> 00:46:12.560
3.12.5, 3.12.0, 3.11.9, 3.10.3, 8 and so on that I could pick. However, I'm just wondering where

00:46:12.560 --> 00:46:24.320
your cutting edge needle setting is going to go here. I don't see a three of 13. Yeah. And one of

00:46:24.320 --> 00:46:29.280
the things that is tricky about any of these package package manager stories is if I homebrew

00:46:29.280 --> 00:46:34.720
it, I'll see that there's a new Python, especially a major release, but I might have to wait a week

00:46:34.720 --> 00:46:38.720
before it's available on homebrew and, but homebrew auto updated. But if I install it from

00:46:38.720 --> 00:46:42.960
the installer from python.org, it won't auto update it. And you know, there's just, there's

00:46:42.960 --> 00:46:47.520
always a little drawback of it. And so when I saw this feature, I'm like, well, if this thing could

00:46:47.520 --> 00:46:53.040
just really soon have the newest one, that would just be icing on the cake. And so what is your,

00:46:53.040 --> 00:46:59.760
what is your policy on how quickly to adopt new things? How quickly to adopt release candidates

00:46:59.760 --> 00:47:05.040
and betas and things like that? Yeah. Like with 3.13, I mean, I would like to have it out as

00:47:05.040 --> 00:47:14.000
soon as there's an RC that that's what I would like to do. Our policy or our, our goal is to

00:47:14.000 --> 00:47:19.760
make sure that it's out before the stable release. So we would like to not be lagging on the stable

00:47:19.760 --> 00:47:26.720
release. And you know, we view like the, the minor releases in Python similarly in rough

00:47:26.720 --> 00:47:30.880
historically, like we'll be like, okay, we want to make sure that we support all the 312 language

00:47:30.880 --> 00:47:35.920
features before 3.12 is stable. And there were like a bunch of language features in 3.12. There

00:47:35.920 --> 00:47:40.240
was like some new grammar, there were new typing features. And so the goal there again, was like,

00:47:40.240 --> 00:47:44.160
the goal is to have it out by time it's stable. So that's typically like the contract we try and

00:47:44.160 --> 00:47:48.160
uphold. And that's still our plan for 3.13. Okay. Awesome. Yeah. Good to know.

00:47:48.160 --> 00:47:54.480
Jay says it would be, it would be nice to have an option to install pre-release builds.

00:47:54.480 --> 00:47:59.840
And Tushar says the thing is Python build standalone builds 600 releases per version

00:47:59.840 --> 00:48:04.480
number, having that run daily is too much, but if anyone could do some interesting caching,

00:48:04.480 --> 00:48:06.800
surely the Astral folks could do some sweet caching.

00:48:06.800 --> 00:48:11.280
It's kind of amazing though, that project runs, it's not like we don't, we don't own it. It's

00:48:11.280 --> 00:48:15.520
not under our org. That project runs completely for free on GitHub action.

00:48:15.520 --> 00:48:17.840
Wow. Isn't that kind of crazy, isn't it?

00:48:17.840 --> 00:48:20.320
Yeah. GitHub is ridiculous.

00:48:20.320 --> 00:48:21.840
Yeah. So anyway, that's kind of cool.

00:48:21.840 --> 00:48:26.640
How much traffic it handles and yeah, how much data. Yeah. They're, they're pretty awesome.

00:48:26.640 --> 00:48:32.480
Okay. So if you don't have Python, you can also, you don't have to do a VNV, you can just say UV

00:48:32.480 --> 00:48:36.320
Python install, give it a version and then you'll just have that. Like that's what

00:48:36.320 --> 00:48:42.160
Jake and I were referring to earlier, but you can also create a VNV. And this is sort of a

00:48:42.160 --> 00:48:46.000
philosophy that I'm, I'm getting, and sorry, someone said this earlier, but it's scrolled

00:48:46.000 --> 00:48:52.320
off the live stream comments that this prefer or require virtual environments by default,

00:48:52.320 --> 00:48:57.600
rather than prefer to try to jam stuff into system Python or the core Python. And then

00:48:57.600 --> 00:49:01.040
it could be a virtual environment if you really know the incantations.

00:49:01.040 --> 00:49:05.600
Yeah. Yeah. That's probably like, you know, when we did the release in February,

00:49:05.600 --> 00:49:12.400
we tried to steer pretty closely to the way pit behaves to make it easy for people. But we did

00:49:12.400 --> 00:49:18.240
pick a few battles where we wanted to intentionally diverge. And this was, this was one of the bigger

00:49:18.240 --> 00:49:23.680
ones, which is UV by default requires a virtual environment. So if you try and UV pip install,

00:49:23.680 --> 00:49:26.480
and there's no, we can't find a virtual environment in the current directory or an

00:49:26.480 --> 00:49:31.440
active virtual environment, we'll throw an error. And you can opt out of that by passing a system

00:49:31.440 --> 00:49:37.440
flag, but unlike pip, right, it's opt out. So you have to, by default, it uses a virtual environment

00:49:37.440 --> 00:49:44.000
and you can escape from that if you want to intentionally. So we're trying to like with

00:49:44.000 --> 00:49:50.080
these APIs too, like these are all virtual environment. Well, the tool stuff is, it is,

00:49:50.080 --> 00:49:54.720
but in a different way, like UV run, UV lock, UV sync, these all create a virtual environment

00:49:54.720 --> 00:49:59.920
in the project directory where the project is defined by a Py project. So if you run UV run

00:49:59.920 --> 00:50:04.400
in that directory, it will look at the dependencies, resolve them, create a lock file,

00:50:04.400 --> 00:50:07.760
create a virtual environment, install their locked versions into the virtual environment,

00:50:07.760 --> 00:50:13.760
run the command. And it does that every time, but it's so fast that we will hopefully so fast

00:50:13.760 --> 00:50:17.760
that we can do it. So like if the dependencies haven't changed, it will still make sure that

00:50:17.760 --> 00:50:21.840
everything's up to date. So if you just use UV run, we try and keep the whole environment

00:50:21.840 --> 00:50:25.280
in sync for you. And you don't have to think about how do I manage my environment? How do

00:50:25.280 --> 00:50:31.440
I activate it? How do I install stuff? But we're pretty like, we're pretty pro virtual environment.

00:50:31.440 --> 00:50:38.560
And one thing I want to do, and it's sometimes hard to hold these lines because you have users

00:50:38.560 --> 00:50:44.320
who come to you and want something really different. And it can be hard not to say yes

00:50:44.320 --> 00:50:49.680
to a lot of the things that users want. But some lines, I think we have to hold because

00:50:49.680 --> 00:50:55.280
if we concede on them, sorry, I'm making it sound like a battle, but if we concede on them,

00:50:55.280 --> 00:51:00.400
it just limits the things we can do in the future. Like if we make things too flexible,

00:51:00.400 --> 00:51:04.720
it limits some of the possibilities of what we can do in the future. And like one thing that I

00:51:04.720 --> 00:51:10.480
kind of want to change the perception around is, I think virtual environments are, they're here to

00:51:10.480 --> 00:51:18.240
stay really. And so we embrace them, but I want to change some of how people think about virtual

00:51:18.240 --> 00:51:22.640
environments. In particular, I want to change this whole idea of activating a virtual environment.

00:51:22.640 --> 00:51:28.160
I want it to feel more like node modules, which people don't necessarily think highly of node

00:51:28.160 --> 00:51:31.680
modules. I think when people think of node modules, they think of a huge node modules folder

00:51:31.680 --> 00:51:36.480
with like a ton of bloat. But the idea there is like, when you're in a project, you just sort of

00:51:36.480 --> 00:51:41.200
run commands and all the packages just get installed there. And it just runs in the correct

00:51:41.200 --> 00:51:44.480
environment with the correct dependencies. And that's actually what I kind of want. That's

00:51:44.480 --> 00:51:47.840
actually what I want Python to feel like is, yeah, there's a virtual environment, but it's

00:51:47.840 --> 00:51:51.200
actually just kind of like the directories. It's kind of just like full of packages, full of your

00:51:51.200 --> 00:51:56.880
dependencies. And you just use the right one at the right points in time. So that's part of the

00:51:56.880 --> 00:52:01.200
shift that I want us to move towards a little bit. And it's part of why we're a very virtual

00:52:01.200 --> 00:52:05.120
environment first and why we put the virtual environment right in the project in a specific

00:52:05.120 --> 00:52:10.480
known place, because we want to get away a little bit from this idea of where's the environment?

00:52:10.480 --> 00:52:14.720
How do I activate it? Do I have the wrong one activated? I want it to feel a little bit more

00:52:14.720 --> 00:52:20.480
like it is just sort of native to how the project works. If you're in the context of that thing,

00:52:20.480 --> 00:52:24.800
then it just uses the right one. Do you have intentions to do something? I can't remember

00:52:24.800 --> 00:52:29.360
the path, but something to the effect where if you're in a directory and there's no PyProject

00:52:29.360 --> 00:52:33.920
TML or virtual environment, but if you went up one or two, if we're both, would it fall to that

00:52:33.920 --> 00:52:40.320
one or would it just go? We do do that with UV run. So with UV run, we sort of find the root of

00:52:40.320 --> 00:52:48.160
the project. We'll look up at parent directories. But if you just run Python, blah, blah, blah,

00:52:48.160 --> 00:52:53.760
obviously we don't hook into anything there. And so, like with a lot of other things, like with UV

00:52:53.760 --> 00:52:57.360
run, UV lock, UV sync, we create a virtual environment. If you use our commands, it's

00:52:57.360 --> 00:53:01.600
kind of just like everything just works. But you can also just activate the virtual environment and

00:53:01.600 --> 00:53:05.680
do whatever you want, because we're kind of trying to embrace the fact that virtual environments are

00:53:05.680 --> 00:53:11.920
ever knows, not ever knows how to use them, but people are familiar with them. Editors and tooling

00:53:11.920 --> 00:53:19.040
revolve around them. So things that try to eject from virtual environments tend to cause a lot of

00:53:19.040 --> 00:53:23.360
problems for editors and workflows. So part of embracing virtual environments, I think again,

00:53:23.360 --> 00:53:28.080
is meeting the ecosystem where it is a little bit and being like, okay, the fact that we use

00:53:28.080 --> 00:53:32.560
virtual environments and they're just in your project means that you don't need a special

00:53:32.560 --> 00:53:37.600
editor integration to use UV. PyCharm will just let you use that virtual environment,

00:53:37.600 --> 00:53:41.920
just a normal virtual environment, in this perspective. So that's, again, part of what

00:53:41.920 --> 00:53:47.920
we're trying to do is build things that just work for people and try and embrace the standards and

00:53:47.920 --> 00:53:53.520
the conventions while also maybe influencing or changing parts of them that we think could be

00:53:53.520 --> 00:53:58.800
improved or could be made more user-friendly. Yeah. I don't know why I didn't book you for

00:53:58.800 --> 00:54:02.880
a two and a half hour podcast, because that's what we're going to need. So Vincent from Calm

00:54:02.880 --> 00:54:08.640
Code says, "UV run is such a game changer. He may work on a Jupyter runner for that this week.

00:54:08.640 --> 00:54:12.800
Feels like such a game changer," which is awesome. Cool. Yeah. There's a lot of cool ideas too around

00:54:12.800 --> 00:54:17.120
this sort of... Sorry, go ahead. Well, I was going to say with that in mind, let's dive into

00:54:17.120 --> 00:54:23.200
this whole project management stuff here. Right? Like this is, I think this is one of the three

00:54:23.200 --> 00:54:28.560
big pieces of functionality that comes through. And you've been talking about this sort of,

00:54:28.560 --> 00:54:32.160
some of the features like UV run and so on, but let's talk through, let's talk through...

00:54:32.160 --> 00:54:40.800
Yeah. I want to create a project. I don't have the Python installed. It's a new project. I want

00:54:40.800 --> 00:54:46.080
to create a pyproject.toml, but I don't remember the format for that. Let's go. How's that work?

00:54:46.080 --> 00:54:51.920
So we have a series of commands that kind of manage the project lifecycle for you. So you

00:54:51.920 --> 00:54:57.360
can run uv init to create a new project. And it has a couple of flags based on whether you want

00:54:57.360 --> 00:55:02.480
to build a library or a command line application, whether you want it to be structured as a Python

00:55:02.480 --> 00:55:06.560
package or just kind of, maybe it's just an application that you're running on your machine.

00:55:07.280 --> 00:55:12.800
But uv init will create the project. You can then run uv add, flask, uv add, FastAPI, whatever,

00:55:12.800 --> 00:55:17.040
to add dependencies. And when you run uv add, it will automatically generate the lock file

00:55:17.040 --> 00:55:23.520
and sync the dependencies to your system. So we do have commands like uv lock to generate the

00:55:23.520 --> 00:55:28.800
lock file and uv sync to download the correct dependencies into your environment. But you can

00:55:28.800 --> 00:55:32.240
also just kind of use these lifecycle commands and uv will make sure that everything's in the

00:55:32.240 --> 00:55:38.320
right state as you go. So you can run uv add, uv run. If you do uv run and then Python, blah, blah,

00:55:38.320 --> 00:55:44.080
blah, what happens behind the scenes is we resolve the dependencies, we make sure the environment's

00:55:44.080 --> 00:55:48.880
up to date, and then we run that command in the environment. So the whole lifecycle of working

00:55:48.880 --> 00:55:55.440
with your project can be managed through uv init, uv add, uv remove, uv run. There's a lot that goes

00:55:55.440 --> 00:56:01.520
into that. And there's also a lot of kind of powerful features built in here too. Like when

00:56:01.520 --> 00:56:07.840
you run uv run, it accepts a flag --with. So you can do uv run --with and put a

00:56:07.840 --> 00:56:13.440
dependency there. And it will basically just download that, put it in an ephemeral virtual

00:56:13.440 --> 00:56:18.320
environment and make it available for the command. So you can just pull in one-off dependencies as

00:56:18.320 --> 00:56:23.520
you need to run things. Like I never actually think about activating environments anymore.

00:56:23.520 --> 00:56:28.560
Like most of the time when I'm running Python commands to run one-off tooling, I'm running

00:56:28.560 --> 00:56:33.520
uv run --with requirements and I give it a requirements file. And then I pass the name of

00:56:33.520 --> 00:56:38.960
the file I want to run. And it just builds the thing you need and runs the command and then

00:56:38.960 --> 00:56:42.320
throws it away. And because you have, again, we were talking at the beginning of this episode

00:56:42.320 --> 00:56:48.000
about how really fast tools change the ergonomics. Part of what we're trying to build here is if we

00:56:48.000 --> 00:56:53.680
have this packaging system, that's really fast, especially for like repeated operations. Like

00:56:53.680 --> 00:56:58.080
I need to keep pulling in, I've downloaded this package before and you download it again,

00:56:58.080 --> 00:57:01.520
use it for this one command. Like we can just like throw away virtual environments and create

00:57:01.520 --> 00:57:08.560
new virtual environments in like in milliseconds. Yeah. If this was a Python dash M V E and V sort

00:57:08.560 --> 00:57:16.320
of, it would be way too much overhead. Yeah. Yeah. And so we can just like, even like a bunch of

00:57:16.320 --> 00:57:19.520
dependencies, like as they've been installed in your machine already, it's really, really fast

00:57:19.520 --> 00:57:26.480
just to pull these things together, use them and throw them away. So there's just a lot, there's a

00:57:26.480 --> 00:57:30.160
lot of things that we can do. And I think even like looking forward to the future, there's a lot

00:57:30.160 --> 00:57:35.520
of things we can do because we have this like performance foundation. Like, you know, I'm

00:57:35.520 --> 00:57:39.360
thinking about what if you want to test code on like a bunch of different Python versions. Yeah.

00:57:39.360 --> 00:57:44.880
And maybe you don't want to like have to keep destroying and recreating your virtual environment

00:57:44.880 --> 00:57:48.000
or something like that. Like there's just, there's a whole lot of stuff that we can build

00:57:48.000 --> 00:57:51.600
that would be really hard to imagine if you didn't have a really fast tool.

00:57:51.600 --> 00:57:54.400
Yeah. It's a chain. It definitely changes what's possible.

00:57:54.400 --> 00:57:58.880
Too sure out there, put it on an example that it's very near and dear to my heart.

00:57:58.880 --> 00:58:04.400
You know what would be great? If UV could build standalone binaries and embed Python into them.

00:58:04.400 --> 00:58:10.640
Yeah. It's not something we've built anything around, but yeah, I know it's being described

00:58:10.640 --> 00:58:16.160
there. Yeah. I think one of the, what I've seen most of the things do is we'll do something like

00:58:16.160 --> 00:58:22.400
zip up a virtual environment or site packages or something and then put that in a binary. And then

00:58:22.400 --> 00:58:28.480
when you run it, it'll spit that out or maybe do a memory mapped sort of magic to try to map into

00:58:28.480 --> 00:58:33.520
that and unzip it into memory or all sorts of weirdness. And I think really for this to be

00:58:33.520 --> 00:58:38.560
easy, some somewhere along the way, I could be wrong, not a core developer, but I feel like

00:58:38.560 --> 00:58:47.120
Python's import behavior needs to be able to import from an embedded resource in a compiled binary

00:58:47.120 --> 00:58:52.240
rather than sticking to binary and have the binary do like weird things where it fakes out the path.

00:58:52.240 --> 00:58:56.640
Cause there's always like something that falls apart. But if the pip itself, like, okay, we can

00:58:56.640 --> 00:59:02.000
import from a memory stream and not just from file system, then these things would be like, oh, well,

00:59:02.000 --> 00:59:05.920
if that's the case, here's how you just embed those. And off it goes, you know, it'd be more

00:59:05.920 --> 00:59:08.720
like go or say, here's your one thing you run it. You know what I mean?

00:59:08.720 --> 00:59:14.000
Yeah. Yeah. There's definitely interesting stuff to explore there. And there's some

00:59:14.000 --> 00:59:17.280
interesting tools that exist already to try to facilitate some of those things.

00:59:17.280 --> 00:59:18.640
Yeah.

00:59:18.640 --> 00:59:20.800
It's also, we've invested time in yet though.

00:59:20.800 --> 00:59:21.920
Yep. All right. Well.

00:59:21.920 --> 00:59:23.840
Yeah. I was thinking PyApp is similar. Yeah.

00:59:23.840 --> 00:59:27.680
Yeah. PyApp is definitely, I've used PyApp before. Actually I have an app running in my system right

00:59:27.680 --> 00:59:32.480
now. It's in a little menu bar thing. That's a PyApp app and it works well. It does work well.

00:59:32.480 --> 00:59:33.040
Yep.

00:59:33.040 --> 00:59:33.540
Okay.

00:59:34.400 --> 00:59:40.000
So the project API is kind of like, you know, if you've used like poetry or PDM,

00:59:40.000 --> 00:59:45.440
like these tools that are oriented around working on a project and you have a PyProjectTOML that

00:59:45.440 --> 00:59:50.560
defines your dependencies and you might have some sort of structure. It's based around that kind of

00:59:50.560 --> 00:59:55.920
workflow of working on a project, which, you know, is that's like one way that people work with

00:59:55.920 --> 00:59:58.800
Python, but there's a lot of ways, there's a lot of things that people do with Python, which is

00:59:58.800 --> 01:00:05.760
why we have a couple of different APIs. Right. So we also have this tool API, like UV tool install,

01:00:05.760 --> 01:00:10.960
UV tool run, which we've aliased to UVX. These are for running.

01:00:10.960 --> 01:00:12.560
This is interesting. Yeah.

01:00:12.560 --> 01:00:16.320
Yeah. These are for running like one-off, not one-off commands, but like things that you want

01:00:16.320 --> 01:00:21.040
installed globally. So like you might want rough installed globally on your machine so you can run

01:00:21.040 --> 01:00:26.160
it on a bunch of different projects. We call those like tools and you install them, you know,

01:00:26.160 --> 01:00:30.240
similar if you've used PipX before, we install them into dedicated environments

01:00:30.240 --> 01:00:37.120
and put them on your path. And there's a lot of really cool stuff here. Like I now use UVX all

01:00:37.120 --> 01:00:43.120
the time when I want to run things. So I'll do like UVX rough check and that translates to UV

01:00:43.120 --> 01:00:47.680
tool run rough, you know, run the check command. And behind the scenes, what it does is it finds

01:00:47.680 --> 01:00:52.080
latest version of rough, it creates an environment with that version, and then it runs the command

01:00:52.080 --> 01:00:58.400
using the rough binary in there. And there's really no overhead to that if you're kind of

01:00:58.400 --> 01:01:05.360
running it repeatedly. So, you know, this is oriented around like a different way of working

01:01:05.360 --> 01:01:09.840
with Python, where you have these tools that you need to run on your machine and you use them for

01:01:09.840 --> 01:01:14.080
different things. So we have like the project interface for working on a project. And then

01:01:14.080 --> 01:01:18.160
we have the tool interface for running Python, you know, command line tools.

01:01:18.160 --> 01:01:26.000
Yeah. So UVX run, well, UVX is the run version. You've also got the install. I have some thoughts

01:01:26.000 --> 01:01:31.520
of when I might do one or the other, but UV tool install seems like something you might want to run

01:01:31.520 --> 01:01:37.520
and have around and have auto-complete in your shell. So I could type R U tab and get rough or

01:01:37.520 --> 01:01:39.120
I could UV tool install.

01:01:39.120 --> 01:01:42.480
I think for things you're going to run repeatedly, it makes a lot of sense to install them.

01:01:43.120 --> 01:01:50.320
Also, if you have like, if you ran UV tool install rough, and then you ran like UVX rough,

01:01:50.320 --> 01:01:54.400
we would use the installed version. So if you already have the tool installed, we'll still

01:01:54.400 --> 01:01:59.120
pull the installed version, assuming it's compatible with the version request that you made.

01:01:59.120 --> 01:02:04.480
So like, yeah, I generally like UV tool install things that I'm going to run, you know, multiple

01:02:04.480 --> 01:02:11.120
times. The other really nice thing about UV tool install is we have UV tool upgrade. So you can do

01:02:11.120 --> 01:02:15.760
like UV tool upgrade --all, and we'll upgrade all the installed tools. So you don't

01:02:15.760 --> 01:02:19.040
have to think about like, which tools do I have installed? Like what versions are they at? Are

01:02:19.040 --> 01:02:24.320
they out of date? So it kind of gives you a way to manage all the Python tools that you're using

01:02:24.320 --> 01:02:29.760
at a kind of global level. So, you know, we have a lot of commands like in our docs,

01:02:29.760 --> 01:02:33.600
we have a lot of like automation tooling built around Python, like, you know, rough and UV

01:02:33.600 --> 01:02:36.560
are written in Rust, but a lot of our like documentation tooling, like we have a lot

01:02:36.560 --> 01:02:43.280
of scripting in Python. And all of our docs now in the doc string at the top have like the UVX

01:02:43.280 --> 01:02:48.160
command that you run to like run the script. Nice. And so I just like copy that and paste that and

01:02:48.160 --> 01:02:53.520
then the script just runs with all of its dependencies. So it's like, it's just super.

01:02:53.520 --> 01:03:00.400
It's just very, very convenient. I think like all these are API's and the way they come together.

01:03:00.400 --> 01:03:06.240
And there's a lot I know it's a lot of different stuff. And that was actually my biggest fear with

01:03:06.240 --> 01:03:12.640
this release was it's hard to succinctly explain what this release is, because it's a lot of

01:03:12.640 --> 01:03:16.960
different things. And it's not like when we released UV in February, when we released UV

01:03:16.960 --> 01:03:21.840
in February, it's like, this is a new tool. If you know pip, you understand what this is, right?

01:03:21.840 --> 01:03:27.120
It was much easier to explain, I think, in a succinct way, like what we're doing. And in this

01:03:27.120 --> 01:03:30.960
release, it's like, it's actually like a lot of different stuff that comes together to tell what

01:03:30.960 --> 01:03:39.600
I think is a very coherent story. But it's hard to succinctly explain exactly what we did. And

01:03:39.600 --> 01:03:48.320
I was very, like the response to it, I was really heartened to see that people were like getting it

01:03:48.320 --> 01:03:51.840
and they were getting different parts of it. Like different parts of it were speaking to different

01:03:51.840 --> 01:03:55.680
people, because I actually think different parts of it are like relevant to different ways that

01:03:55.680 --> 01:04:01.200
people work with Python. So a lot of people were excited about the lock files, the UV run. A lot

01:04:01.200 --> 01:04:05.120
of people were excited about the fact that we have this like scripting API, so you can like have

01:04:05.120 --> 01:04:09.840
these standalone scripts where the dependencies are embedded in them. And if you do UV run that

01:04:09.840 --> 01:04:16.240
script, we just resolve the dependencies, download them and run the script with those

01:04:16.240 --> 01:04:21.120
dependencies available. So you can have these like hermetic Python scripts. We had the Python

01:04:21.120 --> 01:04:24.320
install API. So there were just different things that were resonating with people, which I think

01:04:24.320 --> 01:04:29.520
is what made me happiest in the response to it. Did you read, I'm sure you read Armen's,

01:04:29.520 --> 01:04:35.200
Rye and UV, August is harvest season for Python packaging. Yeah. Yeah. That's a pretty positive

01:04:35.200 --> 01:04:41.040
take and a pretty wide ranging recommendation there. It's pretty interesting. Yeah. The

01:04:41.040 --> 01:04:48.320
relationship with Rye is something we get a lot of questions about. And I think like when we took

01:04:48.320 --> 01:04:55.040
over Rye, the goal was always like, we want to build UV up until to be a suitable replacement

01:04:55.040 --> 01:05:02.560
that people can migrate from Rye to UV. And we're getting further along that path, but there's still

01:05:02.560 --> 01:05:07.600
like things we're missing. We don't plan on like deprecating Rye anytime soon, but all of our like

01:05:07.600 --> 01:05:11.920
new feature development is really happening in UV and Rye it's mostly like bug fixes, like keeping

01:05:11.920 --> 01:05:18.240
things up to date. So, Rye has actually benefited a lot from UV because it uses UV under the hood.

01:05:18.320 --> 01:05:25.520
So like Rye has just gotten like there's new features or it's gotten faster. But our goal

01:05:25.520 --> 01:05:29.520
is really to like find the things that are missing from Rye and make sure we can support them in UV.

01:05:29.520 --> 01:05:35.360
Yeah. Last one we've got to cover here is, Yovheni points out single file scripts with

01:05:35.360 --> 01:05:40.720
dependencies. That's the last one, the script execution. So yeah, this is a huge problem.

01:05:40.720 --> 01:05:46.640
One of the reasons I think Tushar was suggesting it, and I'm also really excited about it is if you

01:05:46.640 --> 01:05:51.520
could bundle your code into an application, one of the benefits is you don't have to have a

01:05:51.520 --> 01:05:56.400
conversation with everyone that runs it. How to do virtual environments, how to do package management,

01:05:56.400 --> 01:06:01.600
all this kind of stuff. You just say run, click it or whatever. And somewhat short of that is I

01:06:01.600 --> 01:06:08.560
want to give you just a script of some sort, but and just say run this, right? Here's the script

01:06:08.560 --> 01:06:14.240
of app, you have an example.py to run that. But if you put some sort of magical incantation, which

01:06:14.240 --> 01:06:21.040
it's backed by a PEP to say what it actually requires, then UV --script something,

01:06:21.040 --> 01:06:25.680
it'll just see that and go, okay, or UV run rather. It'll see that, install the pieces

01:06:25.680 --> 01:06:28.880
ephemerally, right? And run. That's pretty cool. Yeah, exactly.

01:06:28.880 --> 01:06:31.120
So as our kind of our last thing before we run out of time.

01:06:31.120 --> 01:06:36.560
It's really cool. So this is backed by a pep. I think it's 723, if I recall correctly. So this

01:06:36.560 --> 01:06:42.560
is like a standardized, this syntax at the top of the file is standardized. Might not be mentioned.

01:06:42.560 --> 01:06:45.920
Somewhere. Yeah. There's a bunch of PEP conversations, but not the one.

01:06:45.920 --> 01:06:51.600
Yeah. We sometimes try and like shy away from talking about user facing features in terms of

01:06:51.600 --> 01:06:53.200
peps. Yeah.

01:06:53.200 --> 01:06:54.080
It's because-

01:06:54.080 --> 01:06:55.520
There you go, 723, that's it.

01:06:55.520 --> 01:07:00.640
Yeah. Okay. Well, there it is. But anyway, the, so the idea here is like,

01:07:00.640 --> 01:07:05.520
you can declare the dependencies for the script, right in the script. And then when you do UV run

01:07:05.520 --> 01:07:09.920
that script, we read that dependency data and we run the script in an environment with those

01:07:09.920 --> 01:07:19.920
dependencies. So the other, I think really cool piece here is I talked before about UV add. So

01:07:19.920 --> 01:07:25.120
if you're in a project with a PI project, Tom, you can do like UV add best API or whatever,

01:07:25.120 --> 01:07:30.400
but you can also do that for scripts. So if you scroll, if you look for like UV add dash dash

01:07:30.400 --> 01:07:34.560
script, so you're referred to this like magical incantation at the top. We will actually like

01:07:34.560 --> 01:07:39.760
create that for you. So if you do UV add --script, and then the script name and the

01:07:39.760 --> 01:07:43.120
dependencies, like we'll actually just like put that stuff in there for you. So you don't actually

01:07:43.120 --> 01:07:48.800
have to like remember how to do that. Like you can just do UV run --script, and we will

01:07:48.800 --> 01:07:53.440
actually like populate that field. So you can create a script, you can manage the dependencies

01:07:53.440 --> 01:07:58.640
in it with UV, you can run it. This is like super useful. There's some interesting conversations

01:07:58.640 --> 01:08:04.080
happening now too around like, what if we want to have a lock file for these? Because it's a little

01:08:04.080 --> 01:08:08.240
bit different, right? This is the list of dependencies. It's not the list of resolved

01:08:08.240 --> 01:08:12.880
versions. So if you wanted to have like full reproducibility, you probably want a lock file.

01:08:12.880 --> 01:08:19.520
And not just these things versions, but they're the transitive closure of all the dependencies.

01:08:19.520 --> 01:08:27.120
Everything they depend on. Yeah. So, you know, we do that for projects. Like if you do UV lock

01:08:27.120 --> 01:08:31.200
in a project, we create this lock file. That's all the transitive dependencies. It locks the

01:08:31.200 --> 01:08:36.400
exact URLs, the hashes, the versions, everything. We don't do that right now for scripts just because

01:08:36.400 --> 01:08:40.640
there's no, there isn't really a place to put it. But we're kind of thinking about.

01:08:40.640 --> 01:08:44.720
Have you considered the Windows registry? I mean, you could always just like integrate that and

01:08:44.720 --> 01:08:49.200
import that over to Mac and Linux. That'd be fine. Yeah. Just put everything in the Windows registry.

01:08:49.200 --> 01:08:54.000
Yeah. That's a winning idea. No, I totally get it.

01:08:54.000 --> 01:08:56.720
Yeah. I mean, the other thing that's interesting too is like the notebooks, like people are

01:08:56.720 --> 01:09:02.000
thinking about how can we add this kind of functionality to notebooks and you know,

01:09:02.000 --> 01:09:06.080
being able to declare the dependencies for a notebook, right in the notebook, being able to

01:09:06.080 --> 01:09:10.080
lock them too. It's a lot of cool stuff that we can build now that we have all these primitives

01:09:10.080 --> 01:09:14.240
connected. Yeah, for sure. I mean, you could do something like take a hash of the file and then

01:09:14.240 --> 01:09:18.400
use that hash as the name and as long as the file doesn't change, it'll run the same. I don't know.

01:09:18.400 --> 01:09:21.040
Yeah. Yeah. I'll leave that to you all.

01:09:21.040 --> 01:09:26.320
So I think, I mean, we didn't even talk about the speed for some of these things and there's,

01:09:26.320 --> 01:09:30.400
there's a whole lot of stuff here, but. There's a lot of good stories to tell about

01:09:30.400 --> 01:09:35.760
how we made some of these things. The problems we had to solve to like really some of this stuff,

01:09:35.760 --> 01:09:40.560
but they'll make for, you know, if I dream, they'll make for good blog posts. In reality,

01:09:40.560 --> 01:09:46.560
they'll probably make for good Twitter threads. Absolutely. All right. Well, Charlie, thanks for

01:09:46.560 --> 01:09:51.520
being here. Maybe give us a final thoughts and words for folks who are interested in this,

01:09:51.520 --> 01:09:58.000
this new layer of UV. Yeah. I mean, I think like this is, this release is really different from

01:09:58.000 --> 01:10:02.560
the previous release in part because we designed and built a lot of stuff that's pretty new for

01:10:02.560 --> 01:10:08.080
people and also requires people to, to change their workflows in a lot of cases. Like the

01:10:08.080 --> 01:10:12.720
previous release, it was like, this is a lot like pip, so kind of just drop it in. And now it's like,

01:10:12.720 --> 01:10:17.200
here's a bunch of ways to use this tools. If you were, you, it does require you to work a certain

01:10:17.200 --> 01:10:21.680
way and kind of think a certain way, but we think it's really powerful. And that's all stuff we're

01:10:21.680 --> 01:10:26.640
like kind of trying to figure out. Right. So we're very eager for, you know, I'm sure, I'm sure all

01:10:26.640 --> 01:10:31.440
this stuff will change and I'm just eager for like, like every release. I'm just excited to have it

01:10:31.440 --> 01:10:36.320
out, have people testing it, have people using it so we can get feedback. And so, you know, I, I

01:10:36.320 --> 01:10:40.880
would love for you to try it out. I'd love you even more for you to come file issues about the

01:10:40.880 --> 01:10:47.120
things that don't work so we can make it better and better. But I think we have a really cool

01:10:47.120 --> 01:10:51.040
foundation here. We can build a lot of things that hopefully make working with Python a lot,

01:10:51.040 --> 01:10:57.120
you know, a lot easier in the sense that the tools kind of get out of your way rather than

01:10:57.120 --> 01:11:02.720
getting in your way. So yeah, that'll be our focus for the next, for the next while is, is seeing how

01:11:02.720 --> 01:11:06.240
people are using this stuff and seeing where we can make it better. Well, I think it's pretty

01:11:06.240 --> 01:11:11.040
awesome what you all are up to. Big fan of UV. So happy, happy to see the project. Thank you.

01:11:11.040 --> 01:11:15.520
Progress here and always happy to have you on. So thanks. Thank you. Yeah. See you later. Bye.

01:11:15.520 --> 01:11:22.160
This has been another episode of Talk Python to Me. Thank you to our sponsors. Be sure to check

01:11:22.160 --> 01:11:27.120
out what they're offering. It really helps support the show. This episode is sponsored by Posit

01:11:27.120 --> 01:11:31.920
Connect from the makers of Shiny. Publish, share, and deploy all of your data projects that you're

01:11:31.920 --> 01:11:39.040
creating using Python. Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Reports, Dashboards,

01:11:39.040 --> 01:11:44.320
and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to

01:11:44.320 --> 01:11:52.080
talkpython.fm/posit. Want to level up your Python? We have one of the largest catalogs of Python

01:11:52.080 --> 01:11:56.960
video courses over at Talk Python. Our content ranges from true beginners to deeply advanced

01:11:56.960 --> 01:12:01.920
topics like memory and async. And best of all, there's not a subscription in sight. Check it

01:12:01.920 --> 01:12:06.880
out for yourself at training.talkpython.fm. Be sure to subscribe to the show. Open your

01:12:06.880 --> 01:12:11.680
favorite podcast app and search for Python. We should be right at the top. You can also find

01:12:11.680 --> 01:12:18.800
the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on

01:12:18.800 --> 01:12:23.760
talkpython.fm. We're live streaming most of our recordings these days. If you want to be part of

01:12:23.760 --> 01:12:28.320
the show and have your comments featured on the air, be sure to subscribe to our YouTube channel

01:12:28.320 --> 01:12:34.080
at talkpython.fm/youtube. This is your host, Michael Kennedy. Thanks so much for listening.

01:12:34.080 --> 01:12:37.600
I really appreciate it. Now get out there and write some Python code.

