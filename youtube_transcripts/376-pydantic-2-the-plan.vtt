WEBVTT

00:00:00.000 --> 00:00:00.840
- Hey, YouTube.


00:00:00.840 --> 00:00:01.680
Hey, Samuel.


00:00:01.680 --> 00:00:04.480
- Hi there, how are you doing?


00:00:04.480 --> 00:00:05.320
- Doing very well.


00:00:05.320 --> 00:00:07.680
I'm super excited to be talking about Pydantic


00:00:07.680 --> 00:00:09.400
and your plan and all these changes.


00:00:09.400 --> 00:00:10.720
And I know there's a whole bunch of people


00:00:10.720 --> 00:00:12.440
I've seen on Twitter and here on YouTube


00:00:12.440 --> 00:00:13.480
that are gonna be excited.


00:00:13.480 --> 00:00:14.600
So thanks for being here.


00:00:14.600 --> 00:00:15.880
For those of you listening,


00:00:15.880 --> 00:00:18.560
be sure to throw some comments and thoughts


00:00:18.560 --> 00:00:22.040
into the live chat and we'll try to get those into the show.


00:00:22.040 --> 00:00:23.880
Ready to kick this off?


00:00:23.880 --> 00:00:25.200
- Absolutely.


00:00:25.200 --> 00:00:26.680
- All right.


00:00:26.680 --> 00:00:29.280
Samuel, welcome back to Talk by Pydantic.


00:00:29.280 --> 00:00:34.080
to talk Python to me. It's great to be back. It was when was it? It was in the middle of it was


00:00:34.080 --> 00:00:41.040
in COVID, wasn't it? I seem to remember. It was core COVID. Yes, it was just what was that about


00:00:41.040 --> 00:00:47.440
15 months ago? Yeah. Yeah. Yeah. I was in my attic in the yeah I'm now in the office.


00:00:47.440 --> 00:00:53.600
Exactly. Locked down in the house and and all those kinds of things. Yeah, for sure.


00:00:55.120 --> 00:00:57.680
So yeah, it's great to have you back.


00:00:57.680 --> 00:01:01.080
We talked about Pydantic back then.


00:01:01.080 --> 00:01:04.440
Obviously, we're talking about Pydantic now as well.


00:01:04.440 --> 00:01:08.160
I would say it's grown tremendously since then.


00:01:08.160 --> 00:01:10.520
It was already quite popular then.


00:01:10.520 --> 00:01:14.280
- Yeah, I think it's, I don't have right now


00:01:14.280 --> 00:01:15.960
off the top of my head good metrics on, you know,


00:01:15.960 --> 00:01:18.720
insofar as you can quantify the growth of these things.


00:01:18.720 --> 00:01:21.160
I think it, yeah, it's grown a lot,


00:01:21.160 --> 00:01:23.400
but I think the feeling for me is it's become


00:01:24.760 --> 00:01:27.560
a lot more companies and people have started to rely on it,


00:01:27.560 --> 00:01:31.400
and it's become a core tool that they expect to work


00:01:31.400 --> 00:01:34.440
in the way you expect pytest or Django to work.


00:01:34.440 --> 00:01:38.000
Not quite, perhaps, at those levels, but moving in that direction.


00:01:38.000 --> 00:01:41.080
And yeah, I guess I'm probably jumping the gun,


00:01:41.080 --> 00:01:44.040
but at the beginning of this year, I was thinking about it,


00:01:44.040 --> 00:01:48.200
and I was obviously super proud of how many people were using Pydantic


00:01:48.200 --> 00:01:51.080
and how useful it was being, but I wasn't quite so proud of its internals,


00:01:51.080 --> 00:01:54.240
which is why I started thinking about


00:01:54.240 --> 00:01:57.400
what it would look like to kind of start again,


00:01:57.400 --> 00:02:00.560
'cause obviously V2 was an opportunity to break stuff,


00:02:00.560 --> 00:02:02.520
not that we haven't broken things in minor releases


00:02:02.520 --> 00:02:03.360
when we shouldn't have done,


00:02:03.360 --> 00:02:05.780
but like to formally break things and do it right,


00:02:05.780 --> 00:02:09.200
where it was obviously, I guess, wrong from the beginning.


00:02:09.200 --> 00:02:11.640
- Sure, well, the original,


00:02:11.640 --> 00:02:14.460
the goal, I'm sure, is not to go out and break things,


00:02:14.460 --> 00:02:19.280
but sometimes in order to take years of learning


00:02:19.280 --> 00:02:23.840
an experience and usage and turn that into the way you think it should be,


00:02:23.840 --> 00:02:25.680
some things may have to break, right?


00:02:25.680 --> 00:02:29.240
Yeah, I think that when I first released Pydantic, it wasn't...


00:02:29.240 --> 00:02:32.400
I've subsequently built projects I thought were going to be really popular


00:02:32.400 --> 00:02:34.680
and there's been, you know, varied in their success,


00:02:34.680 --> 00:02:39.080
but I literally built Pydantic for me and put it on, you know,


00:02:39.080 --> 00:02:42.360
put it on PyPy and then put it on Hacker News to see what would happen.


00:02:42.360 --> 00:02:45.640
But because of that, I thought about...


00:02:45.640 --> 00:02:49.000
there were some esoteric design decisions that were the stuff I wanted,


00:02:49.000 --> 00:02:51.560
but on reflection, they're not right


00:02:51.560 --> 00:02:54.360
for a popular library used by lots of people.


00:02:54.360 --> 00:02:56.600
Strictness being, I guess, the most obvious example,


00:02:56.600 --> 00:02:58.440
but a bunch of other stuff.


00:02:58.440 --> 00:02:59.560
- Yeah, we'll talk about strictness.


00:02:59.560 --> 00:03:01.860
We'll talk about a lot of these changes,


00:03:01.860 --> 00:03:03.660
but why do you think it was popular?


00:03:03.660 --> 00:03:07.480
- I think it came along at the right time.


00:03:07.480 --> 00:03:08.920
I think it came along when type hints


00:03:08.920 --> 00:03:11.040
were just getting popular in Python.


00:03:11.040 --> 00:03:13.420
They had been around in some guise for like ever, right?


00:03:13.420 --> 00:03:15.000
You could do something with them in 2.7,


00:03:15.000 --> 00:03:17.540
but they were just beginning to become a thing.


00:03:18.880 --> 00:03:23.680
mypy was coming out, but I suppose I was not the only person who was frustrated by


00:03:23.680 --> 00:03:26.560
the idea that they didn't have teeth, that they were there.


00:03:26.560 --> 00:03:27.840
But it seemed kind of weird, right?


00:03:27.840 --> 00:03:35.080
If you came from a Rust or a C++ or a C background, types are everything.


00:03:35.080 --> 00:03:38.200
And the idea that they were there but they meant nothing was a bit of an anathema to


00:03:38.200 --> 00:03:41.840
me and I just started off with, "Can I make them work a bit?"


00:03:41.840 --> 00:03:45.400
And that was five years ago and here we are.


00:03:45.400 --> 00:03:49.200
- Yeah, I agree that coming along at the right time


00:03:49.200 --> 00:03:50.920
was probably part of the magic.


00:03:50.920 --> 00:03:55.920
I think there was just some libraries and some frameworks


00:03:55.920 --> 00:04:03.040
who decided these types should have meaning, like you said.


00:04:03.040 --> 00:04:05.320
There was a couple of web frameworks,


00:04:05.320 --> 00:04:08.680
obviously most notably FastAPI,


00:04:08.680 --> 00:04:10.400
but there were other ones as well


00:04:10.400 --> 00:04:12.680
who were taking the ideas of,


00:04:12.680 --> 00:04:15.360
here's some type definitions in Python


00:04:15.360 --> 00:04:18.160
and what can we do with that?


00:04:18.160 --> 00:04:19.680
Could we actually make that mean something


00:04:19.680 --> 00:04:21.440
to help the developer experience?


00:04:21.440 --> 00:04:23.880
- I think that's true, and I guess I got some stuff right


00:04:23.880 --> 00:04:26.840
in doing documentation quite well, quite early on.


00:04:26.840 --> 00:04:28.800
I know that it wasn't perfect,


00:04:28.800 --> 00:04:30.640
but it did the job at the time.


00:04:30.640 --> 00:04:33.320
FastAPI and Sebastian's,


00:04:33.320 --> 00:04:34.600
Sebastian's amazing in lots of things,


00:04:34.600 --> 00:04:36.360
but his capacity to write documentation


00:04:36.360 --> 00:04:39.000
that is almost a story, that almost leads you,


00:04:39.000 --> 00:04:40.160
is enjoyable to read in the way


00:04:40.160 --> 00:04:42.060
that documentation normally isn't.


00:04:43.360 --> 00:04:45.720
Obviously, being adopted by FastAPI,


00:04:45.720 --> 00:04:47.720
like strapped rockets to Pydantic,


00:04:47.720 --> 00:04:49.600
but I think the other thing that made


00:04:49.600 --> 00:04:54.600
an enormous difference is that I came to Pydantic


00:04:54.600 --> 00:04:58.480
as a developer, not a typing academic.


00:04:58.480 --> 00:05:00.600
And I know there's a lot of debate about whether or not


00:05:00.600 --> 00:05:03.340
the typing world of Python moves a bit too far


00:05:03.340 --> 00:05:06.480
into the world of the theoretical,


00:05:06.480 --> 00:05:09.960
but I always wanted, for me it was always obvious


00:05:09.960 --> 00:05:13.420
that a string of 123 should be coerced to an int.


00:05:13.420 --> 00:05:16.180
And there's a lot of people who will say that's not useful.


00:05:16.180 --> 00:05:17.580
And then there's a million different ways


00:05:17.580 --> 00:05:19.420
in which they use it and they don't even realize.


00:05:19.420 --> 00:05:21.220
Because you think it's really obvious


00:05:21.220 --> 00:05:23.440
when you have ID equals 123 in a URL


00:05:23.440 --> 00:05:25.540
that that 123 is an integer.


00:05:25.540 --> 00:05:27.940
But obviously when you're passing a URL,


00:05:27.940 --> 00:05:30.820
there's no way to say that is actually definitely an int.


00:05:30.820 --> 00:05:35.260
So some of the lax stuff, the coercion,


00:05:35.260 --> 00:05:37.900
I think has been the thing that sets Pydantic apart


00:05:37.900 --> 00:05:39.140
from some of the other libraries


00:05:39.140 --> 00:05:40.940
that were perhaps more formally correct,


00:05:40.940 --> 00:05:45.140
but I would argue less useful in lots of contexts.


00:05:45.140 --> 00:05:48.640
- Well, I also think the more that you work on the web,


00:05:48.640 --> 00:05:51.840
where what you're accepting is out of your control,


00:05:51.840 --> 00:05:56.260
you want more help and you want more validation


00:05:56.260 --> 00:05:58.420
and you want more guardrails.


00:05:58.420 --> 00:06:00.160
People are posting JSON documents


00:06:00.160 --> 00:06:02.360
of who knows what to you.


00:06:02.360 --> 00:06:05.020
There's the query strings and the URL parameters


00:06:05.020 --> 00:06:06.140
that are always strings,


00:06:06.140 --> 00:06:08.300
no matter what they're supposed to be and stuff.


00:06:08.300 --> 00:06:10.880
So yeah, I think Hydandic especially fit well


00:06:10.880 --> 00:06:12.480
in the API side of things.


00:06:12.480 --> 00:06:15.440
- I also think there's the risk of getting a bit


00:06:15.440 --> 00:06:19.100
kind of like fuzzy and cod philosophy about this.


00:06:19.100 --> 00:06:22.760
There's a value in remembering what it was like


00:06:22.760 --> 00:06:24.480
to not be that good a developer


00:06:24.480 --> 00:06:29.080
and making it easy to use for beginners.


00:06:29.080 --> 00:06:31.280
And there's definitely a world of developers


00:06:31.280 --> 00:06:36.120
whose primary interest it feels


00:06:36.120 --> 00:06:37.960
is proving how much they know


00:06:37.960 --> 00:06:39.440
rather than making it easy for people.


00:06:39.440 --> 00:06:42.140
And Sebastian is even better at this than I am,


00:06:42.140 --> 00:06:44.600
but I think Pylantic does a good job of it,


00:06:44.600 --> 00:06:45.600
of being easy to use.


00:06:45.600 --> 00:06:47.240
And if you're new to developing,


00:06:47.240 --> 00:06:48.880
you and I know the difference between bytes and string,


00:06:48.880 --> 00:06:51.760
and obviously we would laugh through our nose


00:06:51.760 --> 00:06:53.040
at anyone who got them confused,


00:06:53.040 --> 00:06:54.720
but the fact is that when you're new,


00:06:54.720 --> 00:06:56.120
they look like two identical things,


00:06:56.120 --> 00:06:57.280
and one's got a B at the beginning,


00:06:57.280 --> 00:06:58.560
and the other one's got an F at the beginning,


00:06:58.560 --> 00:07:00.640
and what does any of that mean, right?


00:07:00.640 --> 00:07:02.800
- Yeah, just ignore that part, yeah.


00:07:02.800 --> 00:07:04.920
- Right, and so the fact that you can pass bytes


00:07:04.920 --> 00:07:09.240
to a string field saves people a lot of head scratching.


00:07:09.240 --> 00:07:14.720
- Yeah, it certainly has taken on a life,


00:07:14.720 --> 00:07:16.400
quite a life in the Python space


00:07:16.400 --> 00:07:20.560
and many, many different frameworks and libraries


00:07:20.560 --> 00:07:22.500
are depending upon it, which is great.


00:07:22.500 --> 00:07:24.880
Some stats that you put in this article,


00:07:24.880 --> 00:07:27.120
we're gonna talk, or this plan that we're gonna talk about,


00:07:27.120 --> 00:07:31.400
there's 72,000 public repos that I'm guessing


00:07:31.400 --> 00:07:34.520
are expressing some kind of dependency on.


00:07:34.520 --> 00:07:35.360
- Yeah.


00:07:35.360 --> 00:07:37.820
- Pydantic and then 10,000 get up stars.


00:07:37.820 --> 00:07:39.620
Yeah, that's coming up on 11.


00:07:39.620 --> 00:07:41.260
That's pretty amazing.


00:07:41.260 --> 00:07:42.980
- And the download count,


00:07:42.980 --> 00:07:45.860
I think it was 24,000 a month,


00:07:45.860 --> 00:07:49.380
sorry, 24 million a month when I last looked from PyPy.


00:07:49.380 --> 00:07:51.820
And that doesn't include distributions.


00:07:51.820 --> 00:07:53.080
Pydantic is distributed with,


00:07:53.080 --> 00:07:56.900
I think every major Linux distribution.


00:07:56.900 --> 00:08:00.100
So downloads in those contexts won't be included in that.


00:08:00.100 --> 00:08:03.300
So yeah, it's like it's being,


00:08:03.300 --> 00:08:06.740
It's widely adopted and it seems to be getting more widely adopted as time goes on.


00:08:06.740 --> 00:08:08.340
Yeah, for sure.


00:08:08.340 --> 00:08:11.300
Just to back up what you're saying to an army captain out there,


00:08:11.300 --> 00:08:13.300
it says, "Pidentik is very easy to onboard."


00:08:13.300 --> 00:08:14.300
Yeah, it's...


00:08:14.300 --> 00:08:17.900
Just because it does what you would expect it to,


00:08:17.900 --> 00:08:19.140
what you would want it to do.


00:08:19.140 --> 00:08:20.140
Yeah.


00:08:20.140 --> 00:08:23.540
So, let's see.


00:08:23.540 --> 00:08:27.140
One thing I wanted to sort of touch on a little bit


00:08:27.140 --> 00:08:30.740
before we got into the plan officially


00:08:31.180 --> 00:08:33.180
is let's just highlight some of the frameworks


00:08:33.180 --> 00:08:35.180
that are


00:08:35.180 --> 00:08:37.180
making core use of Pydantic.


00:08:37.180 --> 00:08:39.260
Obviously we talked about FastAPI, right?


00:08:39.260 --> 00:08:43.660
For people who don't know, maybe tell them real quick. What is FastAPI?


00:08:43.660 --> 00:08:46.300
FastAPI is a


00:08:46.300 --> 00:08:51.660
amazing web framework that allows you to, I think if you scroll down, I think that probably pictures will be better than words.


00:08:51.660 --> 00:08:53.180
Yeah.


00:08:53.180 --> 00:08:58.300
You use Pydantic and types generally to define what data people can pass to your endpoints.


00:08:58.680 --> 00:09:03.480
primarily as per the name for developing APIs.


00:09:03.480 --> 00:09:04.920
And yeah, it makes it super simple.


00:09:04.920 --> 00:09:07.500
I think there's an example down somewhere a bit further down


00:09:07.500 --> 00:09:09.320
on the home page.


00:09:09.320 --> 00:09:10.120
Maybe there isn't.


00:09:10.120 --> 00:09:11.360
Maybe it's on getting started.


00:09:11.360 --> 00:09:14.600
But there we are.


00:09:14.600 --> 00:09:19.400
Yeah, you see here, whether it be URL parameters like item ID


00:09:19.400 --> 00:09:23.240
or query parameters or obviously the body,


00:09:23.240 --> 00:09:25.840
they're all validated with Pydantic,


00:09:25.840 --> 00:09:28.200
which cuts out enormous amount of the work


00:09:28.200 --> 00:09:29.640
building APIs.


00:09:29.640 --> 00:09:31.360
Absolutely.


00:09:31.360 --> 00:09:32.880
And then there's a couple of things


00:09:32.880 --> 00:09:33.320
interesting.


00:09:33.320 --> 00:09:34.600
You have Pydantic models,


00:09:34.600 --> 00:09:37.240
which are Python classes


00:09:37.240 --> 00:09:38.480
with type, you know,


00:09:38.480 --> 00:09:39.720
a field colon type.


00:09:39.720 --> 00:09:40.760
So you express the type


00:09:40.760 --> 00:09:41.760
information about it.


00:09:41.760 --> 00:09:45.360
And then you can say this API


00:09:45.360 --> 00:09:47.120
function just takes one of these


00:09:47.120 --> 00:09:48.120
and it will automatically


00:09:48.120 --> 00:09:49.880
pull that data in and validate it


00:09:49.880 --> 00:09:51.240
using Pydantic through.


00:09:51.240 --> 00:09:53.080
Like the body, but then


00:09:53.080 --> 00:09:54.760
also you can express that


00:09:54.760 --> 00:09:57.440
that is the response model


00:09:57.440 --> 00:10:01.120
or the input model, and it'll use OpenAPI


00:10:01.120 --> 00:10:02.640
to actually generate the documentation.


00:10:02.640 --> 00:10:03.800
So there's all these different ways


00:10:03.800 --> 00:10:07.360
in which FastAPI is made better.


00:10:07.360 --> 00:10:09.440
- So the powerful thing about FastAPI


00:10:09.440 --> 00:10:13.440
is that by defining a relatively small amount here,


00:10:13.440 --> 00:10:15.240
we just defined it as like a three line function


00:10:15.240 --> 00:10:20.240
to define our endpoint, we get JSON schema for the input.


00:10:20.240 --> 00:10:24.880
So then we get docs built off of that.


00:10:24.880 --> 00:10:26.520
And we get obviously docs on the return type


00:10:26.520 --> 00:10:30.620
if we annotated it with what's returned.


00:10:30.620 --> 00:10:35.120
So yeah, from, and obviously the value


00:10:35.120 --> 00:10:38.560
and I can see from your tabs where you're gonna go next,


00:10:38.560 --> 00:10:40.160
like you define something in one place


00:10:40.160 --> 00:10:42.440
and you can then use it for your input


00:10:42.440 --> 00:10:45.800
and for your return type and then in your database.


00:10:45.800 --> 00:10:46.720
- Yeah, absolutely.


00:10:46.720 --> 00:10:49.720
So yeah, here's the, this is the most well-known example


00:10:49.720 --> 00:10:52.540
for using it on the API layer, the web layer,


00:10:52.540 --> 00:10:55.560
but there's also some cool examples of databases


00:10:55.560 --> 00:10:58.240
as you pointed out there, right?


00:10:58.240 --> 00:10:59.080
- Yeah.


00:10:59.080 --> 00:11:01.000
- Did this surprise you when you saw these?


00:11:01.000 --> 00:11:02.720
You probably had the API stuff in mind,


00:11:02.720 --> 00:11:04.840
but did the database surprise you?


00:11:04.840 --> 00:11:05.920
- It did a bit.


00:11:05.920 --> 00:11:08.500
I mean, I haven't looked at Beanie in lots of detail,


00:11:08.500 --> 00:11:12.640
but yeah, it's amazing that these things are coming along


00:11:12.640 --> 00:11:17.640
and being built and leveraging what Pydantic can do.


00:11:17.640 --> 00:11:21.860
I'm not a big ORM fan myself.


00:11:21.860 --> 00:11:23.740
I'm a bit old fashioned.


00:11:23.740 --> 00:11:25.020
I like to write my SQL.


00:11:25.020 --> 00:11:30.020
I like to write SQL, not MySQL.


00:11:30.020 --> 00:11:33.300
So I haven't actually used them, I have to say,


00:11:33.300 --> 00:11:34.620
but FastAPI I've used a lot


00:11:34.620 --> 00:11:36.180
and I've found absolutely amazing,


00:11:36.180 --> 00:11:40.820
but I can't talk about Beanie or SQL model


00:11:40.820 --> 00:11:45.820
beyond having had a quick look.


00:11:45.820 --> 00:11:47.500
- Yeah, you're like, "Oh, interesting.


00:11:47.500 --> 00:11:49.500
"What are they doing with this thing I created?"


00:11:49.500 --> 00:11:52.380
Yeah, so I just wanna give a quick sort of awareness,


00:11:52.380 --> 00:11:57.220
Shout out to Beanie, which is an async ODM object


00:11:57.220 --> 00:11:59.480
document mapper from MongoDB, like an RM,


00:11:59.480 --> 00:12:04.140
but there's no R, so D for document, based on motor.


00:12:04.140 --> 00:12:04.960
So it's pretty cool.


00:12:04.960 --> 00:12:07.900
It takes the asynchronous driver from MongoDB


00:12:07.900 --> 00:12:11.260
and then Pydantic, you just express your models,


00:12:11.260 --> 00:12:14.180
your documents as Pydantic models,


00:12:14.180 --> 00:12:16.940
which map really well because you can have hierarchies


00:12:16.940 --> 00:12:19.380
of Pydantic classes and models,


00:12:19.380 --> 00:12:21.980
which maps perfectly to document databases.


00:12:21.980 --> 00:12:24.820
So yeah, this is actually what TalkBython


00:12:24.820 --> 00:12:26.980
and Python Bytes websites are built on,


00:12:26.980 --> 00:12:27.820
which has been really nice.


00:12:27.820 --> 00:12:32.300
And then obviously, Sebastian Ramirez created SQL model,


00:12:32.300 --> 00:12:36.660
which is the same idea, but for SQL, right?


00:12:36.660 --> 00:12:38.300
It's built on top of SQLAlchemy,


00:12:38.300 --> 00:12:42.820
but you actually define your classes as identic models,


00:12:42.820 --> 00:12:46.340
and then that finds a way to sort of work with SQLAlchemy


00:12:46.340 --> 00:12:48.740
to still do the same stuff that it traditionally has done.


00:12:48.740 --> 00:12:50.300
So yeah, it's pretty neat.


00:12:50.300 --> 00:12:53.100
- Yeah, I think there was one of the complaints people had


00:12:53.100 --> 00:12:55.460
was that they were having to define their data twice.


00:12:55.460 --> 00:12:56.460
They would have a Pydantic model


00:12:56.460 --> 00:12:58.940
and then they would have a SQLAlchemy model.


00:12:58.940 --> 00:13:01.420
And so, yeah, it's not very surprising in a way


00:13:01.420 --> 00:13:04.420
that we found a way to combine them into one.


00:13:04.420 --> 00:13:07.780
Again, I'm not an expert on the internals of SQL model,


00:13:07.780 --> 00:13:10.380
but yeah, the two things look similar enough


00:13:10.380 --> 00:13:11.980
that like at a first pass,


00:13:11.980 --> 00:13:13.220
you would think it would make kind of sense


00:13:13.220 --> 00:13:15.900
to, yeah, squish them together.


00:13:15.900 --> 00:13:19.940
- Yeah, and one interesting thought about this


00:13:19.940 --> 00:13:22.820
is if you're gonna work in SQL model


00:13:22.820 --> 00:13:24.580
or you're gonna work in Beanie or something like that,


00:13:24.580 --> 00:13:26.340
and you decide, no, I actually wanna switch


00:13:26.340 --> 00:13:27.540
to a relational database,


00:13:27.540 --> 00:13:29.580
or I wanna switch from a relational database


00:13:29.580 --> 00:13:32.080
over to MongoDB or something like that,


00:13:32.080 --> 00:13:34.980
if it's all expressed as Pydantic models,


00:13:34.980 --> 00:13:36.300
like how close are you?


00:13:36.300 --> 00:13:37.140
You know what I mean?


00:13:37.140 --> 00:13:40.200
Like it's very little work to sort of make that transition.


00:13:40.200 --> 00:13:42.780
So it's cool that Pydantic is this kind of like


00:13:42.780 --> 00:13:45.840
abstraction layer. - And that's a cool project.


00:13:45.840 --> 00:13:49.260
There's a cool project that I was discussing with Adrian,


00:13:49.260 --> 00:13:51.760
I think it's Garcia yesterday, which is using


00:13:51.760 --> 00:13:55.420
Pydantic models to define data coming in


00:13:55.420 --> 00:13:58.420
from already Google Pub/Sub


00:13:58.420 --> 00:14:05.680
and from AWS, SQS, and potentially from Redis.


00:14:05.680 --> 00:14:07.260
So again, it's the same idea that like,


00:14:07.260 --> 00:14:09.540
once you define your models in Python,


00:14:09.540 --> 00:14:12.660
it wouldn't be that hard to switch from AWS to Google


00:14:12.660 --> 00:14:17.200
or even to like a database type tool like Redis.


00:14:17.200 --> 00:14:19.240
- Yeah, wow, amazing.


00:14:19.240 --> 00:14:20.720
Teddy out in the audience says,


00:14:20.720 --> 00:14:22.760
"We use data model code generator


00:14:22.760 --> 00:14:26.160
to generate our Pydantic models from JSON schemas."


00:14:26.160 --> 00:14:27.280
Are you familiar with that?


00:14:27.280 --> 00:14:29.400
- Yeah, yeah, so obviously,


00:14:29.400 --> 00:14:31.200
just as you can generate a JSON schema


00:14:31.200 --> 00:14:33.800
from a Pydantic model,


00:14:33.800 --> 00:14:37.040
there's a third-party tool that lets you go the other way


00:14:37.040 --> 00:14:38.560
and generate Pydantic models.


00:14:38.560 --> 00:14:40.640
It obviously won't do everything for you,


00:14:40.640 --> 00:14:41.560
validators and stuff,


00:14:41.560 --> 00:14:44.240
but it gives you the first start.


00:14:44.240 --> 00:14:45.320
- Nice.


00:14:45.320 --> 00:14:46.640
Let me throw one more out there


00:14:46.640 --> 00:14:49.560
before we dive into the plan, which is where we're going.


00:14:49.560 --> 00:14:52.000
How about JSON to Pydantic Converter?


00:14:52.000 --> 00:14:53.440
Have you seen this website?


00:14:53.440 --> 00:14:57.880
- I had, I did not know that existed until now,


00:14:57.880 --> 00:15:00.040
but I guess it's using that same tool under the hood,


00:15:00.040 --> 00:15:00.880
is it?


00:15:00.880 --> 00:15:01.720
- We'll watch this.


00:15:01.720 --> 00:15:02.540
- Maybe it's not.


00:15:02.540 --> 00:15:04.600
- It may be, I'm not actually sure.


00:15:04.600 --> 00:15:07.000
I haven't seen it mentioned it, but it doesn't really say.


00:15:07.000 --> 00:15:07.840
So.


00:15:07.840 --> 00:15:09.000
- I'd say not, 'cause it doesn't,


00:15:09.000 --> 00:15:10.040
that's not JSON schema, right?


00:15:10.040 --> 00:15:11.200
That's just.


00:15:11.200 --> 00:15:13.240
- What you do is you give it an example.


00:15:13.240 --> 00:15:15.960
- Oh, that's very cool.


00:15:15.960 --> 00:15:18.800
you give it an example JSON document.


00:15:18.800 --> 00:15:23.720
I'm till 27.


00:15:23.720 --> 00:15:26.720
So you give it a JSON document and it will actually,


00:15:26.720 --> 00:15:29.020
when I first heard about this,


00:15:29.020 --> 00:15:31.000
well, Pydantic will already generate JSON.


00:15:31.000 --> 00:15:32.120
Like, no, no, no, the other way,


00:15:32.120 --> 00:15:34.960
you give it a JSON results and it will generate


00:15:34.960 --> 00:15:38.920
the data model by looking at it.


00:15:38.920 --> 00:15:41.960
And it actually, even if you have like hierarchical stuff,


00:15:41.960 --> 00:15:45.000
it'll create multiple base model derived classes


00:15:45.000 --> 00:15:46.760
and all sorts, this thing is,


00:15:46.760 --> 00:15:48.720
this is pretty sweet right here, this thing.


00:15:48.720 --> 00:15:51.120
- That's pretty powerful, kudos to whoever built it.


00:15:51.120 --> 00:15:52.400
Yeah, I hadn't heard of it, but.


00:15:52.400 --> 00:15:54.560
- Yeah, and I've thrown massively complicated


00:15:54.560 --> 00:15:56.000
JSON documents at it.


00:15:56.000 --> 00:15:58.480
It is just like, well, it's gonna take eight classes,


00:15:58.480 --> 00:16:00.560
but here you go, and it just writes them all.


00:16:00.560 --> 00:16:01.680
It's fantastic.


00:16:01.680 --> 00:16:07.560
All right, well, with that, let's talk about the plan.


00:16:07.560 --> 00:16:09.760
First of all, before we get into the plan,


00:16:09.760 --> 00:16:14.000
I just wanna say, well done on this.


00:16:14.000 --> 00:16:17.440
We covered this on the Python Bytes podcast


00:16:17.440 --> 00:16:19.360
three or four weeks ago, something like that.


00:16:19.360 --> 00:16:22.440
And the response was, "Oh my gosh,


00:16:22.440 --> 00:16:26.240
this is incredibly detailed, incredibly well thought out."


00:16:26.240 --> 00:16:27.880
I think somebody, audience commented like,


00:16:27.880 --> 00:16:30.560
"There are companies that have been created


00:16:30.560 --> 00:16:33.120
and founded with less thought about the future


00:16:33.120 --> 00:16:33.960
and doing than that."


00:16:33.960 --> 00:16:35.720
So yeah, nicely done.


00:16:35.720 --> 00:16:36.560
- Thank you.


00:16:36.560 --> 00:16:40.960
Yeah, I spent a lot of time,


00:16:40.960 --> 00:16:43.400
quite a lot, a PyCon talking about this.


00:16:43.400 --> 00:16:46.680
to people and talking about little bits of it,


00:16:46.680 --> 00:16:48.400
there was a lot of it in my brain.


00:16:48.400 --> 00:16:51.240
And Sebastian, who is kind enough to sponsor me,


00:16:51.240 --> 00:16:53.680
but also obviously is maintaining FastAPI,


00:16:53.680 --> 00:16:55.460
was kind of asking me what it was gonna do.


00:16:55.460 --> 00:16:56.800
And I kept being like, "Oh, it'll do that thing,


00:16:56.800 --> 00:16:57.640
"and it'll do this thing."


00:16:57.640 --> 00:16:59.520
And then I got to the point of realizing,


00:16:59.520 --> 00:17:03.560
and probably about 70% of issues on Pydantic's issue tracker


00:17:03.560 --> 00:17:06.440
I reply with, "Don't worry, it'll work in V2."


00:17:06.440 --> 00:17:08.680
And I realized I got to the point where I really owed


00:17:08.680 --> 00:17:12.040
the community an answer to some of these questions.


00:17:12.040 --> 00:17:14.640
In fact, the first bit of feedback I got from it was,


00:17:14.640 --> 00:17:16.440
I'm dyslexic and I'm quite slow at reading


00:17:16.440 --> 00:17:20.860
and those read time notes never make any sense to me.


00:17:20.860 --> 00:17:22.520
So I just put 10 minutes in at the very beginning


00:17:22.520 --> 00:17:25.800
and then forgot about it as I extended it and extended it.


00:17:25.800 --> 00:17:27.800
And the first feedback was, great article,


00:17:27.800 --> 00:17:29.640
but how the hell is anyone reading that in 10 minutes?


00:17:29.640 --> 00:17:32.440
And so I pulled a new number out of thin air.


00:17:32.440 --> 00:17:35.640
- I, so yeah, it's a 25 minutes reading time,


00:17:35.640 --> 00:17:38.560
which I think is actually fairly accurate


00:17:38.560 --> 00:17:40.200
depending on how thoughtful you think


00:17:40.200 --> 00:17:42.600
about these various things.


00:17:42.600 --> 00:17:44.640
So the plan is--


00:17:44.640 --> 00:17:46.880
- Someone had, I've gotta have a shout out


00:17:46.880 --> 00:17:47.920
to one joke on Twitter.


00:17:47.920 --> 00:17:49.400
Someone was like, when it said 10 minutes,


00:17:49.400 --> 00:17:51.600
they were like, 10 minutes to parse,


00:17:51.600 --> 00:17:54.080
two days to validate, which I thought.


00:17:54.080 --> 00:17:55.680
- Oh yes, well done.


00:17:55.680 --> 00:17:58.200
Very, very pedantic like.


00:17:58.200 --> 00:18:03.200
Okay, so why do we need this plan?


00:18:03.200 --> 00:18:06.680
What's, why do we need to start?


00:18:06.680 --> 00:18:08.680
- So I think, I mean, like stepping back a bit,


00:18:08.680 --> 00:18:12.480
most projects, once they're mature and in widespread use,


00:18:12.480 --> 00:18:15.440
people don't sit down and tear them to pieces.


00:18:15.440 --> 00:18:17.920
They mostly stick with the same kind of warts


00:18:17.920 --> 00:18:23.320
and people polish the edges, but there's not a from scratch


00:18:23.320 --> 00:18:24.320
rebuild.


00:18:24.320 --> 00:18:26.200
And often when there is from scratch rebuild,


00:18:26.200 --> 00:18:28.120
it offends a lot of people because they


00:18:28.120 --> 00:18:29.320
don't know what's happening.


00:18:29.320 --> 00:18:33.280
And the cost of migrating is quite high,


00:18:33.280 --> 00:18:35.960
and they're turned off.


00:18:35.960 --> 00:18:39.960
But I thought there was enough wrong with the internals of Pydantic,


00:18:39.960 --> 00:18:43.320
and there was enough opportunity to do stuff way better,


00:18:43.320 --> 00:18:48.120
and there was enough reason to do that because there were enough people using it,


00:18:48.120 --> 00:18:52.040
that it was worth me sitting down and spending six months,


00:18:52.040 --> 00:18:55.000
but we've passed six months, building it right.


00:18:55.000 --> 00:19:00.600
And like I say, there was one of the...


00:19:00.600 --> 00:19:04.120
Not stats, but one of my observations was looking at...


00:19:04.120 --> 00:19:08.160
So there was a Stack Overflow survey


00:19:08.160 --> 00:19:10.080
of what technology people are using.


00:19:10.080 --> 00:19:12.160
And FastAPI had, I don't know what percentage,


00:19:12.160 --> 00:19:15.520
but like 6% market share, right?


00:19:15.520 --> 00:19:17.880
And then below it, they were talking about clouds


00:19:17.880 --> 00:19:19.360
and which clouds have what market share.


00:19:19.360 --> 00:19:20.760
Now, if you assume the same number of people


00:19:20.760 --> 00:19:23.240
are using web frameworks as are using clouds,


00:19:23.240 --> 00:19:27.180
which is an approximation, but not a mad approximation,


00:19:27.180 --> 00:19:29.480
then you would say that FastAPI and therefore Pydantic


00:19:29.480 --> 00:19:32.320
have a bigger market share than Oracle and IBM combined.


00:19:33.320 --> 00:19:36.520
in slightly different markets and obviously without the revenue to go with it.


00:19:36.520 --> 00:19:41.040
But it makes you realize that getting this right


00:19:41.040 --> 00:19:43.920
has a massive effect on lots of people.


00:19:43.920 --> 00:19:50.240
And secondly, I don't have a clue how many times


00:19:50.240 --> 00:19:55.480
Pydantic validates data a day between Netflix and Facebook


00:19:55.480 --> 00:19:59.720
and Amazon and Microsoft and everyone else, but it's a high number.


00:19:59.720 --> 00:20:04.080
And so the environmental impact of making Pydantic 10 times


00:20:04.080 --> 00:20:08.440
faster and therefore consume 10 times less CO2 to do


00:20:08.440 --> 00:20:10.960
a validation is, I suspect, not trivial.


00:20:10.960 --> 00:20:13.400
It's virtually impossible to get an accurate number,


00:20:13.400 --> 00:20:16.280
but something real.


00:20:16.280 --> 00:20:20.640
That's a really interesting way to think of it with almost


00:20:20.640 --> 00:20:24.200
having a responsibility to lessen the compute load.


00:20:24.200 --> 00:20:26.640
And when you're running your own website


00:20:26.640 --> 00:20:29.480
and it does a couple of users an hour or whatever,


00:20:29.480 --> 00:20:30.360
Like who cares, right?


00:20:30.360 --> 00:20:34.440
But when you're talking a million requests a second


00:20:34.440 --> 00:20:37.440
or whatever it is across all the different people


00:20:37.440 --> 00:20:40.080
using all the different frameworks across, right?


00:20:40.080 --> 00:20:41.560
That actually is meaningful.


00:20:41.560 --> 00:20:42.680
- That's not what I suspect.


00:20:42.680 --> 00:20:46.560
And like, think about a web server,


00:20:46.560 --> 00:20:49.840
assuming your database is doing all of the heavy lifting


00:20:49.840 --> 00:20:51.200
that it should be doing.


00:20:51.200 --> 00:20:52.840
What's the next biggest thing?


00:20:52.840 --> 00:20:57.840
Well, there's TLS termination, that's expensive,


00:20:58.480 --> 00:21:01.400
but again, that's done by some optimized C and Nginx


00:21:01.400 --> 00:21:03.280
or probably outside your code completely


00:21:03.280 --> 00:21:05.740
if you're using a platform provider.


00:21:05.740 --> 00:21:06.640
What's the next biggest thing


00:21:06.640 --> 00:21:08.360
that your code is doing CPU wise?


00:21:08.360 --> 00:21:10.800
Well, it's data validation basically.


00:21:10.800 --> 00:21:14.200
- Yeah, conversion, serialization, deserialization,


00:21:14.200 --> 00:21:17.320
validation, and all that lives in the pedantic realm.


00:21:17.320 --> 00:21:21.440
Also, I talked about two frameworks


00:21:21.440 --> 00:21:24.380
and I know there are others like Pydastic


00:21:24.380 --> 00:21:25.580
for Elasticsearch.


00:21:28.200 --> 00:21:32.440
where the validation and the data exchange


00:21:32.440 --> 00:21:35.580
is the database exchange as well, right?


00:21:35.580 --> 00:21:38.920
That's, that could be very important for,


00:21:38.920 --> 00:21:41.200
if you make this much faster,


00:21:41.200 --> 00:21:44.440
I don't know the numbers for Beanie precisely,


00:21:44.440 --> 00:21:47.500
but I know that a lot of those ORM ODMs,


00:21:47.500 --> 00:21:51.780
if you go and query and get like 10,000 rows back,


00:21:51.780 --> 00:21:54.120
the vast majority of that time is,


00:21:54.120 --> 00:21:59.120
how do I construct and fill out 10,000 objects in memory?


00:21:59.120 --> 00:22:01.320
- Yeah. - Right?


00:22:01.320 --> 00:22:02.800
And if you make Pydantic faster


00:22:02.800 --> 00:22:04.320
and Pydantic is that object,


00:22:04.320 --> 00:22:06.000
well, there's a huge bonus right now.


00:22:06.000 --> 00:22:07.040
- It's more than just,


00:22:07.040 --> 00:22:08.120
and I think the other thing to say


00:22:08.120 --> 00:22:11.000
is we've talked about web applications


00:22:11.000 --> 00:22:14.320
and from FastAPI being the kind of most high profile user


00:22:14.320 --> 00:22:17.080
of Pydantic, we talk about that a lot,


00:22:17.080 --> 00:22:18.240
but a lot of its usage,


00:22:18.240 --> 00:22:21.280
if you look at stuff that Explosion AI are doing,


00:22:21.280 --> 00:22:23.240
it's in data science and AI,


00:22:23.240 --> 00:22:26.280
and it's exactly that, it's like data sanitization


00:22:26.280 --> 00:22:30.920
into and out of models or into and out of databases.


00:22:30.920 --> 00:22:35.280
And there you are talking about really massive amounts of data.


00:22:35.280 --> 00:22:37.560
>>Absolutely. All right, let's get into it.


00:22:37.560 --> 00:22:41.640
So we talked about the plan.


00:22:41.640 --> 00:22:45.320
How about the roadmap, the timeline, things like that?


00:22:45.320 --> 00:22:47.080
>>So we're behind a bit, but we're not too far behind.


00:22:47.080 --> 00:22:51.080
I released version 0.1 of Pydantic Core yesterday,


00:22:51.080 --> 00:22:54.320
So that's, I'll come to what that means in a minute,


00:22:54.320 --> 00:22:57.240
but that's the first step of the plan.


00:22:57.240 --> 00:23:04.020
I'm about, I think I've either closed or merged 25 PRs today


00:23:04.020 --> 00:23:09.020
trying to get through Pydantic and get version V1.10 out.


00:23:09.020 --> 00:23:10.780
So I'm halfway, I'm not halfway through,


00:23:10.780 --> 00:23:15.020
I'm some bit of the way through two to be precise.


00:23:15.020 --> 00:23:18.100
- Right, so what you were talking about in the plan,


00:23:18.100 --> 00:23:19.660
as you said, there's a bunch of open PRs,


00:23:19.660 --> 00:23:21.420
a bunch of open issues.


00:23:21.420 --> 00:23:24.500
Let's merge in as much of that as possible


00:23:24.500 --> 00:23:27.760
to sort of capture it and then move forward


00:23:27.760 --> 00:23:30.500
in this rewrite that we'll talk about.


00:23:30.500 --> 00:23:31.540
- Right, yeah, exactly.


00:23:31.540 --> 00:23:35.340
So get 1.10 out, which is the same basic code base


00:23:35.340 --> 00:23:37.540
with a bunch more stuff added that I've,


00:23:37.540 --> 00:23:40.260
because I had a job and was really busy earlier in the year,


00:23:40.260 --> 00:23:42.300
I kind of dropped the ball on reviewing those PRs


00:23:42.300 --> 00:23:44.220
and they kind of got out of control.


00:23:45.260 --> 00:23:50.260
but get them dealt with and then get to a clean slate


00:23:50.260 --> 00:23:55.260
and then make the big move from V1.10 to V2.


00:23:55.260 --> 00:23:58.820
- Yeah, okay.


00:23:58.820 --> 00:24:02.540
And we do talk about there being breaking changes.


00:24:02.540 --> 00:24:04.580
We'll get into some specific details there,


00:24:04.580 --> 00:24:09.580
but probably the most relevant to this entire rewrite


00:24:09.580 --> 00:24:13.300
is this thing you're calling the Pydantic-Core.


00:24:13.300 --> 00:24:14.500
Yeah? - Yeah.


00:24:14.500 --> 00:24:18.060
So this started off as a kind of small experiment


00:24:18.060 --> 00:24:20.980
with me saying, what would, a kind of thought experiment,


00:24:20.980 --> 00:24:23.980
what would Pydantic look like


00:24:23.980 --> 00:24:25.200
if it was implemented in Rust?


00:24:25.200 --> 00:24:27.340
What would its internals look like


00:24:27.340 --> 00:24:29.060
if they were implemented in Rust?


00:24:29.060 --> 00:24:32.260
And that experiment effectively worked,


00:24:32.260 --> 00:24:34.820
and sure enough, Pydantic Core is written in Rust


00:24:34.820 --> 00:24:38.940
and does all of the core data validation,


00:24:38.940 --> 00:24:41.260
and it will do a lot of the serialization.


00:24:41.260 --> 00:24:42.100
I haven't built that yet,


00:24:42.100 --> 00:24:44.480
that I intend to build into Rust.


00:24:44.480 --> 00:24:47.140
So there's an awful lot that will stay in Python,


00:24:47.140 --> 00:24:51.300
but yeah, Pydantic Core is written in Rust


00:24:51.300 --> 00:24:55.820
and uses the amazing Py03 library to bindings


00:24:55.820 --> 00:25:00.820
to write Rust code that's callable from Python.


00:25:00.820 --> 00:25:02.740
- Yeah.


00:25:02.740 --> 00:25:05.260
Maybe tell people about Py03 real quick,


00:25:05.260 --> 00:25:09.400
because this is how you write the code in Rust,


00:25:09.400 --> 00:25:13.560
but then expose it to the rest of the Python aspects


00:25:13.560 --> 00:25:14.880
of Python, right?


00:25:14.880 --> 00:25:17.640
- Yeah, Py03, I'm not a good C developer


00:25:17.640 --> 00:25:18.920
and I'm gonna use the wrong terminology


00:25:18.920 --> 00:25:20.520
and be shouted at, but like,


00:25:20.520 --> 00:25:23.840
it takes the Python ABI for C,


00:25:23.840 --> 00:25:27.280
so how you would write C codes to be used from Python,


00:25:27.280 --> 00:25:29.720
and effectively makes that available in Rust.


00:25:29.720 --> 00:25:32.920
Rust has great interop with C,


00:25:32.920 --> 00:25:36.880
and so, yeah, it basically takes all those types


00:25:36.880 --> 00:25:41.880
and exposes them all in a type-safe way


00:25:41.880 --> 00:25:43.400
that you can then consume.


00:25:43.400 --> 00:25:45.520
So if we stop here and we look at like,


00:25:45.520 --> 00:25:49.440
Summers, a string, right?


00:25:49.440 --> 00:25:53.400
Where Py03 is taking care of all the hard work


00:25:53.400 --> 00:25:58.060
of you passing two ints from Python into this function,


00:25:58.060 --> 00:25:59.840
converting them to uSize,


00:25:59.840 --> 00:26:02.360
then the logic inside is pure Rust,


00:26:02.360 --> 00:26:03.560
it's adding two uSizes


00:26:03.560 --> 00:26:07.140
converting the result to a string,


00:26:07.140 --> 00:26:12.000
and then again, Py03 is taking care of returning it,


00:26:12.000 --> 00:26:15.520
and in particular, using this PyResult result type in Rust,


00:26:15.520 --> 00:26:17.240
without going too far down the rabbit hole


00:26:17.240 --> 00:26:20.560
of how Rust works, Rust has an amazing model


00:26:20.560 --> 00:26:22.440
for how to deal with errors,


00:26:22.440 --> 00:26:24.920
that basically stops you from ever ignoring an exception,


00:26:24.920 --> 00:26:26.720
or what they call an error,


00:26:26.720 --> 00:26:29.600
and that's these results, which are basically,


00:26:29.600 --> 00:26:32.480
they would call it an enum, but from Python world,


00:26:32.480 --> 00:26:35.020
think of it like a union, which is either okay,


00:26:35.020 --> 00:26:37.420
it went well or error, it was an error.


00:26:37.420 --> 00:26:39.340
And so you have to return an okay,


00:26:39.340 --> 00:26:40.860
or you have to return an error.


00:26:40.860 --> 00:26:42.200
And when you consume that in Rust,


00:26:42.200 --> 00:26:44.860
you have to deal with the error case.


00:26:44.860 --> 00:26:46.220
It won't let you ignore it.


00:26:46.220 --> 00:26:50.380
But that maps really nicely into Python exceptions.


00:26:50.380 --> 00:26:53.100
So here we're returning okay, so we'll get a result.


00:26:53.100 --> 00:26:56.240
But if we used py error and return that,


00:26:56.240 --> 00:26:57.420
then you would get an exception


00:26:57.420 --> 00:26:58.780
when you call the function.


00:26:58.780 --> 00:27:02.100
- Interesting.


00:27:02.100 --> 00:27:05.020
So the powerful thing about Rust,


00:27:05.020 --> 00:27:07.260
but obviously it's faster, everyone knows that,


00:27:07.260 --> 00:27:10.700
and it does mean the Pydantic core is much faster


00:27:10.700 --> 00:27:13.500
than Pydantic, and Pydantic 2 will be much faster


00:27:13.500 --> 00:27:14.820
than Pydantic 1.


00:27:14.820 --> 00:27:17.780
I think it's probably quite rare to see a library


00:27:17.780 --> 00:27:21.540
in a version update get significantly faster,


00:27:21.540 --> 00:27:25.180
let alone like 10 to 50 times faster as Pydantic 2 will be.


00:27:25.180 --> 00:27:28.180
So that's been achieved, but there are other advantages


00:27:28.180 --> 00:27:31.140
that you get which are perhaps less obvious.


00:27:31.140 --> 00:27:34.940
One of them is recursion without a performance penalty


00:27:34.940 --> 00:27:39.940
that means that Pydantic core data validation


00:27:39.940 --> 00:27:42.820
is truly recursive all the way down


00:27:42.820 --> 00:27:44.680
and allows you to build effectively


00:27:44.680 --> 00:27:48.060
any crazy combination of different validators


00:27:48.060 --> 00:27:48.900
into each other.


00:27:48.900 --> 00:27:51.740
Because validators are this basically pile of,


00:27:51.740 --> 00:27:54.320
think of them as classes in Python,


00:27:54.320 --> 00:27:55.980
they're not classes in Rust,


00:27:55.980 --> 00:27:58.860
but that call each other recursively all the way down.


00:27:58.860 --> 00:28:06.420
And you can, one of the other advantages is like tiny functions, which allow you to split


00:28:06.420 --> 00:28:10.780
code up and make it easier to edit one thing without breaking other things.


00:28:10.780 --> 00:28:15.700
Because in Python, it's not entirely obvious to people coming from languages like C, C


00:28:15.700 --> 00:28:22.020
sharp, Rust and so on that just calling a function itself is pretty expensive, relatively


00:28:22.020 --> 00:28:23.260
speaking in Python.


00:28:23.260 --> 00:28:27.820
Yeah, I'm on the wing of people who would say


00:28:27.820 --> 00:28:31.260
if you're worrying about the overhead of calling a function,


00:28:31.260 --> 00:28:33.740
you're probably not writing the right language most of the time.


00:28:33.740 --> 00:28:38.540
Yes, it's a big number, but it's a tiny number in most contexts.


00:28:38.540 --> 00:28:43.340
But I think there's definitely a world in which end users,


00:28:43.340 --> 00:28:45.260
people building web apps in Python,


00:28:45.260 --> 00:28:49.420
definitely for companies should and will be using Python.


00:28:49.420 --> 00:28:52.620
But the libraries that underpin that, that they use,


00:28:52.620 --> 00:28:54.620
There's big value.


00:28:54.620 --> 00:28:57.620
Value is a complex term in open source in itself,


00:28:57.620 --> 00:29:00.620
but let's use the word value and ignore what it might mean.


00:29:00.620 --> 00:29:03.620
In implementing those libraries, there's the second step down.


00:29:03.620 --> 00:29:08.620
So the Pydantic, the HTTP framework,


00:29:08.620 --> 00:29:14.620
in Rust, or in... I think in Rust, basically,


00:29:14.620 --> 00:29:18.620
because those are the... well, there are three libraries that have real bindings for Python.


00:29:18.620 --> 00:29:22.660
Python, C, I don't want to be writing lots of C


00:29:22.660 --> 00:29:25.060
and I don't think many people do.


00:29:25.060 --> 00:29:27.380
Well, I'll say that.


00:29:27.380 --> 00:29:30.260
Rust obviously, and then there's C++ and Boost.


00:29:30.260 --> 00:29:34.260
And I think the developers of Py03 came from using Boost


00:29:34.260 --> 00:29:37.980
and they basically built Py03 to be better.


00:29:37.980 --> 00:29:40.760
I've used Boost a bit,


00:29:40.760 --> 00:29:43.520
but I found Py03 to be really impressive.


00:29:43.520 --> 00:29:45.000
- Yeah.


00:29:45.000 --> 00:29:47.140
I think your comment about,


00:29:47.140 --> 00:29:49.460
should you be worrying about those loops is super relevant.


00:29:49.460 --> 00:29:52.220
There's certain libraries where Pynantic


00:29:52.220 --> 00:29:54.120
is certainly among them.


00:29:54.120 --> 00:29:59.120
It's used so much that these little tiny portions,


00:29:59.120 --> 00:30:01.280
probably just a very small slice of the code


00:30:01.280 --> 00:30:06.140
that is applicable is actually a pretty significant hit


00:30:06.140 --> 00:30:08.340
in terms of overall performance.


00:30:08.340 --> 00:30:10.060
You know, you think like SQLAlchemy


00:30:10.060 --> 00:30:12.620
and like the serialization, deserialization bit, right?


00:30:12.620 --> 00:30:14.020
That's a small part of the library,


00:30:14.020 --> 00:30:17.760
but that's something that just is omnipresent, right?


00:30:17.760 --> 00:30:20.500
And this internal validation and stuff


00:30:20.500 --> 00:30:22.460
that you're thinking about doing in PyO3


00:30:22.460 --> 00:30:24.840
or in Rust, combine it with PyO3,


00:30:24.840 --> 00:30:29.620
it makes a big difference even if it's only a small,


00:30:29.620 --> 00:30:31.520
relatively small portion of the part


00:30:31.520 --> 00:30:33.840
that people perceive it to be.


00:30:33.840 --> 00:30:37.580
- Exactly, and coming back to my environmental point,


00:30:37.580 --> 00:30:40.660
the environment doesn't care if you take a flight


00:30:40.660 --> 00:30:42.260
or I take a flight or I miss a flight,


00:30:42.260 --> 00:30:44.400
But obviously, the environment does


00:30:44.400 --> 00:30:47.440
care if we can reduce the number of flights taken worldwide


00:30:47.440 --> 00:30:48.120
by 10%.


00:30:48.120 --> 00:30:51.440
And because of Pydantic's widespread use,


00:30:51.440 --> 00:30:54.520
that's why I'm saying getting Pydantic to be 10% faster,


00:30:54.520 --> 00:30:56.640
you probably won't notice.


00:30:56.640 --> 00:31:01.680
But overall, we will hopefully make computation in the cloud


00:31:01.680 --> 00:31:05.520
a tiny bit faster.


00:31:05.520 --> 00:31:06.160
>>Absolutely.


00:31:09.440 --> 00:31:10.680
Question from the audience.


00:31:10.680 --> 00:31:14.080
Magnus says, will a user be able to write data validators


00:31:14.080 --> 00:31:15.840
in Rust for Pydantic 2?


00:31:15.840 --> 00:31:18.920
- That is a difficult and complex question.


00:31:18.920 --> 00:31:23.100
There is an open issue on Pydantic Core's issue tracker


00:31:23.100 --> 00:31:26.440
about it, and I have proposed a way


00:31:26.440 --> 00:31:28.000
that it might be possible.


00:31:28.000 --> 00:31:32.840
The story of shared libraries, DLLs, in Rust


00:31:32.840 --> 00:31:35.320
is not quite as pretty as it could be,


00:31:35.320 --> 00:31:37.760
and I really don't want to build, basically,


00:31:37.760 --> 00:31:40.120
another way of sharing dependencies beyond PyPI


00:31:40.120 --> 00:31:43.080
where you're like, okay, you need to install


00:31:43.080 --> 00:31:45.040
Pydantic from PyPI, then you need to install


00:31:45.040 --> 00:31:47.000
this other package, perhaps from PyPI,


00:31:47.000 --> 00:31:49.920
and then you need to use this other code to link the DLL


00:31:49.920 --> 00:31:51.400
so that we can do a, you know,


00:31:51.400 --> 00:31:53.840
dynamically link those libraries.


00:31:53.840 --> 00:31:57.280
That sounds like an enormous maintenance overhead


00:31:57.280 --> 00:32:00.160
for me and for people doing it


00:32:00.160 --> 00:32:02.640
because people find it hard enough to share code


00:32:02.640 --> 00:32:04.040
and use code from PyPI.


00:32:07.120 --> 00:32:09.000
- Yeah, then how do you deploy that


00:32:09.000 --> 00:32:10.240
and how do you get it compiled?


00:32:10.240 --> 00:32:14.460
- Right, so very briefly, my theory for an answer is,


00:32:14.460 --> 00:32:17.640
actually, I'm not gonna go down that rabbit hole right now,


00:32:17.640 --> 00:32:19.180
but there's an issue that I think explains it


00:32:19.180 --> 00:32:21.120
and I'm happy to talk about it there.


00:32:21.120 --> 00:32:22.480
- Sure, if you don't add it now,


00:32:22.480 --> 00:32:24.600
you don't have to live with the consequences


00:32:24.600 --> 00:32:25.440
of choosing that.


00:32:25.440 --> 00:32:26.320
- That's the other thing, right?


00:32:26.320 --> 00:32:28.200
That like someone comes along and has a really bright idea


00:32:28.200 --> 00:32:31.000
and in 10 years time, I'm still answering questions


00:32:31.000 --> 00:32:32.360
about how to make it work.


00:32:32.360 --> 00:32:33.600
- Yeah, exactly, okay.


00:32:33.600 --> 00:32:36.320
You already mentioned the performance,


00:32:36.320 --> 00:32:38.180
But just working our way through the plan here,


00:32:38.180 --> 00:32:40.260
the next step is to say,


00:32:40.260 --> 00:32:43.580
hey, the benchmarks indicate this is four to 50 times faster


00:32:43.580 --> 00:32:47.000
and in general, 17x is kind of what you're guessing


00:32:47.000 --> 00:32:49.500
for something reasonable.


00:32:49.500 --> 00:32:54.140
- And not guessing, as in just the benchmarks


00:32:54.140 --> 00:32:58.040
on Pydantic core that are run on every commit,


00:32:58.040 --> 00:33:03.040
a lot of them have alternate equivalents in Pydantic 1.9,


00:33:03.880 --> 00:33:06.220
And so that's the speed up that we're seeing.


00:33:06.220 --> 00:33:10.480
There are a few more optimizations I can make.


00:33:10.480 --> 00:33:14.340
There are a few, it'll get a tiny bit slower,


00:33:14.340 --> 00:33:16.580
I guess, when it's wrapped in Pydantic,


00:33:16.580 --> 00:33:18.220
in Python, but a tiny amount.


00:33:18.220 --> 00:33:20.920
So yeah, I think those are realistic numbers.


00:33:20.920 --> 00:33:22.920
- Yeah, that's a huge difference.


00:33:22.920 --> 00:33:25.840
Now you say when validating a model,


00:33:25.840 --> 00:33:28.820
how does that performance compare


00:33:28.820 --> 00:33:32.720
to creating a Pydantic class instance?


00:33:32.720 --> 00:33:36.740
you know, how much, how much faster does like using


00:33:36.740 --> 00:33:39.040
that in Python get versus.


00:33:39.040 --> 00:33:41.280
- 17 times faster doing the validation.


00:33:41.280 --> 00:33:42.200
You should get your model back.


00:33:42.200 --> 00:33:46.600
So that is going from a Python object,


00:33:46.600 --> 00:33:49.400
a Python dict let's say of your input data


00:33:49.400 --> 00:33:54.400
to a instantiated class instance, instance of your model.


00:33:54.400 --> 00:33:57.720
- Right, fantastic.


00:33:57.720 --> 00:33:59.780
Okay, that is really, really awesome.


00:33:59.780 --> 00:34:01.980
Next up is strict mode.


00:34:01.980 --> 00:34:09.180
One of the things I really like about Pydantic is how it will take data that is,


00:34:09.180 --> 00:34:12.980
could be the right thing, but it's not actually the right thing.


00:34:12.980 --> 00:34:17.380
Like you said, the string 1, 2, 3, but you really want an integer,


00:34:17.380 --> 00:34:19.180
the actual number 1, 2, 3.


00:34:19.180 --> 00:34:24.380
And it just says, you know, this is what we would do if I had to do it myself.


00:34:24.380 --> 00:34:27.780
I would parse the string and convert it over and so on.


00:34:27.780 --> 00:34:28.980
And that just happens.


00:34:28.980 --> 00:34:33.980
but some people don't want this clever behavior, right?


00:34:33.980 --> 00:34:36.160
- Yeah, exactly.


00:34:36.160 --> 00:34:38.980
And I think that there are legitimate cases for that.


00:34:38.980 --> 00:34:42.000
I think there are some people who are wanting it


00:34:42.000 --> 00:34:44.220
whose cases I don't think are entirely legitimate,


00:34:44.220 --> 00:34:47.180
but like, yeah, I totally get why in some contexts


00:34:47.180 --> 00:34:48.180
it's valuable.


00:34:48.180 --> 00:34:49.860
And so, yeah, so it's built in.


00:34:49.860 --> 00:34:53.580
Yeah, you have that switch from the word go.


00:34:53.580 --> 00:34:56.460
One of the really cool things that this solves


00:34:57.500 --> 00:35:01.980
kind of, not by mistake, but as a side effect,


00:35:01.980 --> 00:35:05.260
is validating unions.


00:35:05.260 --> 00:35:07.740
We basically run through every member of the union


00:35:07.740 --> 00:35:11.020
in strict mode first, and try and validate in strict mode,


00:35:11.020 --> 00:35:14.180
and then validate in lax mode.


00:35:14.180 --> 00:35:19.300
And therefore, for example, if you had a union of int


00:35:19.300 --> 00:35:24.420
and string, and then you passed it the string 1, 2, 3,


00:35:24.420 --> 00:35:26.460
it wouldn't get converted to int,


00:35:26.460 --> 00:35:30.020
as it would do in historically in Pydantic.


00:35:30.020 --> 00:35:34.020
Pydantic now has smart union, but like it's not perfect,


00:35:34.020 --> 00:35:36.500
but this solves some edge cases like that


00:35:36.500 --> 00:35:38.800
and some much more confusing ones than that.


00:35:38.800 --> 00:35:43.420
- Nice, related to that is I would say


00:35:43.420 --> 00:35:46.620
is this conversion table that you're putting out, right?


00:35:46.620 --> 00:35:47.780
What's the story here?


00:35:47.780 --> 00:35:48.800
- So there's two things.


00:35:48.800 --> 00:35:50.460
There's this like, I kind of called it


00:35:50.460 --> 00:35:51.660
cod philosophy the other day,


00:35:51.660 --> 00:35:56.260
like this like rule for when you would convert something


00:35:56.260 --> 00:36:00.660
when you wouldn't. And actually it's come out to be really useful in us thinking about when we


00:36:00.660 --> 00:36:06.900
shouldn't convert things, because to take an example we have been in Pynantic v1, you can


00:36:06.900 --> 00:36:12.900
coerce a set to a list and that mostly seems to make sense and it's something that you might want


00:36:12.900 --> 00:36:19.140
to do in lots of contexts, but actually if you go up a bit the single and intuitive means we can't


00:36:19.140 --> 00:36:24.900
convert a set to a list because you don't always get the same output when you convert a set to a


00:36:24.900 --> 00:36:27.780
because the order of things can change.


00:36:27.780 --> 00:36:30.180
And so using this rule has been helpful


00:36:30.180 --> 00:36:33.440
in trying to be more consistent about what we convert.


00:36:33.440 --> 00:36:35.900
But I'm the first to put my hand up and say,


00:36:35.900 --> 00:36:37.100
this rule is not perfect,


00:36:37.100 --> 00:36:39.600
there are always going to have to be exceptions to it.


00:36:39.600 --> 00:36:43.820
And at the bottom of this blog post,


00:36:43.820 --> 00:36:45.900
but then properly on the docs completed,


00:36:45.900 --> 00:36:48.100
will be a full on table of everything


00:36:48.100 --> 00:36:50.780
and what gets converted and what doesn't in Lax mode.


00:36:50.780 --> 00:36:53.220
So you can look it up rather than having to guess.


00:36:54.260 --> 00:36:56.580
Before we move off strict mode,


00:36:56.580 --> 00:37:01.600
Klutz just has some kind things to say about PyTanix


00:37:01.600 --> 00:37:04.980
as it's one of the most useful packages ever, congrats.


00:37:04.980 --> 00:37:05.820
- That's really good, sorry.


00:37:05.820 --> 00:37:06.660
- But Magnus,


00:37:06.660 --> 00:37:12.780
Magnus asks, is strict mode a global or a per model setting


00:37:12.780 --> 00:37:16.340
or is it a usage when you actually do the parsing?


00:37:16.340 --> 00:37:17.420
Where do you set this?


00:37:17.420 --> 00:37:19.060
- It's actually more powerful than that.


00:37:19.060 --> 00:37:23.260
It is either on a field


00:37:23.260 --> 00:37:27.940
or on an entire model, and you can set it at validation time.


00:37:27.940 --> 00:37:30.660
So you can configure it in config


00:37:30.660 --> 00:37:32.060
and configure it on a particular field,


00:37:32.060 --> 00:37:33.580
and then you can override it


00:37:33.580 --> 00:37:37.500
when you're effectively calling the validator.


00:37:37.500 --> 00:37:39.100
- I see, maybe there's some situation


00:37:39.100 --> 00:37:41.860
where you're loading old bad data


00:37:41.860 --> 00:37:44.600
or something you wanna say, go ahead and do this,


00:37:44.600 --> 00:37:46.260
but in the future, we're not accepting it,


00:37:46.260 --> 00:37:47.300
something like that.


00:37:47.300 --> 00:37:49.260
- Right, and actually, one of the reasons I built that


00:37:49.260 --> 00:37:50.480
was to use it in the union,


00:37:50.480 --> 00:37:53.360
because we go through the validators the first time


00:37:53.360 --> 00:37:56.360
at validation time, insisting on strict mode.


00:37:56.360 --> 00:37:59.440
But yeah, one of the other cases


00:37:59.440 --> 00:38:00.600
which will come up somewhere down here


00:38:00.600 --> 00:38:02.600
is we now have a isInstance


00:38:02.600 --> 00:38:04.560
or a like pseudo isInstance method,


00:38:04.560 --> 00:38:08.440
which confirms whether data matches our model.


00:38:08.440 --> 00:38:11.080
And there we automatically use strict mode


00:38:11.080 --> 00:38:12.440
'cause for me, it's kind of obvious


00:38:12.440 --> 00:38:14.040
that if you're doing isInstance,


00:38:14.040 --> 00:38:16.840
you want that to be strict.


00:38:16.840 --> 00:38:18.320
- Yeah.


00:38:18.320 --> 00:38:21.180
All right, moving on to the next part of the plan


00:38:21.180 --> 00:38:24.160
is built-in JSON support.


00:38:24.160 --> 00:38:25.000
- Yes, so this is-


00:38:25.000 --> 00:38:26.480
- What are we talking about here?


00:38:26.480 --> 00:38:29.120
- So we're talking about parsing JSON in Rust


00:38:29.120 --> 00:38:33.080
and parsing that JSON object straight in,


00:38:33.080 --> 00:38:37.600
within, internally within the library to the validator


00:38:37.600 --> 00:38:39.520
to then do the validation.


00:38:39.520 --> 00:38:41.120
One of the big advantages that has


00:38:41.120 --> 00:38:43.200
is it solves the strict mode problem.


00:38:43.200 --> 00:38:45.020
So if you looked above,


00:38:45.020 --> 00:38:47.440
let's say we have the string of a date,


00:38:47.440 --> 00:38:52.440
let's say an ISO 8601 date of year, month, day.


00:38:52.440 --> 00:38:55.740
In JSON, it's obvious that that should be validated


00:38:55.740 --> 00:38:58.640
as a date, but if you pass that in from a Python object,


00:38:58.640 --> 00:39:00.080
it's not valid in strict mode, right?


00:39:00.080 --> 00:39:02.780
That's not, that doesn't look anything like a date.


00:39:02.780 --> 00:39:04.560
The problem if we had strict mode


00:39:04.560 --> 00:39:07.560
without the built-in JSON validation is


00:39:07.560 --> 00:39:10.360
you can't pass JSON with a date in it.


00:39:10.360 --> 00:39:14.000
- There's no scenario where directly going from JSON works


00:39:14.000 --> 00:39:18.880
Because JSON, for odd reasons, has no concept.


00:39:18.880 --> 00:39:20.800
- It doesn't have date, but it also doesn't have set


00:39:20.800 --> 00:39:23.480
or bytes or loads of stuff that you want to use in Python.


00:39:23.480 --> 00:39:27.600
So one of the things that built-in JSON support gives us,


00:39:27.600 --> 00:39:29.700
as well as obviously a performance premium,


00:39:29.700 --> 00:39:36.160
is that we can be sensible and say


00:39:36.160 --> 00:39:41.160
that ISO-8601 date is a valid date in strict mode


00:39:41.160 --> 00:39:43.640
if it's coming from JSON, but not from Python.


00:39:43.640 --> 00:39:47.760
- Okay, yeah, and also just makes it faster, right?


00:39:47.760 --> 00:39:52.180
Because probably parsing JSON and Rust is pretty quick.


00:39:52.180 --> 00:39:53.900
- It's really, it's fast,


00:39:53.900 --> 00:39:58.860
but also we don't have to create a Python dict


00:39:58.860 --> 00:40:01.000
and a Python list and all those Python types.


00:40:01.000 --> 00:40:03.980
Creating Python strings has like some significant overhead


00:40:03.980 --> 00:40:08.980
compared to creating a string in Rust.


00:40:08.980 --> 00:40:13.400
And in future, once I've got V2 out,


00:40:13.400 --> 00:40:15.240
I intend to build a custom JSON parser,


00:40:15.240 --> 00:40:18.360
which is even faster and will give us line numbers in errors,


00:40:18.360 --> 00:40:19.760
which would be really nice,


00:40:19.760 --> 00:40:22.680
'cause we don't have that now and we can't do that in V2


00:40:22.680 --> 00:40:25.240
because src/json, which I'm using,


00:40:25.240 --> 00:40:26.360
doesn't provide line numbers,


00:40:26.360 --> 00:40:29.200
but I hope in V2.1 or something,


00:40:29.200 --> 00:40:31.200
we will be able to add that.


00:40:31.200 --> 00:40:33.440
- Yeah, amazing.


00:40:33.440 --> 00:40:36.400
Really quick on the strict stuff as well.


00:40:36.400 --> 00:40:39.720
Manoj asks, "What about strict int as a type?


00:40:39.720 --> 00:40:41.400
Is it gonna be still around?"


00:40:41.400 --> 00:40:43.120
- That can stay around 'cause that will just be,


00:40:43.120 --> 00:40:44.780
That'll be effectively,


00:40:44.780 --> 00:40:47.120
so it's probably worth at this stage for people,


00:40:47.120 --> 00:40:50.080
if you could just go to Pydantic Cores repo


00:40:50.080 --> 00:40:55.080
and we'll have a really brief look at what it looks like.


00:40:55.080 --> 00:41:04.080
Yeah, and then just in the readme, you'll see a example.


00:41:04.080 --> 00:41:05.360
So you see here, right?


00:41:05.360 --> 00:41:06.600
We up a bit.


00:41:06.600 --> 00:41:10.240
You don't need to go into all the details of it,


00:41:10.240 --> 00:41:13.620
So the way that we define the model in Pydantic core


00:41:13.620 --> 00:41:17.100
is with this kind of micro schema, which


00:41:17.100 --> 00:41:19.780
is defining, in this case, a type dict


00:41:19.780 --> 00:41:23.020
with a bunch of fields in it.


00:41:23.020 --> 00:41:25.660
And here, on a particular field, we could say strict true.


00:41:25.660 --> 00:41:28.460
So let's say on the int field, we could say strict true.


00:41:28.460 --> 00:41:30.620
And that field will be strict, while the rest isn't.


00:41:30.620 --> 00:41:34.860
So obviously, what strict int the Pydantic type will do,


00:41:34.860 --> 00:41:39.520
when it becomes a schema, it will set strict to true


00:41:39.520 --> 00:41:41.120
on that particular field.


00:41:41.120 --> 00:41:41.960
- Got it.


00:41:41.960 --> 00:41:45.960
So effectively is a synonym for the more general way


00:41:45.960 --> 00:41:49.640
to say use strict mode, but only on this field, right?


00:41:49.640 --> 00:41:51.120
- Yeah, exactly.


00:41:51.120 --> 00:41:54.040
It's just a marker effectively sets strict on this field.


00:41:54.040 --> 00:41:55.080
- Yeah, exactly.


00:41:55.080 --> 00:41:59.000
So in Pydantic, you can say I have, say an age,


00:41:59.000 --> 00:42:00.040
which is an int,


00:42:00.040 --> 00:42:04.620
and you can set it to a default value like zero,


00:42:04.620 --> 00:42:06.760
or you could say it's optional, set it to none,


00:42:06.760 --> 00:42:08.780
but you can also set it to a field, right?


00:42:08.780 --> 00:42:10.220
where you have additional information.


00:42:10.220 --> 00:42:11.860
Is that how you set strict mode?


00:42:11.860 --> 00:42:14.260
Do you set it to a field and say strict mode equals true


00:42:14.260 --> 00:42:15.860
or something like that more generally?


00:42:15.860 --> 00:42:17.700
- It's not built yet, so it's up for debate.


00:42:17.700 --> 00:42:20.420
But yeah, effectively strict will be a setting on field


00:42:20.420 --> 00:42:22.100
and obviously on config as well.


00:42:22.100 --> 00:42:24.420
And there will be these types


00:42:24.420 --> 00:42:26.660
which basically contain some extra information


00:42:26.660 --> 00:42:29.660
like strict int will just like set that strict to true


00:42:29.660 --> 00:42:31.140
for that field. - Right, exactly.


00:42:31.140 --> 00:42:32.820
And for people who are not aware,


00:42:32.820 --> 00:42:35.900
config is an inner class of the Pydantic model


00:42:35.900 --> 00:42:38.180
that has a bunch of settings you can set, right?


00:42:38.180 --> 00:42:40.260
- Yeah, and people do some unholy stuff


00:42:40.260 --> 00:42:42.620
of like modifying the base version of config


00:42:42.620 --> 00:42:45.500
and therefore doing global stuff, which I've never done.


00:42:45.500 --> 00:42:47.100
People seem to make it work.


00:42:47.100 --> 00:42:48.540
I don't know if it'll work in V2.


00:42:48.540 --> 00:42:50.380
I don't promise it will.


00:42:50.380 --> 00:42:51.540
- Yeah, absolutely.


00:42:51.540 --> 00:42:53.340
One of the things that's interesting


00:42:53.340 --> 00:42:55.220
with this Pydantic core is now


00:42:55.220 --> 00:42:58.540
this is a dependency of Pydantic, right?


00:42:58.540 --> 00:42:59.380
- Yeah.


00:42:59.380 --> 00:43:02.260
- And people could use it directly if they wanted, right?


00:43:02.260 --> 00:43:04.060
Like validating without a model,


00:43:04.060 --> 00:43:06.500
you don't have to define a class or any of those things.


00:43:06.500 --> 00:43:08.980
100%, you don't have to define the class.


00:43:08.980 --> 00:43:11.300
If we look in the example we were using there,


00:43:11.300 --> 00:43:12.220
we didn't have a class,


00:43:12.220 --> 00:43:14.740
we were just validating to a type dict,


00:43:14.740 --> 00:43:16.580
so we would get back a dict,


00:43:16.580 --> 00:43:20.020
which obviously means we have full support


00:43:20.020 --> 00:43:22.620
for typing's type dict type.


00:43:22.620 --> 00:43:25.460
It's also a little bit faster than creating a model


00:43:25.460 --> 00:43:29.540
'cause we don't have to create the class instance,


00:43:29.540 --> 00:43:31.740
we just create the dict that goes inside it.


00:43:31.740 --> 00:43:35.300
Yeah, people could use it without.


00:43:35.300 --> 00:43:39.300
The only concern, obviously, is whether or not,


00:43:39.300 --> 00:43:42.380
like, obviously it's now compiled,


00:43:42.380 --> 00:43:45.380
and you have to be able to run that Rust code


00:43:45.380 --> 00:43:47.100
to be able to use Pydantic.


00:43:47.100 --> 00:43:51.480
With the v0.1 release of Pydantic Core yesterday,


00:43:51.480 --> 00:43:53.460
we have, I think, off the top of my head,


00:43:53.460 --> 00:43:55.220
56 different binaries that we released


00:43:55.220 --> 00:43:57.280
for different environments.


00:43:57.280 --> 00:43:59.960
The team of the guys at Py03 and at Maturin,


00:43:59.960 --> 00:44:01.820
which is their way of building,


00:44:01.820 --> 00:44:04.460
have been super helpful,


00:44:04.460 --> 00:44:08.460
and we'll continue to support, so it doesn't worry me.


00:44:08.460 --> 00:44:13.200
We already have the full Pydantic core set of unit tests


00:44:13.200 --> 00:44:16.840
running in the browser via WebAssembly.


00:44:16.840 --> 00:44:18.900
So obviously Python moving into the browser


00:44:18.900 --> 00:44:20.860
with WebAssembly is like the big new thing.


00:44:20.860 --> 00:44:22.020
I'm really excited about it.


00:44:22.020 --> 00:44:23.940
I wanted Pydantic core to work.


00:44:23.940 --> 00:44:28.940
And so Hud, who's one of the Pyodide maintainers,


00:44:28.940 --> 00:44:31.260
I met at PyCon, he's been super helpful


00:44:31.260 --> 00:44:33.200
actually with Pydantic core in general,


00:44:33.200 --> 00:44:35.220
but particularly with getting it to work.


00:44:35.220 --> 00:44:36.600
At the risk of running a live demo,


00:44:36.600 --> 00:44:39.840
if you just go back to Pydantic Core,


00:44:39.840 --> 00:44:41.880
I know it's slightly changing subject,


00:44:41.880 --> 00:44:44.220
but I have to show you this because it makes me really excited.


00:44:44.220 --> 00:44:46.120
We go up and you go into Wasm Preview,


00:44:46.120 --> 00:44:47.640
which is one of the directories.


00:44:47.640 --> 00:44:49.840
>> Yeah, Wasm Preview.


00:44:49.840 --> 00:44:52.200
>> Then hit the index?


00:44:52.200 --> 00:44:56.320
>> No, if you click here, which just basically renders that index file.


00:44:56.320 --> 00:44:58.640
I hope it works.


00:44:58.640 --> 00:45:00.120
>> It'll work.


00:45:00.120 --> 00:45:01.880
>> It's got to work.


00:45:01.880 --> 00:45:03.800
It's got to work.


00:45:03.800 --> 00:45:07.000
This is it downloading the binary,


00:45:07.000 --> 00:45:09.240
downloading all the unit tests, extracting them in Python,


00:45:09.240 --> 00:45:12.660
and running the full test suite in the browser.


00:45:12.660 --> 00:45:15.280
- Let me try it one more time.


00:45:15.280 --> 00:45:17.280
Do it a second time.


00:45:17.280 --> 00:45:19.960
Yeah, so what we're seeing, if you click on this link,


00:45:19.960 --> 00:45:22.060
which I'll put in the show notes,


00:45:22.060 --> 00:45:27.060
is it downloads the CPython runtime and WebAssembly


00:45:27.060 --> 00:45:29.500
based on Pyodide, I'm guessing.


00:45:29.500 --> 00:45:30.640
- Yep.


00:45:30.640 --> 00:45:35.000
And then it downloads the archive zip,


00:45:35.000 --> 00:45:38.960
sends that to Python.


00:45:38.960 --> 00:45:40.960
Obviously we're running full CPython in the browser,


00:45:40.960 --> 00:45:45.800
so we can use the zip package to extract the zip,


00:45:45.800 --> 00:45:47.720
extract that into the virtual file system


00:45:47.720 --> 00:45:50.680
that Inscription gives us.


00:45:50.680 --> 00:45:55.680
Then we install the WASM32 wheel.


00:45:55.680 --> 00:45:57.840
We basically do pip install, well, micro pip,


00:45:57.840 --> 00:45:59.440
which is the way of installing stuff.


00:45:59.440 --> 00:46:01.460
and then we just call pytest and off it goes


00:46:01.460 --> 00:46:02.500
and it runs the tests.


00:46:02.500 --> 00:46:06.360
- Yeah, see the test come by standard colorized pytest output


00:46:06.360 --> 00:46:11.360
1,465 tests pass in five seconds.


00:46:11.360 --> 00:46:12.480
Pretty fantastic.


00:46:12.480 --> 00:46:15.740
- So it is a bit slower this than full CPython,


00:46:15.740 --> 00:46:19.980
but I'm still like really stoked for what this is gonna mean


00:46:19.980 --> 00:46:24.160
to the future of Python and particularly to stuff


00:46:24.160 --> 00:46:25.860
like the context where you might use Pydantic


00:46:25.860 --> 00:46:27.360
of data processing and stuff.


00:46:27.360 --> 00:46:30.260
I don't think Python is gonna replace React,


00:46:30.260 --> 00:46:32.560
and I think it's a bit daft of people to suggest it will,


00:46:32.560 --> 00:46:33.960
'cause that's just gonna lead to disappointment,


00:46:33.960 --> 00:46:37.040
but in context like this, it's gonna be super valuable.


00:46:37.040 --> 00:46:39.280
One of the things I'm really looking forward to


00:46:39.280 --> 00:46:42.760
is Pydantic 2's documentation.


00:46:42.760 --> 00:46:45.040
Every single example is gonna be executable.


00:46:45.040 --> 00:46:47.520
So you can edit it and you can press run


00:46:47.520 --> 00:46:50.360
right inside the browser, which I think should help a lot.


00:46:50.360 --> 00:46:51.480
- Yeah, fantastic.


00:46:51.480 --> 00:46:53.720
Have you been tracking PyScript?


00:46:55.140 --> 00:46:57.380
Yeah, I have been tracking PyScript.


00:46:57.380 --> 00:46:58.980
It's obviously, it's very cool.


00:46:58.980 --> 00:47:00.540
It's wrapping Pyodide,


00:47:00.540 --> 00:47:03.260
which is where all the genius work is going on.


00:47:03.260 --> 00:47:04.520
I'm using Pyodide directly,


00:47:04.520 --> 00:47:06.700
and I think I can continue to do that.


00:47:06.700 --> 00:47:09.420
But yeah, it's providing a bit of a,


00:47:09.420 --> 00:47:11.220
like, yeah, a super helpful wrapper


00:47:11.220 --> 00:47:15.180
for those who find, yeah, need a bit more help,


00:47:15.180 --> 00:47:17.940
and it's simple as a script tag.


00:47:17.940 --> 00:47:20.300
- Yeah, okay.


00:47:20.300 --> 00:47:22.480
Let's see.


00:47:24.940 --> 00:47:28.380
- Yeah, question from David out in the audience asks,


00:47:28.380 --> 00:47:30.480
with at least two year projects switching to Rust,


00:47:30.480 --> 00:47:32.220
PyDandic and watch files,


00:47:32.220 --> 00:47:35.180
do you see it as a general trend in the Python ecosystem?


00:47:35.180 --> 00:47:38.820
You know, in things like PyScript, which I just pulled up.


00:47:38.820 --> 00:47:40.220
- I have a third one actually, rtoml,


00:47:40.220 --> 00:47:43.820
which is a wrapper around the Rust toml library,


00:47:43.820 --> 00:47:45.100
which is a bit less necessary now


00:47:45.100 --> 00:47:46.820
when there is better toml support in Python,


00:47:46.820 --> 00:47:47.660
but a couple of years ago


00:47:47.660 --> 00:47:50.660
when the main toml package was not working for me,


00:47:50.660 --> 00:47:52.140
I wrapped that.


00:47:52.140 --> 00:47:53.700
Yes, I do.


00:47:53.700 --> 00:47:58.640
I was saying earlier that I think lots of the low-level tools


00:47:58.640 --> 00:48:01.460
should be written in Rust.


00:48:01.460 --> 00:48:03.660
There is a massive space for someone to go out and build


00:48:03.660 --> 00:48:09.580
a raging fast ASGI framework in Rust,


00:48:09.580 --> 00:48:11.740
and obviously use a Rust web framework


00:48:11.740 --> 00:48:15.660
and just provide ASGI interface.


00:48:15.660 --> 00:48:18.180
I'm looking forward to someone doing that


00:48:18.180 --> 00:48:20.180
to replace the lots of uVehicle.


00:48:20.180 --> 00:48:22.820
Not that-- uVehicle is great.


00:48:22.820 --> 00:48:25.220
It uses watch files, in fact, so not to criticize them,


00:48:25.220 --> 00:48:28.580
but yeah, there are a bunch of low-level stuff


00:48:28.580 --> 00:48:30.740
where performance matters, which totally,


00:48:30.740 --> 00:48:34.940
and I think should and will end up being more in Rust.


00:48:34.940 --> 00:48:39.140
- So you're suggesting something like


00:48:39.140 --> 00:48:42.140
what you have for Flask, but everything is Rust,


00:48:42.140 --> 00:48:44.980
except for just your view methods happen to be Python,


00:48:44.980 --> 00:48:48.500
and click that together with Py03 or something like that.


00:48:48.500 --> 00:48:51.460
- That's the ultimate place to go to.


00:48:51.460 --> 00:48:53.840
I think that the place to start would be,


00:48:53.840 --> 00:48:56.700
so we have WSGI, which many of you will have heard of,


00:48:56.700 --> 00:48:58.160
which Flask and Django run on.


00:48:58.160 --> 00:49:01.800
We have ASGI, which is the async equivalent,


00:49:01.800 --> 00:49:04.080
which is basically, it's great,


00:49:04.080 --> 00:49:06.400
because it means that to build a web framework,


00:49:06.400 --> 00:49:08.080
you don't have to deal with HTTP,


00:49:08.080 --> 00:49:11.360
you deal with a dict, which has basically got fields


00:49:11.360 --> 00:49:12.540
and body and stuff like that, right?


00:49:12.540 --> 00:49:14.680
And some function to get the rest of the body


00:49:14.680 --> 00:49:16.660
in the async case.


00:49:16.660 --> 00:49:17.500
And that's what we have now,


00:49:17.500 --> 00:49:19.640
and we have like Starlette and uVehicle,


00:49:19.640 --> 00:49:21.880
which are both built by Encode and are both great,


00:49:21.880 --> 00:49:24.600
but they have a separation by using this consistent


00:49:24.600 --> 00:49:28.280
protocol in between.


00:49:28.280 --> 00:49:31.640
And that allows really cool innovation on both sides.


00:49:31.640 --> 00:49:35.120
My suggestion is we don't have to get rid of the Starlet


00:49:35.120 --> 00:49:36.720
or the FastAPI or that level,


00:49:36.720 --> 00:49:39.560
but we could do lots of the low-level HTTP parsing


00:49:39.560 --> 00:49:43.480
yeah, in Rust.


00:49:43.480 --> 00:49:45.120
Before I get shouted down,


00:49:45.120 --> 00:49:48.840
I'm sure that uveicorn and other such libraries


00:49:48.840 --> 00:49:52.360
are in turn using some optimized C


00:49:52.360 --> 00:49:54.800
for passing some of the HTTP requests.


00:49:54.800 --> 00:49:58.000
So I don't have a number for the speed up, but.


00:49:58.000 --> 00:49:59.000
- Right.


00:49:59.000 --> 00:50:01.600
Okay, but yeah, that's a very interesting idea.


00:50:01.600 --> 00:50:05.360
One thing I did wanna sort of touch on here is you have,


00:50:05.360 --> 00:50:08.080
you talk about how there's not going to be


00:50:08.080 --> 00:50:11.560
a pure Python implementation of the Pydantic core


00:50:11.560 --> 00:50:16.520
because it's already this complex specialized thing in Rust


00:50:16.520 --> 00:50:20.320
and why do it again in Python,


00:50:20.320 --> 00:50:23.160
just so there might be some edge case of where it'll run.


00:50:23.160 --> 00:50:26.120
Talk about maybe the platforms really quick


00:50:26.120 --> 00:50:26.960
that's supported for,


00:50:26.960 --> 00:50:29.400
the WebAssembly one we just spoke about, which is fantastic.


00:50:29.400 --> 00:50:31.920
And I think that's gonna open up a lot of possibilities


00:50:31.920 --> 00:50:33.560
the more stuff we have in WebAssembly,


00:50:33.560 --> 00:50:36.640
but there shouldn't be a big problem with this, right?


00:50:36.640 --> 00:50:37.620
That it's-- - There shouldn't.


00:50:37.620 --> 00:50:39.000
I think with what we have there,


00:50:39.000 --> 00:50:40.880
we've covered the 99%,


00:50:40.880 --> 00:50:44.000
we're probably into the 99.9% of platforms covered


00:50:44.000 --> 00:50:46.880
where people actually want to use this.


00:50:46.880 --> 00:50:50.040
The only place where I know that there's a slight challenge


00:50:50.040 --> 00:50:55.480
is on Raspberry Pi, where the normal install of Raspberry


00:50:55.480 --> 00:50:59.920
and/or whatever it's called uses their own wheelhouse


00:50:59.920 --> 00:51:02.360
effectively for installing wheels, which doesn't yet


00:51:02.360 --> 00:51:04.440
support build of Rust.


00:51:04.440 --> 00:51:06.680
I'm sure it will one day, and you can just tell it to use


00:51:06.680 --> 00:51:08.640
PyPI, and it will work.


00:51:08.640 --> 00:51:11.400
Again, this is the kind of thing where having built watch files


00:51:11.400 --> 00:51:13.040
and distributed that, I've worked


00:51:13.040 --> 00:51:14.760
through a lot of these problems,


00:51:14.760 --> 00:51:16.440
and I'm pretty confident we're not gonna find


00:51:16.440 --> 00:51:18.240
some really important framework,


00:51:18.240 --> 00:51:19.640
sorry, really important environment


00:51:19.640 --> 00:51:21.720
where it's just not gonna work.


00:51:21.720 --> 00:51:24.920
And again, as more packages adopt Rust,


00:51:24.920 --> 00:51:27.200
we'll smooth out those problems,


00:51:27.200 --> 00:51:28.040
we'll learn from them,


00:51:28.040 --> 00:51:30.480
and we'll be able to fix the edge cases.


00:51:30.480 --> 00:51:31.360
- Yeah.


00:51:31.360 --> 00:51:33.880
One benefit of that is previously,


00:51:33.880 --> 00:51:38.540
Pydantic itself had some Cython and other things


00:51:38.540 --> 00:51:41.260
where it needed to be faster,


00:51:41.260 --> 00:51:44.300
but because now it can just use the PyDandic core,


00:51:44.300 --> 00:51:46.660
what's left over is pure Python, right?


00:51:46.660 --> 00:51:48.140
- Right, and one of the big problem,


00:51:48.140 --> 00:51:49.060
well, there were two problems with that.


00:51:49.060 --> 00:51:51.380
It made the development process a bit slow


00:51:51.380 --> 00:51:54.340
because we basically took vanilla Python,


00:51:54.340 --> 00:51:55.460
we compiled it with Cython,


00:51:55.460 --> 00:51:57.420
and we got a kind of 50% speed up,


00:51:57.420 --> 00:51:59.820
and we have to do some slightly weird things.


00:51:59.820 --> 00:52:02.580
So occasionally you have to return union of just string


00:52:02.580 --> 00:52:05.340
to prevent Cython from casting that string


00:52:05.340 --> 00:52:08.860
to a native string and losing substrings, stuff like that.


00:52:08.860 --> 00:52:11.620
Some weird edge cases that bite people occasionally.


00:52:11.620 --> 00:52:15.540
But the biggest problem is that that means


00:52:15.540 --> 00:52:17.980
that the Pydantic binaries are massive


00:52:17.980 --> 00:52:21.300
because the Cython compiled versions


00:52:21.300 --> 00:52:23.600
of Python code get really big.


00:52:23.600 --> 00:52:27.060
And obviously moving the performance critical bit


00:52:27.060 --> 00:52:28.860
into Pydantic core gets rid of that concern


00:52:28.860 --> 00:52:32.060
and Pydantic itself becomes a pure Python package,


00:52:32.060 --> 00:52:34.440
easier to hack on, CI will run faster,


00:52:34.440 --> 00:52:36.260
the whole process should be sped up


00:52:36.260 --> 00:52:37.900
and it'll be much smaller.


00:52:37.900 --> 00:52:39.680
- Yeah, it'd be more approachable, right?


00:52:39.680 --> 00:52:42.040
People, they wanna contribute to it and so on.


00:52:42.040 --> 00:52:47.760
One thing that I did wanna ask,


00:52:47.760 --> 00:52:51.360
well, let's see, losing track of my thought here


00:52:51.360 --> 00:52:53.280
on this one, but no, I know, I know.


00:52:53.280 --> 00:52:55.280
I had something I wanted to ask you


00:52:55.280 --> 00:52:58.240
about the binary version here.


00:52:58.240 --> 00:53:00.360
Oh well, we'll move on,


00:53:00.360 --> 00:53:02.080
'cause I can't remember what I was gonna ask you.


00:53:02.080 --> 00:53:03.880
But let's give, I jumped around,


00:53:03.880 --> 00:53:06.200
'cause I did wanna talk about this compiled stuff,


00:53:06.200 --> 00:53:08.200
You'll just get that as a wheel.


00:53:08.200 --> 00:53:12.660
Almost everybody, they won't really know or care.


00:53:12.660 --> 00:53:14.980
They just pip install it, it doesn't matter that it's Rust,


00:53:14.980 --> 00:53:16.980
it just downloads as a binary.


00:53:16.980 --> 00:53:19.980
Exactly. Same as loads of packages you use now.


00:53:19.980 --> 00:53:21.980
NumPy and whatever.


00:53:21.980 --> 00:53:23.980
They're all compiled.


00:53:23.980 --> 00:53:25.980
If there is no wheel available,


00:53:25.980 --> 00:53:29.640
then pip will do its very best to try and compile that for you.


00:53:29.640 --> 00:53:31.640
In the case of Pydantic Core,


00:53:31.640 --> 00:53:35.040
if you were in some crazy environment


00:53:35.040 --> 00:53:37.780
where we didn't have a binary, you need Rust installed,


00:53:37.780 --> 00:53:40.280
and then pip will take care of compiling it for you.


00:53:40.280 --> 00:53:43.020
But like I said, that's going to be super rare.


00:53:43.020 --> 00:53:44.680
And realistically, if you have that problem,


00:53:44.680 --> 00:53:47.380
come and create an issue and we'll add the binary for you.


00:53:47.380 --> 00:53:50.020
Sure. Okay.


00:53:50.020 --> 00:53:52.640
Picking up back on the plan here,


00:53:52.640 --> 00:53:56.320
you have required versus nullable changes?


00:53:56.320 --> 00:53:59.320
We missed out one of the really cool things above.


00:53:59.320 --> 00:54:01.240
I don't know if I saw it, if we're moving order,


00:54:01.240 --> 00:54:04.880
which is the removing of the necessity for a model.


00:54:04.880 --> 00:54:08.640
- Right. - So as we saw earlier


00:54:08.640 --> 00:54:13.000
in the Pydantic Core example, we can validate.


00:54:13.000 --> 00:54:15.840
So in Pydantic 1, everything was in the end


00:54:15.840 --> 00:54:16.680
a Pydantic model.


00:54:16.680 --> 00:54:20.240
So we looked earlier at FastAPI passing parameters.


00:54:20.240 --> 00:54:22.840
In the background, FastAPI is creating a model,


00:54:22.840 --> 00:54:24.700
doing the validation against that,


00:54:24.700 --> 00:54:26.160
then extracting stuff from the model


00:54:26.160 --> 00:54:28.560
and passing it to the function or whatever else.


00:54:28.560 --> 00:54:32.240
Similarly, if you wanted to parse a type dict,


00:54:32.240 --> 00:54:33.640
you basically, somewhere in the background,


00:54:33.640 --> 00:54:35.840
as a model, we validate against that model,


00:54:35.840 --> 00:54:37.520
then we take the dict from that model


00:54:37.520 --> 00:54:39.200
and pass it back to the user.


00:54:39.200 --> 00:54:42.920
That had some really confusing and annoying edge cases,


00:54:42.920 --> 00:54:44.740
but obviously the main thing was it did have


00:54:44.740 --> 00:54:46.080
a performance impact.


00:54:46.080 --> 00:54:49.320
Now there is no fundamental kind of base type


00:54:49.320 --> 00:54:52.080
in Pylantic core.


00:54:52.080 --> 00:54:54.760
You can validate an int or a string


00:54:54.760 --> 00:54:56.960
or a union of different stuff or a model


00:54:56.960 --> 00:54:59.040
or a data class or a type dict,


00:54:59.040 --> 00:55:01.660
and you just create your schema and off you go.


00:55:02.760 --> 00:55:07.040
Fantastic. So basically, there's this low-level fast engine


00:55:07.040 --> 00:55:09.880
that will just validate all sorts of things


00:55:09.880 --> 00:55:11.720
if you want to use it directly, right?


00:55:11.720 --> 00:55:14.440
Yeah. And one thing important to add just while we're on that


00:55:14.440 --> 00:55:17.320
is there is stuff that's not going to be in Pydantic Core.


00:55:17.320 --> 00:55:20.280
I don't think we'll add the URL type, for example.


00:55:20.280 --> 00:55:24.480
There'll be some custom types that we don't add.


00:55:24.480 --> 00:55:27.080
And obviously, if you want to implement your own types,


00:55:27.080 --> 00:55:30.320
then the way that we get around that is that Pydantic Core


00:55:30.320 --> 00:55:32.080
has basically a function validator,


00:55:32.080 --> 00:55:34.360
which is basically call a function,


00:55:34.360 --> 00:55:37.120
either having done some validation before or after,


00:55:37.120 --> 00:55:40.120
and return the result.


00:55:40.120 --> 00:55:42.580
So that's how we're going to provide a way


00:55:42.580 --> 00:55:45.760
to build validators without writing Rust.


00:55:45.760 --> 00:55:47.600
- Right, fantastic.


00:55:47.600 --> 00:55:51.040
All right, required versus nullable?


00:55:51.040 --> 00:55:53.720
- Yeah, probably a hangover from, again,


00:55:53.720 --> 00:55:57.720
me building Palantik on my own for what I needed,


00:55:57.720 --> 00:56:00.400
and also from, it kind of predated data classes,


00:56:00.400 --> 00:56:02.200
at least in some of the work.


00:56:02.200 --> 00:56:06.400
And so the real problem for me was the word optional,


00:56:06.400 --> 00:56:08.480
and the idea that you had a field that was required,


00:56:08.480 --> 00:56:10.180
but was literally called optional.


00:56:10.180 --> 00:56:14.120
Obviously, Pydantic's not the only library


00:56:14.120 --> 00:56:15.220
that has that problem.


00:56:15.220 --> 00:56:20.480
And the real solution is the pipe operator,


00:56:20.480 --> 00:56:21.920
which is the new way of doing unions,


00:56:21.920 --> 00:56:24.920
none, involves not using the word optional.


00:56:24.920 --> 00:56:26.160
You can obviously also get around it


00:56:26.160 --> 00:56:29.900
by using union of string int,


00:56:29.900 --> 00:56:34.060
But the point is that if you just have a field


00:56:34.060 --> 00:56:38.340
that is optional int, it is required but can be none.


00:56:38.340 --> 00:56:44.020
And that's really just to match data classes


00:56:44.020 --> 00:56:45.460
and other contexts.


00:56:45.460 --> 00:56:51.420
- Yeah, the new way to express optional


00:56:51.420 --> 00:56:54.700
for like string pipe none versus optional string.


00:56:54.700 --> 00:56:57.420
Yeah, that kind of set you free


00:56:57.420 --> 00:57:00.300
to think about this differently.


00:57:00.300 --> 00:57:02.180
- Yeah, also, I mean, I literally asked Guido


00:57:02.180 --> 00:57:04.600
about it at PyCon and he was like,


00:57:04.600 --> 00:57:05.980
he didn't say, yes, we made a mistake.


00:57:05.980 --> 00:57:09.940
He said, that's fixed by having pipe none,


00:57:09.940 --> 00:57:11.580
which is a roundabout way of saying


00:57:11.580 --> 00:57:13.060
we kind of made a mistake back then,


00:57:13.060 --> 00:57:15.260
but you know, typing has come a massively long way


00:57:15.260 --> 00:57:16.820
since someone settled on the word optional.


00:57:16.820 --> 00:57:19.300
So I get it, but it has been a source of confusion


00:57:19.300 --> 00:57:22.940
that's now being cleared up.


00:57:22.940 --> 00:57:23.760
- Yeah, for sure.


00:57:23.760 --> 00:57:26.340
And there's other things that have been changed as well.


00:57:26.340 --> 00:57:30.700
Right, used to have to say from typing import capital L list,


00:57:30.700 --> 00:57:33.220
you return a lowercase list, but it'd be a capital L list.


00:57:33.220 --> 00:57:34.100
And now it's like, you know what?


00:57:34.100 --> 00:57:35.900
Lowercase list works too.


00:57:35.900 --> 00:57:36.740
Right, you don't have to go and create these.


00:57:36.740 --> 00:57:38.660
- Now we just have the weird side case of any,


00:57:38.660 --> 00:57:40.500
where there isn't any function, but you can't use it,


00:57:40.500 --> 00:57:42.640
but we won't go down that line.


00:57:42.640 --> 00:57:44.720
- Yeah, for sure.


00:57:44.720 --> 00:57:48.540
Wanna talk about validated functions?


00:57:48.540 --> 00:57:51.260
- Yeah, I touched on them just now.


00:57:51.260 --> 00:57:54.580
And like I said, we have the idea of before.


00:57:54.580 --> 00:57:55.780
So we do a validation before,


00:57:55.780 --> 00:57:58.360
and then we pass the result of that validation to a function.


00:57:58.360 --> 00:58:00.740
We have validate afterwards.


00:58:00.740 --> 00:58:02.480
And plain, which doesn't do any validation,


00:58:02.480 --> 00:58:03.480
just calls the function.


00:58:03.480 --> 00:58:05.240
The most exciting thing, probably one


00:58:05.240 --> 00:58:08.960
of the things I'm most stoked for in Pydantic V2,


00:58:08.960 --> 00:58:10.680
is these wrap validators.


00:58:10.680 --> 00:58:13.480
So you will have read about middleware in Django


00:58:13.480 --> 00:58:15.340
or any web framework.


00:58:15.340 --> 00:58:18.700
We have this idea of an onion where we call a function, which


00:58:18.700 --> 00:58:21.720
takes a handler to call the next function.


00:58:21.720 --> 00:58:26.060
We have the same thing here in Pydantic V2,


00:58:26.060 --> 00:58:28.860
where we have these, I've called them wrap validators.


00:58:28.860 --> 00:58:31.860
They take a handler to a function and then they call that.


00:58:31.860 --> 00:58:35.060
The power here is obviously we can do some logic


00:58:35.060 --> 00:58:38.060
before the validator, we can do some logic after,


00:58:38.060 --> 00:58:40.660
we can catch errors, we can return a default value.


00:58:40.660 --> 00:58:45.660
It gives us loads of flexibility to do more powerful stuff.


00:58:45.660 --> 00:58:48.060
- Yeah, that's very neat.


00:58:48.060 --> 00:58:50.980
Yeah, you basically can do whatever you want


00:58:50.980 --> 00:58:54.640
and decide to delegate down to the chain of handlers


00:58:54.640 --> 00:58:56.180
if you want, or skip it, right?


00:58:56.180 --> 00:58:58.040
You say, this looks good to me,


00:58:58.040 --> 00:59:00.440
we're just gonna return a value here.


00:59:00.440 --> 00:59:02.120
- In particular with Pylantic one,


00:59:02.120 --> 00:59:04.900
there was no way to skip, yeah,


00:59:04.900 --> 00:59:06.600
to skip validation if you had a validator.


00:59:06.600 --> 00:59:09.120
So, which obviously caused a slowdown


00:59:09.120 --> 00:59:11.160
if let's say you had date time now,


00:59:11.160 --> 00:59:12.600
you still had to call the validator,


00:59:12.600 --> 00:59:14.500
which sure enough got a date time and was happy,


00:59:14.500 --> 00:59:15.760
but you had to go through that logic.


00:59:15.760 --> 00:59:17.720
Whereas here, we know it's a date time


00:59:17.720 --> 00:59:19.960
'cause we've written that code.


00:59:19.960 --> 00:59:22.560
There is the potential for people to make mistakes


00:59:22.560 --> 00:59:25.700
and not call the handler.


00:59:25.700 --> 00:59:27.920
If they wanted to return the raw value,


00:59:27.920 --> 00:59:31.720
then we can't stop them, but that's Python.


00:59:31.720 --> 00:59:33.480
There aren't always guardrails.


00:59:33.480 --> 00:59:36.440
- Right, yeah.


00:59:36.440 --> 00:59:40.000
Some of the power is in the flexibility, right?


00:59:40.000 --> 00:59:42.640
But that lets you do bad things as well.


00:59:42.640 --> 00:59:44.000
- Yeah. - You also have this,


00:59:44.000 --> 00:59:45.000
yeah, go ahead.


00:59:45.000 --> 00:59:46.280
- Sorry to interrupt.


00:59:46.280 --> 00:59:48.100
We could theoretically do some crazy thing


00:59:48.100 --> 00:59:49.680
where we checked if the handler was called


00:59:49.680 --> 00:59:50.920
and raised an error or a warning,


00:59:50.920 --> 00:59:53.560
but I think at this point we let people


00:59:53.560 --> 00:59:56.280
make their own mistakes if they insist.


00:59:56.280 --> 00:59:59.340
- Well, and you also would pay a performance price


00:59:59.340 --> 01:00:01.480
for all the places where it's used correctly.


01:00:01.480 --> 01:00:02.320
- Yeah.


01:00:02.320 --> 01:00:04.720
- Trying to do that kind of stuff, right?


01:00:04.720 --> 01:00:07.880
All right, more powerful aliases.


01:00:07.880 --> 01:00:09.560
- Yeah, this is a feature that I saw.


01:00:09.560 --> 01:00:11.400
- Tell us what aliases are and then,


01:00:11.400 --> 01:00:12.600
yeah, then what's the use here?


01:00:12.600 --> 01:00:14.880
- Aliases are the idea that we have a name


01:00:14.880 --> 01:00:17.320
for what we want to call a variable in our code,


01:00:17.320 --> 01:00:18.800
but we know that in the real world


01:00:18.800 --> 01:00:21.800
where the data is coming from, say on the front end,


01:00:21.800 --> 01:00:22.840
it's got a different name.


01:00:22.840 --> 01:00:24.960
Often it's CamelCase on the front end


01:00:24.960 --> 01:00:26.920
'cause it's JavaScript and we wanna use


01:00:26.920 --> 01:00:32.000
SnakeCase in Python, but also,


01:00:32.000 --> 01:00:34.400
we're using some API and it has to be called something


01:00:34.400 --> 01:00:35.880
when the data's coming in.


01:00:35.880 --> 01:00:38.360
And so we had that in Pydantic v1,


01:00:38.360 --> 01:00:39.720
the idea that you could have a field


01:00:39.720 --> 01:00:42.480
that was called something else externally.


01:00:42.480 --> 01:00:45.200
But this is actually a feature I saw in


01:00:46.000 --> 01:00:47.280
the Rust third library,


01:00:47.280 --> 01:00:49.680
which is the main validation library,


01:00:49.680 --> 01:00:50.680
this idea of flatten.


01:00:50.680 --> 01:00:52.520
So basically take a value,


01:00:52.520 --> 01:00:54.000
not just from the top level decks,


01:00:54.000 --> 01:00:55.840
but from deep down in some object,


01:00:55.840 --> 01:00:58.360
we pass it and use that for the field.


01:00:58.360 --> 01:00:59.560
And so again, this is one of the things.


01:00:59.560 --> 01:01:01.000
- I see this kind of stuff.


01:01:01.000 --> 01:01:01.820
Yeah, sorry.


01:01:01.820 --> 01:01:02.660
I see this stuff all the time


01:01:02.660 --> 01:01:05.780
where you will get some huge response from an API,


01:01:05.780 --> 01:01:06.620
but you're like,


01:01:06.620 --> 01:01:08.360
I just really want this little part here.


01:01:08.360 --> 01:01:10.120
And so what you end up having to do is say,


01:01:10.120 --> 01:01:12.780
okay, capture that result of the dictionary,


01:01:12.780 --> 01:01:14.600
then navigate down to the three levels


01:01:14.600 --> 01:01:15.640
and get the sub object,


01:01:15.640 --> 01:01:17.200
and then pass that to Pydantic.


01:01:17.200 --> 01:01:20.120
And here you could just say, the alias is,


01:01:20.120 --> 01:01:22.960
sort of traverse that down and start from there, right?


01:01:22.960 --> 01:01:24.640
- Exactly, and we get nice advances,


01:01:24.640 --> 01:01:26.000
just like if that thing's not there,


01:01:26.000 --> 01:01:28.480
we don't get an error because the get,


01:01:28.480 --> 01:01:32.220
none has no get method or whatever it might be.


01:01:32.220 --> 01:01:35.680
Pydantic will take care of just saying that feels missing


01:01:35.680 --> 01:01:39.080
if let's say baz was a string.


01:01:39.080 --> 01:01:42.840
So therefore we couldn't get baz, the second element.


01:01:42.840 --> 01:01:46.940
you know, quarks, whatever that is.


01:01:46.940 --> 01:01:49.120
- Yeah, so in the case you have here,


01:01:49.120 --> 01:01:52.980
you say the alias is a list and the list is baz


01:01:52.980 --> 01:01:54.440
and then two and quarks,


01:01:54.440 --> 01:01:57.200
these are things that are appearing in this JSON document,


01:01:57.200 --> 01:01:58.120
the dictionary.


01:01:58.120 --> 01:02:00.840
- Yeah, go ahead.


01:02:00.840 --> 01:02:01.660
- It's effectively some location,


01:02:01.660 --> 01:02:02.780
but what you'll notice again,


01:02:02.780 --> 01:02:04.540
is there's actually another outer list


01:02:04.540 --> 01:02:06.960
because we can have more than one of these.


01:02:06.960 --> 01:02:09.360
We can have it as deep as we like,


01:02:09.360 --> 01:02:13.560
sorry, as many different aliases to try as you want.


01:02:13.560 --> 01:02:17.280
- Right, yeah, so this actually traverses down,


01:02:17.280 --> 01:02:19.440
and the two means go to the third item


01:02:19.440 --> 01:02:20.920
'cause it's zero-based in the list


01:02:20.920 --> 01:02:22.160
and then look for that element.


01:02:22.160 --> 01:02:23.400
That's pretty powerful.


01:02:23.400 --> 01:02:26.200
- Yeah, and again, this is the kind of thing


01:02:26.200 --> 01:02:29.080
that we can do because Pylantic calls in Rust


01:02:29.080 --> 01:02:32.960
and the overhead of having aliases


01:02:32.960 --> 01:02:36.120
of multiple different types is basically absolutely minimal


01:02:36.120 --> 01:02:39.040
'cause in Rust, it's a single enum lookup,


01:02:39.040 --> 01:02:41.080
And if we have a simple alias of a string,


01:02:41.080 --> 01:02:43.920
we don't need to worry about any of that crazy logic


01:02:43.920 --> 01:02:44.760
to recurse down.


01:02:44.760 --> 01:02:47.760
We just take the top element out of the top level dictionary


01:02:47.760 --> 01:02:48.600
and move on.


01:02:48.600 --> 01:02:50.520
- Right on.


01:02:50.520 --> 01:02:52.080
Jonas asks, "Would this solve


01:02:52.080 --> 01:02:53.960
when my app gets Pascal case?


01:02:53.960 --> 01:02:55.160
I wanna work with snake case


01:02:55.160 --> 01:02:57.080
and then return a camel case."


01:02:57.080 --> 01:02:59.720
Is there some way to express that kind of stuff


01:02:59.720 --> 01:03:00.820
with aliases?


01:03:00.820 --> 01:03:02.600
- This does not, but we had,


01:03:02.600 --> 01:03:05.240
there was a pull request for Pylantic two,


01:03:05.240 --> 01:03:08.600
for Pylantic one, where we had load alias and dump alias.


01:03:08.600 --> 01:03:10.900
So a different alias when we were exporting.


01:03:10.900 --> 01:03:12.680
And I do intend to support that.


01:03:12.680 --> 01:03:14.940
So this particular feature is kind of related


01:03:14.940 --> 01:03:16.100
but won't solve it on its own.


01:03:16.100 --> 01:03:18.960
But yeah, I do intend to allow two different aliases.


01:03:18.960 --> 01:03:23.720
- Okay, speaking of loading and getting back out,


01:03:23.720 --> 01:03:26.220
improvements to dumping serialization and export.


01:03:26.220 --> 01:03:30.800
- Yeah, there's a bunch of stuff here


01:03:30.800 --> 01:03:32.160
that people have wanted for a long time,


01:03:32.160 --> 01:03:33.720
in particular being able to create


01:03:33.720 --> 01:03:36.700
a JSON compliant dictionary,


01:03:36.700 --> 01:03:40.120
but also people wanting to do their own customization.


01:03:40.120 --> 01:03:43.460
Again, my hope is that because that dumping logic


01:03:43.460 --> 01:03:45.540
will be implemented in Rust,


01:03:45.540 --> 01:03:48.480
we can get, I'm gonna call it kind of zero cost


01:03:48.480 --> 01:03:50.760
extra features, because in the end,


01:03:50.760 --> 01:03:52.760
it's like, should be just an enum lookup


01:03:52.760 --> 01:03:55.300
to do the complex stuff.


01:03:55.300 --> 01:03:56.500
And if we're not doing the complex stuff,


01:03:56.500 --> 01:03:58.660
we go the optimized path.


01:03:58.660 --> 01:04:03.100
Yeah, what we've realized is there's a whole bunch


01:04:03.100 --> 01:04:05.140
of different things that people might want.


01:04:05.140 --> 01:04:09.040
They might want the raw data, including sub-models.


01:04:09.040 --> 01:04:10.700
They might want what Dix does now,


01:04:10.700 --> 01:04:14.740
which is recursively convert models into dictionaries,


01:04:14.740 --> 01:04:17.620
but otherwise keep stuff unchanged.


01:04:17.620 --> 01:04:21.820
They might want a JSON-compliant dict, as I was saying,


01:04:21.820 --> 01:04:24.260
or they might want full serialization to JSON.


01:04:24.260 --> 01:04:26.100
And obviously, that last one in particular,


01:04:26.100 --> 01:04:27.260
we want to be quite well optimized.


01:04:27.260 --> 01:04:29.540
Well, we want them all to be, but yeah.


01:04:29.540 --> 01:04:31.820
- The last one's the most important, yeah.


01:04:31.820 --> 01:04:36.560
Yeah, we want to be able to provide someone


01:04:36.560 --> 01:04:39.680
complete flexibility without it harming performance


01:04:39.680 --> 01:04:40.840
in the case where they're not using that.


01:04:40.840 --> 01:04:44.160
And that's what I think Pylantic Core has allowed already


01:04:44.160 --> 01:04:48.760
on validation and I hope will allow on serialization.


01:04:48.760 --> 01:04:49.920
- Nice.


01:04:49.920 --> 01:04:51.200
All right, we're getting a little short on time.


01:04:51.200 --> 01:04:52.120
So let's maybe,


01:04:52.120 --> 01:04:56.760
let's, why don't you pick out some of the remaining stuff


01:04:56.760 --> 01:04:57.720
that you wanna focus on?


01:04:57.720 --> 01:04:58.840
I think maybe the most important


01:04:58.840 --> 01:05:00.200
is a model namespace cleanup.


01:05:00.200 --> 01:05:01.360
What do you think?


01:05:01.360 --> 01:05:03.760
I think context, I was just going to mention here,


01:05:03.760 --> 01:05:07.200
that's going to be another amazingly powerful escape


01:05:07.200 --> 01:05:10.520
hatch for some of the things people want to do.


01:05:10.520 --> 01:05:14.000
Obviously, the main use of it is for allowing validation


01:05:14.000 --> 01:05:15.120
against some dynamic data.


01:05:15.120 --> 01:05:16.800
But you can also update that thing.


01:05:16.800 --> 01:05:17.880
It's just a Python object.


01:05:17.880 --> 01:05:19.960
So if you wanted some case--


01:05:19.960 --> 01:05:21.840
we were talking about wrap validators earlier,


01:05:21.840 --> 01:05:24.160
where you've got errors and you want to raise a warning,


01:05:24.160 --> 01:05:27.080
you could append to context the warnings.


01:05:27.080 --> 01:05:29.640
So that is another super powerful escape


01:05:29.640 --> 01:05:32.720
without harming performance for everyone else.


01:05:32.720 --> 01:05:36.880
How it's gonna work with FastAPI,


01:05:36.880 --> 01:05:40.040
where the model, where you do the validation


01:05:40.040 --> 01:05:43.880
before calling user code, I don't know yet,


01:05:43.880 --> 01:05:44.720
but I'm sure Sebastian will find it.


01:05:44.720 --> 01:05:45.760
- Yeah, how do you provide that data


01:05:45.760 --> 01:05:47.160
that is the context, right?


01:05:47.160 --> 01:05:50.560
- You have another dependency, I guess,


01:05:50.560 --> 01:05:54.360
in FastAPI lingo that generates your context


01:05:54.360 --> 01:05:55.760
for that particular call.


01:05:55.760 --> 01:05:57.640
- Yeah, I was thinking some of the dependency injection


01:05:57.640 --> 01:06:01.280
which is not very popular in Python in general,


01:06:01.280 --> 01:06:04.320
but that might be the way you might register.


01:06:04.320 --> 01:06:06.320
Here's how to get the context


01:06:06.320 --> 01:06:08.760
for these types of models or something.


01:06:08.760 --> 01:06:09.760
- Yeah.


01:06:09.760 --> 01:06:11.720
- Yeah, I mean, Sebastian will decide,


01:06:11.720 --> 01:06:15.320
but that's what came to mind when I thought about it.


01:06:15.320 --> 01:06:16.160
Yeah, for sure.


01:06:16.160 --> 01:06:17.560
One quick question just on usage here.


01:06:17.560 --> 01:06:19.400
I see that you're saying user


01:06:19.400 --> 01:06:22.800
and then model validate JSON with this data.


01:06:22.800 --> 01:06:26.280
And you could also just say user star star data.


01:06:26.280 --> 01:06:27.520
I know you're doing this different here,


01:06:27.520 --> 01:06:28.620
so you can pass the context,


01:06:28.620 --> 01:06:32.920
but what would you say is the best way


01:06:32.920 --> 01:06:36.540
to create these objects on that kind of data?


01:06:36.540 --> 01:06:40.180
- Model validate JSON is gonna be there


01:06:40.180 --> 01:06:42.280
and it's gonna be named that or something close to that.


01:06:42.280 --> 01:06:44.460
And the point is that's taking a string of JSON


01:06:44.460 --> 01:06:48.100
or in this case, bytes of JSON and validating it directly.


01:06:48.100 --> 01:06:50.220
We talked about that earlier on.


01:06:50.220 --> 01:06:52.620
So that's not the same as user star star


01:06:52.620 --> 01:06:54.840
- Right, right, right. - data 'cause it's bytes.


01:06:54.840 --> 01:06:56.620
There's also model validate Python,


01:06:56.620 --> 01:07:00.460
which is effectively the same as model star star data,


01:07:00.460 --> 01:07:03.340
except that because obviously we basically don't trust


01:07:03.340 --> 01:07:05.740
anything you pass to it, that's all external data,


01:07:05.740 --> 01:07:07.340
you can't pass context that way.


01:07:07.340 --> 01:07:10.100
- Okay, yeah, exactly.


01:07:10.100 --> 01:07:10.940
All right.


01:07:10.940 --> 01:07:12.580
- Which I think comes onto your question


01:07:12.580 --> 01:07:15.340
about the cleanup of the namespace.


01:07:15.340 --> 01:07:16.340
- It does, yeah.


01:07:16.340 --> 01:07:20.300
So there are some breaking changes


01:07:20.300 --> 01:07:23.500
and there's a decent number about sort of renaming


01:07:23.500 --> 01:07:27.180
some of these model methods and stuff, right?


01:07:27.180 --> 01:07:29.680
Yeah, I'm not too worried about these because we're going to leave


01:07:29.680 --> 01:07:32.900
the old functions there with a depreciation warning on all of them.


01:07:32.900 --> 01:07:35.700
So that will be quite easy. The stuff that's going to be really hard


01:07:35.700 --> 01:07:39.500
in terms of breaking changes is where, for example,


01:07:39.500 --> 01:07:42.860
I've talked earlier about sets no longer being coercible to a list.


01:07:42.860 --> 01:07:44.860
There's no way to give a warning about that, really,


01:07:44.860 --> 01:07:47.420
without absolutely peppering Pydantic Core


01:07:47.420 --> 01:07:50.980
with warning logic that would be horrific.


01:07:50.980 --> 01:07:56.560
So there are going to be the things that are going to be most difficult for people are going to be like silent breaking changes.


01:07:56.560 --> 01:08:00.900
I'm not particularly worried about functions that give you a warning when you call them and say use the new name.


01:08:00.900 --> 01:08:05.660
It's going to be the silent stuff, or the fundamental changes in behavior that are going to be hard.


01:08:05.660 --> 01:08:10.380
But again, I, there's no way to make Pylantic better without doing that.


01:08:10.380 --> 01:08:11.420
Right.


01:08:11.420 --> 01:08:12.300
Fair.


01:08:12.300 --> 01:08:14.860
Okay, let's see.


01:08:16.780 --> 01:08:18.900
I think it's worth pointing out the error descriptions


01:08:18.900 --> 01:08:21.020
now have a documentation link.


01:08:21.020 --> 01:08:22.300
That's kind of interesting.


01:08:22.300 --> 01:08:25.220
- Yeah, I think that's gonna be super powerful for people.


01:08:25.220 --> 01:08:29.060
I don't know anyone who's ever used a Cargo and Clippy,


01:08:29.060 --> 01:08:31.620
which are the Rust tools for broadly speaking,


01:08:31.620 --> 01:08:33.100
linting and compiling.


01:08:33.100 --> 01:08:34.860
Whenever you get an error,


01:08:34.860 --> 01:08:37.460
there's a link basically to give you more information.


01:08:37.460 --> 01:08:40.140
And obviously a lot of these links


01:08:40.140 --> 01:08:42.420
will be being shown to developers through APIs


01:08:42.420 --> 01:08:45.280
and we can't provide all the information we might like


01:08:45.280 --> 01:08:47.720
in a one-sentence message.


01:08:47.720 --> 01:08:52.760
And so we're going to have a bit of Pydantic's docs dedicated


01:08:52.760 --> 01:08:55.120
to information on every single warning,


01:08:55.120 --> 01:08:59.360
every single error message, and what can happen.


01:08:59.360 --> 01:09:02.000
It leads to another interesting question about Pydantic 2


01:09:02.000 --> 01:09:03.720
and what we do with the documentation


01:09:03.720 --> 01:09:05.320
and the licensing of it.


01:09:05.320 --> 01:09:08.560
So Pydantic is definitely going to stay MIT-licensed.


01:09:08.560 --> 01:09:11.560
Might be dual-licensed Apache 2, if someone can tell me


01:09:11.560 --> 01:09:12.600
why that's necessary.


01:09:12.600 --> 01:09:15.540
but it's going to stay permissively licensed.


01:09:15.540 --> 01:09:19.200
But I'm kind of becoming aware that the documentation, which


01:09:19.200 --> 01:09:21.880
is valuable and will get better and more valuable,


01:09:21.880 --> 01:09:23.120
is currently MIT licensed.


01:09:23.120 --> 01:09:24.720
And some company could take it all


01:09:24.720 --> 01:09:28.920
and bang it on their domain totally legally.


01:09:28.920 --> 01:09:31.520
So I might change the documentation license


01:09:31.520 --> 01:09:33.880
to something a bit more restrictive.


01:09:33.880 --> 01:09:37.060
To say, for example, you can't take all of these error


01:09:37.060 --> 01:09:42.080
message documentation and just put them on your own domain,


01:09:42.080 --> 01:09:44.960
or at least we have some way of making that possible


01:09:44.960 --> 01:09:47.240
without allowing people to commercialize that.


01:09:47.240 --> 01:09:49.440
Mostly because it would get really confusing


01:09:49.440 --> 01:09:52.360
if there was Pydantic's documentation is up to date


01:09:52.360 --> 01:09:54.920
and Fubar company who published the whole same thing


01:09:54.920 --> 01:09:58.260
but leave it out of date and they both come up on GOOP.


01:09:58.260 --> 01:09:59.100
- Yeah.


01:09:59.100 --> 01:10:03.280
It's interesting to think about having this mixed model


01:10:03.280 --> 01:10:05.880
in your repo 'cause obviously you want Pydantic,


01:10:05.880 --> 01:10:08.840
the library to be wide open for people


01:10:09.720 --> 01:10:11.640
But then there's this supporting stuff


01:10:11.640 --> 01:10:14.360
that you might want to treat differently.


01:10:14.360 --> 01:10:18.360
- Yeah, and I know that the Linux distributions


01:10:18.360 --> 01:10:20.880
are gonna be super spiky if any of that stuff


01:10:20.880 --> 01:10:22.860
that's not MIT licensed got distributed, right?


01:10:22.860 --> 01:10:26.920
Because their package managers have to have stuff


01:10:26.920 --> 01:10:29.000
that's correctly licensed.


01:10:29.000 --> 01:10:32.400
I mean, obviously they allow stuff that's like GPL


01:10:32.400 --> 01:10:34.720
or something, but I'm thinking about something,


01:10:34.720 --> 01:10:37.280
probably GPL doesn't stop you publishing documentation.


01:10:37.280 --> 01:10:39.360
So yeah, it's an open question.


01:10:39.360 --> 01:10:41.640
I don't wanna have a separate repo for documentation


01:10:41.640 --> 01:10:44.840
'cause it'll make creating a PR that much higher friction,


01:10:44.840 --> 01:10:47.800
but I think I need to talk to an IP lawyer


01:10:47.800 --> 01:10:49.480
before I say anything authoritative on this


01:10:49.480 --> 01:10:51.360
is what I guess I'm getting to.


01:10:51.360 --> 01:10:54.200
- Yeah, I'm feeling entirely unqualified


01:10:54.200 --> 01:10:57.080
to give any advice on this,


01:10:57.080 --> 01:11:01.280
but it's tricky, right?


01:11:01.280 --> 01:11:02.600
As we were talking before we hit record,


01:11:02.600 --> 01:11:06.160
like if you have a license in a subfolder,


01:11:06.160 --> 01:11:10.600
Does that license override the more broad one?


01:11:10.600 --> 01:11:12.720
Do you have to go and change your broad license,


01:11:12.720 --> 01:11:15.000
your MIT license, say, here's the MIT license,


01:11:15.000 --> 01:11:18.600
except for this section of the repo?


01:11:18.600 --> 01:11:21.640
This doesn't apply to, see, it's license, you know,


01:11:21.640 --> 01:11:22.920
that's weird.


01:11:22.920 --> 01:11:24.520
- I presume that the big projects,


01:11:24.520 --> 01:11:26.720
the Djangos of this world and the NumPy


01:11:26.720 --> 01:11:28.200
must have thought about this stuff,


01:11:28.200 --> 01:11:29.840
so probably worth doing some research on them,


01:11:29.840 --> 01:11:32.360
but I'm thinking out loud and I probably need to come up


01:11:32.360 --> 01:11:36.080
with a conclusive answer before I say more.


01:11:36.080 --> 01:11:39.420
Well, it's called a plan, not a release, right?


01:11:39.420 --> 01:11:40.380
- Yeah.


01:11:40.380 --> 01:11:41.220
- Yeah.


01:11:41.220 --> 01:11:43.100
Okay, we talked about the,


01:11:43.100 --> 01:11:46.300
the Hidante becoming its own license.


01:11:46.300 --> 01:11:52.620
The one that I want to talk about is from,


01:11:52.620 --> 01:11:55.420
from ORM and friends, I guess.


01:11:55.420 --> 01:11:59.140
Yeah, maybe talk about this, these sections here.


01:11:59.140 --> 01:11:59.980
Some of these changes.


01:11:59.980 --> 01:12:01.740
- So there's a whole bunch of improvements here


01:12:01.740 --> 01:12:03.780
that we could talk about for an hour,


01:12:03.780 --> 01:12:05.700
probably on each one, let alone, let alone full,


01:12:05.700 --> 01:12:10.340
But the from ORM was a bit of a strange case


01:12:10.340 --> 01:12:12.020
where you had to have a config flag


01:12:12.020 --> 01:12:16.000
and then there was a method on a model.


01:12:16.000 --> 01:12:18.340
Pylantic Core has this built-in from attributes power


01:12:18.340 --> 01:12:21.580
which basically allows it to recurse


01:12:21.580 --> 01:12:24.340
through some Python object that is not a dictionary


01:12:24.340 --> 01:12:26.260
instead of a dictionary if you switch that on.


01:12:26.260 --> 01:12:28.940
So we talked earlier about aliases and about hunting down


01:12:28.940 --> 01:12:31.380
through some complex objects normally of dictionaries


01:12:31.380 --> 01:12:34.420
if that came in from JSON, but in lots of contexts,


01:12:34.420 --> 01:12:36.560
an ORM in particular, it's not, right?


01:12:36.560 --> 01:12:40.580
So from attributes, it lets you basically do that same


01:12:40.580 --> 01:12:42.380
finding things in an object


01:12:42.380 --> 01:12:43.780
from something that's not a dictionary


01:12:43.780 --> 01:12:47.860
via basically get attr and not get item effectively.


01:12:47.860 --> 01:12:49.940
- Yeah, yeah, and that makes a lot of sense


01:12:49.940 --> 01:12:52.060
'cause then you could just pass any class


01:12:52.060 --> 01:12:54.100
that you got from anywhere.


01:12:54.100 --> 01:12:56.220
You don't have to find a way to get it to a dictionary.


01:12:56.220 --> 01:12:57.060
- Yeah, exactly.


01:12:57.060 --> 01:12:59.540
And Pylantic should take care of that


01:12:59.540 --> 01:13:02.180
and give you nice warnings when at like the third level,


01:13:02.180 --> 01:13:04.300
it gets the right error


01:13:04.300 --> 01:13:06.500
or it gets a type error, it'll tell you type error


01:13:06.500 --> 01:13:08.820
and if it's an attribute error, it'll say not found.


01:13:08.820 --> 01:13:10.260
So-- - Got it.


01:13:10.260 --> 01:13:12.980
Yeah, so from ORM, to me that felt like,


01:13:12.980 --> 01:13:14.500
well, here's a thing, a way to integrate it


01:13:14.500 --> 01:13:16.480
with SQLAlchemy or something like that.


01:13:16.480 --> 01:13:18.400
But this is just more general to say,


01:13:18.400 --> 01:13:20.020
we're moving to something that just says,


01:13:20.020 --> 01:13:22.980
given any object, just go get it--


01:13:22.980 --> 01:13:25.380
- I mean, from ORM was a dumb name.


01:13:25.380 --> 01:13:28.840
You're quite right, it came exactly from


01:13:28.840 --> 01:13:31.700
compatibility with ORMs and SQLAlchemy, but in particular.


01:13:31.700 --> 01:13:34.300
But yeah, what we're actually doing


01:13:34.300 --> 01:13:35.340
is taking stuff from attributes.


01:13:35.340 --> 01:13:36.640
So the new name makes more sense


01:13:36.640 --> 01:13:39.920
and the new functionality is like a lot more powerful.


01:13:39.920 --> 01:13:43.780
- Would from attributes work on properties


01:13:43.780 --> 01:13:45.300
in addition to fields?


01:13:45.300 --> 01:13:46.620
- It should do, yeah.


01:13:46.620 --> 01:13:47.460
Yes, it does.


01:13:47.460 --> 01:13:48.980
There's a unit test for it, it does.


01:13:48.980 --> 01:13:50.200
- Okay, fantastic.


01:13:50.200 --> 01:13:53.340
That's really cool 'cause your class


01:13:53.340 --> 01:13:55.220
might have computed elements,


01:13:55.220 --> 01:13:57.480
but you want them to show up in your JSON, right?


01:13:57.480 --> 01:13:58.320
Or something like that.


01:13:58.320 --> 01:13:59.520
- Yeah. - Yeah, cool.


01:14:00.700 --> 01:14:05.100
All right, I think that might be it.


01:14:05.100 --> 01:14:07.440
No, one more question I have for you.


01:14:07.440 --> 01:14:11.780
When I was doing C, C++, C#,


01:14:11.780 --> 01:14:16.220
I remember thinking about numerical types a lot.


01:14:16.220 --> 01:14:19.420
Is it sufficient to have an int here?


01:14:19.420 --> 01:14:21.240
Do I need a long?


01:14:21.240 --> 01:14:22.800
Is it an unsigned long?


01:14:22.800 --> 01:14:24.020
How much data could it be?


01:14:24.020 --> 01:14:27.300
What happens if I have an int and I increment it,


01:14:27.300 --> 01:14:30.300
now it's negative 2.1 billion or whatever,


01:14:30.300 --> 01:14:32.940
Like there's all these weird scenarios


01:14:32.940 --> 01:14:36.600
that go away in Python because Python uses a slower


01:14:36.600 --> 01:14:40.140
but way more flexible numerical type, right?


01:14:40.140 --> 01:14:41.720
- Yep.


01:14:41.720 --> 01:14:42.940
- All the stuff happening in Rust,


01:14:42.940 --> 01:14:45.500
I feel like you might need to think about that a little bit.


01:14:45.500 --> 01:14:49.380
- Yeah, so it's all I32 in the case of Ints,


01:14:49.380 --> 01:14:53.480
so we're limited to whatever, so I64, sorry, I64.


01:14:53.480 --> 01:14:55.980
So whatever the limit is on I64,


01:14:55.980 --> 01:14:59.940
that does mean that you can't pass in,


01:14:59.940 --> 01:15:02.980
Yeah, you had it there, whatever two to the 64 is,


01:15:02.980 --> 01:15:04.900
there we are, that's the number.


01:15:04.900 --> 01:15:06.780
- I don't know how to say that number,


01:15:06.780 --> 01:15:10.700
but it's like a million trillion times nine or something.


01:15:10.700 --> 01:15:13.980
- Yeah, you would have trouble with,


01:15:13.980 --> 01:15:16.940
you could use a functional validator,


01:15:16.940 --> 01:15:18.380
you could find a way around it if you had to,


01:15:18.380 --> 01:15:21.780
but yeah, I think that's a price worth paying


01:15:21.780 --> 01:15:25.620
for the fact that we can do integer stuff


01:15:25.620 --> 01:15:26.440
really quickly, right?


01:15:26.440 --> 01:15:28.860
And we can do bounds checks much more quickly.


01:15:29.820 --> 01:15:32.580
Yeah, and we have, obviously, we have nice errors in there


01:15:32.580 --> 01:15:34.140
if you do pass in something bigger than that,


01:15:34.140 --> 01:15:39.140
or if you pass float inf, again, we'll get infinity,


01:15:39.140 --> 01:15:40.940
same as we would if you got a number above that,


01:15:40.940 --> 01:15:43.620
or float nan, again, you'll get int,


01:15:43.620 --> 01:15:44.900
you know, that's not allowed.


01:15:44.900 --> 01:15:47.140
So those cases are all taken care of


01:15:47.140 --> 01:15:48.380
and they give you a nice error,


01:15:48.380 --> 01:15:51.560
and there would be an escape hatch if you really had to.


01:15:51.560 --> 01:15:54.220
- Right, so the escape hatch could be,


01:15:54.220 --> 01:15:56.700
you might write a validator that checks,


01:15:56.700 --> 01:15:58.980
is the number, in Python it checks,


01:15:58.980 --> 01:16:01.340
is the number bigger than this limit?


01:16:01.340 --> 01:16:03.820
If it is, raise an exception, say, number two big


01:16:03.820 --> 01:16:04.660
or something like that.


01:16:04.660 --> 01:16:07.100
- Yeah, I mean, there isn't actually an escape hatch


01:16:07.100 --> 01:16:09.780
in the case of JSON, 'cause we have to do the parsing


01:16:09.780 --> 01:16:10.600
before we get there.


01:16:10.600 --> 01:16:13.220
So you'd have to parse your JSON externally


01:16:13.220 --> 01:16:14.940
and then parse it in as a Python object


01:16:14.940 --> 01:16:17.140
and do something weird, but--


01:16:17.140 --> 01:16:20.520
- It's uncommon that you get insanely large numbers


01:16:20.520 --> 01:16:21.420
like this.


01:16:21.420 --> 01:16:23.580
- I think that the insanely large numbers like that


01:16:23.580 --> 01:16:25.820
come up when people try and break things.


01:16:25.820 --> 01:16:26.660
Almost as if they're trying to--


01:16:26.660 --> 01:16:27.480
- Yeah, they try to break things


01:16:27.480 --> 01:16:32.280
or they're trying to do some odd math problem


01:16:32.280 --> 01:16:34.320
where like I'm trying to use recursion to compute


01:16:34.320 --> 01:16:36.740
and see how many prime, something like that.


01:16:36.740 --> 01:16:39.600
But in the general day to day of I'm accepting


01:16:39.600 --> 01:16:44.080
like user input over an API, you know.


01:16:44.080 --> 01:16:47.000
- What I would say is that as a Unix timestamp


01:16:47.000 --> 01:16:50.760
in milliseconds is beyond 999 in years, right?


01:16:50.760 --> 01:16:53.560
It's beyond the date that anyone's ever gonna wanna use.


01:16:54.720 --> 01:16:58.220
So I don't see that being a problem really.


01:16:58.220 --> 01:16:59.960
- Yeah, I don't either.


01:16:59.960 --> 01:17:02.340
Actually, I think there's probably,


01:17:02.340 --> 01:17:03.780
I don't know how to make it happen,


01:17:03.780 --> 01:17:07.560
but there's probably some interesting performance story


01:17:07.560 --> 01:17:09.640
for Python getting faster,


01:17:09.640 --> 01:17:11.760
if it could work with real numerical types


01:17:11.760 --> 01:17:14.600
rather than these super flexible numerical types.


01:17:14.600 --> 01:17:17.420
You know, a lot of times you'll see examples of math


01:17:17.420 --> 01:17:20.400
and it's like, well, okay, this, you know,


01:17:20.400 --> 01:17:24.720
pi long object thing, instead of working just with,


01:17:24.720 --> 01:17:27.240
you know, true ints and floats and stuff,


01:17:27.240 --> 01:17:28.160
really slows it down.


01:17:28.160 --> 01:17:30.320
So I don't know, I see a future maybe someday


01:17:30.320 --> 01:17:32.520
where Python actually adopts


01:17:32.520 --> 01:17:34.960
these sort of limited types like this potentially.


01:17:34.960 --> 01:17:37.080
- But isn't that what kind of libraries like Number


01:17:37.080 --> 01:17:40.280
are doing, they're allowing you to selectively compile


01:17:40.280 --> 01:17:42.920
a function without going completely off on a tangent.


01:17:42.920 --> 01:17:44.160
- Right, exactly.


01:17:44.160 --> 01:17:46.600
There you explicitly say whether it's an int


01:17:46.600 --> 01:17:47.880
or stuff like that, right?


01:17:49.120 --> 01:17:51.080
I think the other option would be,


01:17:51.080 --> 01:17:52.800
another way would be to say,


01:17:52.800 --> 01:17:54.480
you don't wanna be writing Python at that point


01:17:54.480 --> 01:17:58.140
'cause you want all the tools available in Rust syntax


01:17:58.140 --> 01:18:01.720
to allow you to say all the stuff you wanna be able to say


01:18:01.720 --> 01:18:03.320
and do integer overflow nicely.


01:18:03.320 --> 01:18:05.240
So the other option would be,


01:18:05.240 --> 01:18:07.320
at some point there'll be a way to basically write Rust


01:18:07.320 --> 01:18:09.840
even more easily than now inside Python.


01:18:09.840 --> 01:18:11.360
Those of us who are using PyCharm


01:18:11.360 --> 01:18:13.480
and are really lucky that we get PyCharm


01:18:13.480 --> 01:18:15.220
and we can get basically syntax highlighting


01:18:15.220 --> 01:18:18.600
in any random string, that doesn't seem too crazy.


01:18:18.600 --> 01:18:21.080
and obviously even more so if you were importing a file.


01:18:21.080 --> 01:18:23.380
So I think there are lots of ways around it.


01:18:23.380 --> 01:18:25.520
Yeah.


01:18:25.520 --> 01:18:26.420
- Yeah, we'll see.


01:18:26.420 --> 01:18:29.000
Maybe more stuff to come together


01:18:29.000 --> 01:18:30.880
with the WebAssembly feature, who knows?


01:18:30.880 --> 01:18:32.360
Anyway, a lot of stuff to think about.


01:18:32.360 --> 01:18:34.600
I think this is, I didn't bring this up


01:18:34.600 --> 01:18:36.400
because I feel like this is a problem or anything.


01:18:36.400 --> 01:18:38.840
I brought it up just 'cause I wanted people to be maybe


01:18:38.840 --> 01:18:41.680
aware that there are some slightly different


01:18:41.680 --> 01:18:44.400
data types at play here since it's going through Rust.


01:18:44.400 --> 01:18:45.480
- Yeah, I think it's important to see


01:18:45.480 --> 01:18:48.180
that under the hood we are doing, yeah, yeah, exactly.


01:18:48.180 --> 01:18:53.180
And so we didn't talk about date, time, date, time, time,


01:18:53.180 --> 01:18:57.420
time delta validation, but I've built a library in Rust


01:18:57.420 --> 01:19:00.240
for doing that a bit faster than all the ones I could find


01:19:00.240 --> 01:19:02.940
that is, for me, makes the right compromise


01:19:02.940 --> 01:19:03.980
called speed date.


01:19:03.980 --> 01:19:06.940
And that is having to deal with


01:19:06.940 --> 01:19:08.240
exactly those overflow problems.


01:19:08.240 --> 01:19:11.060
And I fuzzed this library a great deal


01:19:11.060 --> 01:19:13.940
and found a whole bunch of overflow issues by fuzzing it


01:19:13.940 --> 01:19:16.300
because yeah, when you're doing raw parsing


01:19:16.300 --> 01:19:20.840
in Rust, you have to think about that stuff.


01:19:20.840 --> 01:19:22.380
Those of us who come from a Python background


01:19:22.380 --> 01:19:24.200
haven't even thought about, you know,


01:19:24.200 --> 01:19:25.800
the idea that adding two numbers is scary


01:19:25.800 --> 01:19:27.680
and might result in a panic.


01:19:27.680 --> 01:19:30.680
- Yeah, honestly, I hadn't thought about it before.


01:19:30.680 --> 01:19:33.020
It's kind of nice to just not have to worry


01:19:33.020 --> 01:19:33.860
about those things.


01:19:33.860 --> 01:19:36.240
You used to just always have to consider, you know,


01:19:36.240 --> 01:19:38.920
is it okay to add, is it okay to multiply these things?


01:19:38.920 --> 01:19:42.200
Because even if that's just an intermediate value,


01:19:42.200 --> 01:19:44.560
something insane might happen along the way, right?


01:19:44.560 --> 01:19:45.720
- Yep.


01:19:45.720 --> 01:19:47.120
- Yeah, cool.


01:19:47.120 --> 01:19:49.120
All right, well, thank you so much


01:19:49.120 --> 01:19:51.840
for working on Pydantic, putting it out there.


01:19:51.840 --> 01:19:55.980
I know it's made my code and my projects much nicer.


01:19:55.980 --> 01:19:59.780
72,000 other people agree, it seems like.


01:19:59.780 --> 01:20:01.800
- No problem, thank you very much.


01:20:01.800 --> 01:20:03.520
And thank you so much to all of the people


01:20:03.520 --> 01:20:05.600
who help with Pydantic in every way,


01:20:05.600 --> 01:20:08.360
from like Eric and Sebastian and people


01:20:08.360 --> 01:20:10.600
who work on it quite a lot,


01:20:10.600 --> 01:20:12.960
but also to all the people who create issues


01:20:12.960 --> 01:20:14.360
and submit one pull request.


01:20:14.360 --> 01:20:16.720
It makes my job a lot more fun that it's not just me


01:20:16.720 --> 01:20:19.880
sitting in an ivory tower doing it on my own.


01:20:19.880 --> 01:20:21.360
- Yeah, absolutely.


01:20:21.360 --> 01:20:24.400
It's much more fun to work on projects with people.


01:20:24.400 --> 01:20:25.600
- Absolutely.


01:20:25.600 --> 01:20:27.840
- Magnus says, "Thanks for the great show


01:20:27.840 --> 01:20:28.960
"and all the work on Pydantic.


01:20:28.960 --> 01:20:30.480
"Looking forward to Pydantic 2."


01:20:30.480 --> 01:20:32.040
Right on.


01:20:32.040 --> 01:20:34.160
Now, before we get out of here, final two questions.


01:20:34.160 --> 01:20:36.600
If you're gonna write some Python code, work on Pydantic,


01:20:36.600 --> 01:20:38.900
what editor do you pull up?


01:20:38.900 --> 01:20:40.080
- I pull up PyCharm.


01:20:40.080 --> 01:20:41.480
I'm a complete convert.


01:20:41.480 --> 01:20:42.720
I completely rely on it.


01:20:43.840 --> 01:20:44.880
- Yeah.


01:20:44.880 --> 01:20:45.720
- Right on.


01:20:45.720 --> 01:20:50.720
And notable PyPI or even a cargo package, I suppose,


01:20:50.720 --> 01:20:53.520
whatever you wanna shout out to some external library


01:20:53.520 --> 01:20:54.840
out there that you think is pretty cool.


01:20:54.840 --> 01:20:58.360
- It's not gonna be particularly interesting


01:20:58.360 --> 01:20:59.320
because we've talked about it already,


01:20:59.320 --> 01:21:01.880
but Py03, I'm like forever impressed


01:21:01.880 --> 01:21:02.880
by what those guys have done.


01:21:02.880 --> 01:21:05.380
And obviously they've made what I'm working on here possible


01:21:05.380 --> 01:21:06.520
and they've been really helpful for me


01:21:06.520 --> 01:21:08.040
when I've asked dumb Rust questions.


01:21:08.040 --> 01:21:09.240
So yeah, thank you to them.


01:21:09.240 --> 01:21:12.760
And yeah, if you're ever thinking about getting into Rust,


01:21:12.760 --> 01:21:14.840
doing it from Python is a really neat way


01:21:14.840 --> 01:21:17.280
where when you can't work out what the hell's going on,


01:21:17.280 --> 01:21:19.800
you can kind of fall back to Python sometimes.


01:21:19.800 --> 01:21:21.320
- Right on.


01:21:21.320 --> 01:21:22.920
There's an audience question a while back


01:21:22.920 --> 01:21:25.360
about any resources that you might recommend


01:21:25.360 --> 01:21:28.400
for learning Rust or on the journey


01:21:28.400 --> 01:21:30.840
to getting to Py03 and so on.


01:21:30.840 --> 01:21:34.640
- No, I'm like, people always ask me,


01:21:34.640 --> 01:21:36.160
how did I learn to code and where did I do it?


01:21:36.160 --> 01:21:37.880
And I basically smash my head against the wall


01:21:37.880 --> 01:21:38.920
until it compiled.


01:21:38.920 --> 01:21:39.920
(laughing)


01:21:39.920 --> 01:21:40.800
- Yeah, I hear that.


01:21:40.800 --> 01:21:42.260
That's a pretty common way.


01:21:42.260 --> 01:21:44.100
Okay, final call to action.


01:21:44.100 --> 01:21:47.380
People are interested, excited, they have feedback,


01:21:47.380 --> 01:21:51.020
something like that, they want to try out Pydantic 2.


01:21:51.020 --> 01:21:53.660
- Particularly if you're using an unusual environment,


01:21:53.660 --> 01:21:57.040
install Pydantic Core right now, pip install Pydantic Core,


01:21:57.040 --> 01:22:00.280
and just run the simple example as one,


01:22:00.280 --> 01:22:02.320
for example, on the release, check it compiles,


01:22:02.320 --> 01:22:04.660
and if you find an environment where it doesn't work,


01:22:04.660 --> 01:22:06.900
so it not compiles but runs, let me know,


01:22:06.900 --> 01:22:09.100
'cause that'll be easier to fix sooner rather than later,


01:22:09.100 --> 01:22:12.620
And then most of all, once we get to the betas


01:22:12.620 --> 01:22:16.540
of an alphas of Pydantic V2, please come and try it then,


01:22:16.540 --> 01:22:18.180
because again, it'll be a lot easier to fix it


01:22:18.180 --> 01:22:20.260
before it's released than after.


01:22:20.260 --> 01:22:21.100
- Yeah, absolutely.


01:22:21.100 --> 01:22:22.580
- And I'll do a lot of shouting on Twitter about that


01:22:22.580 --> 01:22:24.340
when the time comes.


01:22:24.340 --> 01:22:25.180
- Perfect.


01:22:25.180 --> 01:22:27.260
All right, Samuel, thank you so much for being here.


01:22:27.260 --> 01:22:29.380
Thank you for your work on Pydantic and everything else.


01:22:29.380 --> 01:22:30.540
Yeah, yeah, you bet.


01:22:30.540 --> 01:22:31.700
As always, see you later.


01:22:31.700 --> 01:22:32.780
- Cheers.


01:22:32.780 --> 01:22:33.820
Bye-bye.

